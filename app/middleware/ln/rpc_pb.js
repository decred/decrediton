/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var google_api_annotations_pb = require('./google/api/annotations_pb.js');
goog.exportSymbol('proto.lnrpc.AbandonChannelRequest', null, global);
goog.exportSymbol('proto.lnrpc.AbandonChannelResponse', null, global);
goog.exportSymbol('proto.lnrpc.AddInvoiceResponse', null, global);
goog.exportSymbol('proto.lnrpc.AddressType', null, global);
goog.exportSymbol('proto.lnrpc.BakeMacaroonRequest', null, global);
goog.exportSymbol('proto.lnrpc.BakeMacaroonResponse', null, global);
goog.exportSymbol('proto.lnrpc.Chain', null, global);
goog.exportSymbol('proto.lnrpc.ChanBackupExportRequest', null, global);
goog.exportSymbol('proto.lnrpc.ChanBackupSnapshot', null, global);
goog.exportSymbol('proto.lnrpc.ChanInfoRequest', null, global);
goog.exportSymbol('proto.lnrpc.ChanPointShim', null, global);
goog.exportSymbol('proto.lnrpc.ChangePasswordRequest', null, global);
goog.exportSymbol('proto.lnrpc.ChangePasswordResponse', null, global);
goog.exportSymbol('proto.lnrpc.Channel', null, global);
goog.exportSymbol('proto.lnrpc.ChannelAcceptRequest', null, global);
goog.exportSymbol('proto.lnrpc.ChannelAcceptResponse', null, global);
goog.exportSymbol('proto.lnrpc.ChannelBackup', null, global);
goog.exportSymbol('proto.lnrpc.ChannelBackupSubscription', null, global);
goog.exportSymbol('proto.lnrpc.ChannelBackups', null, global);
goog.exportSymbol('proto.lnrpc.ChannelBalanceRequest', null, global);
goog.exportSymbol('proto.lnrpc.ChannelBalanceResponse', null, global);
goog.exportSymbol('proto.lnrpc.ChannelCloseSummary', null, global);
goog.exportSymbol('proto.lnrpc.ChannelCloseSummary.ClosureType', null, global);
goog.exportSymbol('proto.lnrpc.ChannelCloseUpdate', null, global);
goog.exportSymbol('proto.lnrpc.ChannelEdge', null, global);
goog.exportSymbol('proto.lnrpc.ChannelEdgeUpdate', null, global);
goog.exportSymbol('proto.lnrpc.ChannelEventSubscription', null, global);
goog.exportSymbol('proto.lnrpc.ChannelEventUpdate', null, global);
goog.exportSymbol('proto.lnrpc.ChannelEventUpdate.UpdateType', null, global);
goog.exportSymbol('proto.lnrpc.ChannelFeeReport', null, global);
goog.exportSymbol('proto.lnrpc.ChannelGraph', null, global);
goog.exportSymbol('proto.lnrpc.ChannelGraphRequest', null, global);
goog.exportSymbol('proto.lnrpc.ChannelOpenUpdate', null, global);
goog.exportSymbol('proto.lnrpc.ChannelPoint', null, global);
goog.exportSymbol('proto.lnrpc.CloseChannelRequest', null, global);
goog.exportSymbol('proto.lnrpc.CloseStatusUpdate', null, global);
goog.exportSymbol('proto.lnrpc.ClosedChannelUpdate', null, global);
goog.exportSymbol('proto.lnrpc.ClosedChannelsRequest', null, global);
goog.exportSymbol('proto.lnrpc.ClosedChannelsResponse', null, global);
goog.exportSymbol('proto.lnrpc.ConfirmationUpdate', null, global);
goog.exportSymbol('proto.lnrpc.ConnectPeerRequest', null, global);
goog.exportSymbol('proto.lnrpc.ConnectPeerResponse', null, global);
goog.exportSymbol('proto.lnrpc.DebugLevelRequest', null, global);
goog.exportSymbol('proto.lnrpc.DebugLevelResponse', null, global);
goog.exportSymbol('proto.lnrpc.DeleteAllPaymentsRequest', null, global);
goog.exportSymbol('proto.lnrpc.DeleteAllPaymentsResponse', null, global);
goog.exportSymbol('proto.lnrpc.DisconnectPeerRequest', null, global);
goog.exportSymbol('proto.lnrpc.DisconnectPeerResponse', null, global);
goog.exportSymbol('proto.lnrpc.EdgeLocator', null, global);
goog.exportSymbol('proto.lnrpc.EstimateFeeRequest', null, global);
goog.exportSymbol('proto.lnrpc.EstimateFeeResponse', null, global);
goog.exportSymbol('proto.lnrpc.ExportChannelBackupRequest', null, global);
goog.exportSymbol('proto.lnrpc.Feature', null, global);
goog.exportSymbol('proto.lnrpc.FeatureBit', null, global);
goog.exportSymbol('proto.lnrpc.FeeLimit', null, global);
goog.exportSymbol('proto.lnrpc.FeeReportRequest', null, global);
goog.exportSymbol('proto.lnrpc.FeeReportResponse', null, global);
goog.exportSymbol('proto.lnrpc.ForwardingEvent', null, global);
goog.exportSymbol('proto.lnrpc.ForwardingHistoryRequest', null, global);
goog.exportSymbol('proto.lnrpc.ForwardingHistoryResponse', null, global);
goog.exportSymbol('proto.lnrpc.FundingShim', null, global);
goog.exportSymbol('proto.lnrpc.FundingShimCancel', null, global);
goog.exportSymbol('proto.lnrpc.FundingStateStepResp', null, global);
goog.exportSymbol('proto.lnrpc.FundingTransitionMsg', null, global);
goog.exportSymbol('proto.lnrpc.GenSeedRequest', null, global);
goog.exportSymbol('proto.lnrpc.GenSeedResponse', null, global);
goog.exportSymbol('proto.lnrpc.GetInfoRequest', null, global);
goog.exportSymbol('proto.lnrpc.GetInfoResponse', null, global);
goog.exportSymbol('proto.lnrpc.GetTransactionsRequest', null, global);
goog.exportSymbol('proto.lnrpc.GraphTopologySubscription', null, global);
goog.exportSymbol('proto.lnrpc.GraphTopologyUpdate', null, global);
goog.exportSymbol('proto.lnrpc.HTLC', null, global);
goog.exportSymbol('proto.lnrpc.HTLCAttempt', null, global);
goog.exportSymbol('proto.lnrpc.HTLCAttempt.HTLCStatus', null, global);
goog.exportSymbol('proto.lnrpc.Hop', null, global);
goog.exportSymbol('proto.lnrpc.HopHint', null, global);
goog.exportSymbol('proto.lnrpc.InitWalletRequest', null, global);
goog.exportSymbol('proto.lnrpc.InitWalletResponse', null, global);
goog.exportSymbol('proto.lnrpc.Invoice', null, global);
goog.exportSymbol('proto.lnrpc.Invoice.InvoiceState', null, global);
goog.exportSymbol('proto.lnrpc.InvoiceHTLC', null, global);
goog.exportSymbol('proto.lnrpc.InvoiceHTLCState', null, global);
goog.exportSymbol('proto.lnrpc.InvoiceSubscription', null, global);
goog.exportSymbol('proto.lnrpc.KeyDescriptor', null, global);
goog.exportSymbol('proto.lnrpc.KeyLocator', null, global);
goog.exportSymbol('proto.lnrpc.LightningAddress', null, global);
goog.exportSymbol('proto.lnrpc.LightningNode', null, global);
goog.exportSymbol('proto.lnrpc.ListChannelsRequest', null, global);
goog.exportSymbol('proto.lnrpc.ListChannelsResponse', null, global);
goog.exportSymbol('proto.lnrpc.ListInvoiceRequest', null, global);
goog.exportSymbol('proto.lnrpc.ListInvoiceResponse', null, global);
goog.exportSymbol('proto.lnrpc.ListPaymentsRequest', null, global);
goog.exportSymbol('proto.lnrpc.ListPaymentsResponse', null, global);
goog.exportSymbol('proto.lnrpc.ListPeersRequest', null, global);
goog.exportSymbol('proto.lnrpc.ListPeersResponse', null, global);
goog.exportSymbol('proto.lnrpc.ListUnspentRequest', null, global);
goog.exportSymbol('proto.lnrpc.ListUnspentResponse', null, global);
goog.exportSymbol('proto.lnrpc.MPPRecord', null, global);
goog.exportSymbol('proto.lnrpc.MacaroonPermission', null, global);
goog.exportSymbol('proto.lnrpc.MultiChanBackup', null, global);
goog.exportSymbol('proto.lnrpc.NetworkInfo', null, global);
goog.exportSymbol('proto.lnrpc.NetworkInfoRequest', null, global);
goog.exportSymbol('proto.lnrpc.NewAddressRequest', null, global);
goog.exportSymbol('proto.lnrpc.NewAddressResponse', null, global);
goog.exportSymbol('proto.lnrpc.NodeAddress', null, global);
goog.exportSymbol('proto.lnrpc.NodeInfo', null, global);
goog.exportSymbol('proto.lnrpc.NodeInfoRequest', null, global);
goog.exportSymbol('proto.lnrpc.NodePair', null, global);
goog.exportSymbol('proto.lnrpc.NodeUpdate', null, global);
goog.exportSymbol('proto.lnrpc.OpenChannelRequest', null, global);
goog.exportSymbol('proto.lnrpc.OpenStatusUpdate', null, global);
goog.exportSymbol('proto.lnrpc.OutPoint', null, global);
goog.exportSymbol('proto.lnrpc.PayReq', null, global);
goog.exportSymbol('proto.lnrpc.PayReqString', null, global);
goog.exportSymbol('proto.lnrpc.Payment', null, global);
goog.exportSymbol('proto.lnrpc.Payment.PaymentStatus', null, global);
goog.exportSymbol('proto.lnrpc.PaymentHash', null, global);
goog.exportSymbol('proto.lnrpc.Peer', null, global);
goog.exportSymbol('proto.lnrpc.Peer.SyncType', null, global);
goog.exportSymbol('proto.lnrpc.PeerEvent', null, global);
goog.exportSymbol('proto.lnrpc.PeerEvent.EventType', null, global);
goog.exportSymbol('proto.lnrpc.PeerEventSubscription', null, global);
goog.exportSymbol('proto.lnrpc.PendingChannelsRequest', null, global);
goog.exportSymbol('proto.lnrpc.PendingChannelsResponse', null, global);
goog.exportSymbol('proto.lnrpc.PendingChannelsResponse.ClosedChannel', null, global);
goog.exportSymbol('proto.lnrpc.PendingChannelsResponse.ForceClosedChannel', null, global);
goog.exportSymbol('proto.lnrpc.PendingChannelsResponse.PendingChannel', null, global);
goog.exportSymbol('proto.lnrpc.PendingChannelsResponse.PendingOpenChannel', null, global);
goog.exportSymbol('proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel', null, global);
goog.exportSymbol('proto.lnrpc.PendingHTLC', null, global);
goog.exportSymbol('proto.lnrpc.PendingUpdate', null, global);
goog.exportSymbol('proto.lnrpc.PolicyUpdateRequest', null, global);
goog.exportSymbol('proto.lnrpc.PolicyUpdateResponse', null, global);
goog.exportSymbol('proto.lnrpc.QueryRoutesRequest', null, global);
goog.exportSymbol('proto.lnrpc.QueryRoutesResponse', null, global);
goog.exportSymbol('proto.lnrpc.RestoreBackupResponse', null, global);
goog.exportSymbol('proto.lnrpc.RestoreChanBackupRequest', null, global);
goog.exportSymbol('proto.lnrpc.Route', null, global);
goog.exportSymbol('proto.lnrpc.RouteHint', null, global);
goog.exportSymbol('proto.lnrpc.RoutingPolicy', null, global);
goog.exportSymbol('proto.lnrpc.SendCoinsRequest', null, global);
goog.exportSymbol('proto.lnrpc.SendCoinsResponse', null, global);
goog.exportSymbol('proto.lnrpc.SendManyRequest', null, global);
goog.exportSymbol('proto.lnrpc.SendManyResponse', null, global);
goog.exportSymbol('proto.lnrpc.SendRequest', null, global);
goog.exportSymbol('proto.lnrpc.SendResponse', null, global);
goog.exportSymbol('proto.lnrpc.SendToRouteRequest', null, global);
goog.exportSymbol('proto.lnrpc.SignMessageRequest', null, global);
goog.exportSymbol('proto.lnrpc.SignMessageResponse', null, global);
goog.exportSymbol('proto.lnrpc.StopRequest', null, global);
goog.exportSymbol('proto.lnrpc.StopResponse', null, global);
goog.exportSymbol('proto.lnrpc.Transaction', null, global);
goog.exportSymbol('proto.lnrpc.TransactionDetails', null, global);
goog.exportSymbol('proto.lnrpc.UnlockWalletRequest', null, global);
goog.exportSymbol('proto.lnrpc.UnlockWalletResponse', null, global);
goog.exportSymbol('proto.lnrpc.Utxo', null, global);
goog.exportSymbol('proto.lnrpc.VerifyChanBackupResponse', null, global);
goog.exportSymbol('proto.lnrpc.VerifyMessageRequest', null, global);
goog.exportSymbol('proto.lnrpc.VerifyMessageResponse', null, global);
goog.exportSymbol('proto.lnrpc.WalletBalanceRequest', null, global);
goog.exportSymbol('proto.lnrpc.WalletBalanceResponse', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.GenSeedRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.GenSeedRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.GenSeedRequest.displayName = 'proto.lnrpc.GenSeedRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.GenSeedRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.GenSeedRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.GenSeedRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GenSeedRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    aezeedPassphrase: msg.getAezeedPassphrase_asB64(),
    seedEntropy: msg.getSeedEntropy_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.GenSeedRequest}
 */
proto.lnrpc.GenSeedRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.GenSeedRequest;
  return proto.lnrpc.GenSeedRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.GenSeedRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.GenSeedRequest}
 */
proto.lnrpc.GenSeedRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAezeedPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSeedEntropy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.GenSeedRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.GenSeedRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.GenSeedRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GenSeedRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAezeedPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getSeedEntropy_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes aezeed_passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.GenSeedRequest.prototype.getAezeedPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes aezeed_passphrase = 1;
 * This is a type-conversion wrapper around `getAezeedPassphrase()`
 * @return {string}
 */
proto.lnrpc.GenSeedRequest.prototype.getAezeedPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAezeedPassphrase()));
};


/**
 * optional bytes aezeed_passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAezeedPassphrase()`
 * @return {!Uint8Array}
 */
proto.lnrpc.GenSeedRequest.prototype.getAezeedPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAezeedPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.GenSeedRequest.prototype.setAezeedPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes seed_entropy = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.GenSeedRequest.prototype.getSeedEntropy = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes seed_entropy = 2;
 * This is a type-conversion wrapper around `getSeedEntropy()`
 * @return {string}
 */
proto.lnrpc.GenSeedRequest.prototype.getSeedEntropy_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSeedEntropy()));
};


/**
 * optional bytes seed_entropy = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSeedEntropy()`
 * @return {!Uint8Array}
 */
proto.lnrpc.GenSeedRequest.prototype.getSeedEntropy_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSeedEntropy()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.GenSeedRequest.prototype.setSeedEntropy = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.GenSeedResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.GenSeedResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.GenSeedResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.GenSeedResponse.displayName = 'proto.lnrpc.GenSeedResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.GenSeedResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.GenSeedResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.GenSeedResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.GenSeedResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GenSeedResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    cipherSeedMnemonicList: jspb.Message.getRepeatedField(msg, 1),
    encipheredSeed: msg.getEncipheredSeed_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.GenSeedResponse}
 */
proto.lnrpc.GenSeedResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.GenSeedResponse;
  return proto.lnrpc.GenSeedResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.GenSeedResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.GenSeedResponse}
 */
proto.lnrpc.GenSeedResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.addCipherSeedMnemonic(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEncipheredSeed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.GenSeedResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.GenSeedResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.GenSeedResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GenSeedResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCipherSeedMnemonicList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      1,
      f
    );
  }
  f = message.getEncipheredSeed_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * repeated string cipher_seed_mnemonic = 1;
 * @return {!Array.<string>}
 */
proto.lnrpc.GenSeedResponse.prototype.getCipherSeedMnemonicList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<string>} value */
proto.lnrpc.GenSeedResponse.prototype.setCipherSeedMnemonicList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.lnrpc.GenSeedResponse.prototype.addCipherSeedMnemonic = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.lnrpc.GenSeedResponse.prototype.clearCipherSeedMnemonicList = function() {
  this.setCipherSeedMnemonicList([]);
};


/**
 * optional bytes enciphered_seed = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.GenSeedResponse.prototype.getEncipheredSeed = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes enciphered_seed = 2;
 * This is a type-conversion wrapper around `getEncipheredSeed()`
 * @return {string}
 */
proto.lnrpc.GenSeedResponse.prototype.getEncipheredSeed_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEncipheredSeed()));
};


/**
 * optional bytes enciphered_seed = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEncipheredSeed()`
 * @return {!Uint8Array}
 */
proto.lnrpc.GenSeedResponse.prototype.getEncipheredSeed_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEncipheredSeed()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.GenSeedResponse.prototype.setEncipheredSeed = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.InitWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.InitWalletRequest.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.InitWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.InitWalletRequest.displayName = 'proto.lnrpc.InitWalletRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.InitWalletRequest.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.InitWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.InitWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.InitWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.InitWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletPassword: msg.getWalletPassword_asB64(),
    cipherSeedMnemonicList: jspb.Message.getRepeatedField(msg, 2),
    aezeedPassphrase: msg.getAezeedPassphrase_asB64(),
    recoveryWindow: jspb.Message.getFieldWithDefault(msg, 4, 0),
    channelBackups: (f = msg.getChannelBackups()) && proto.lnrpc.ChanBackupSnapshot.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.InitWalletRequest}
 */
proto.lnrpc.InitWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.InitWalletRequest;
  return proto.lnrpc.InitWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.InitWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.InitWalletRequest}
 */
proto.lnrpc.InitWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setWalletPassword(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.addCipherSeedMnemonic(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAezeedPassphrase(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRecoveryWindow(value);
      break;
    case 5:
      var value = new proto.lnrpc.ChanBackupSnapshot;
      reader.readMessage(value,proto.lnrpc.ChanBackupSnapshot.deserializeBinaryFromReader);
      msg.setChannelBackups(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.InitWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.InitWalletRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.InitWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.InitWalletRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletPassword_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getCipherSeedMnemonicList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      2,
      f
    );
  }
  f = message.getAezeedPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getRecoveryWindow();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getChannelBackups();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.lnrpc.ChanBackupSnapshot.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes wallet_password = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.InitWalletRequest.prototype.getWalletPassword = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes wallet_password = 1;
 * This is a type-conversion wrapper around `getWalletPassword()`
 * @return {string}
 */
proto.lnrpc.InitWalletRequest.prototype.getWalletPassword_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getWalletPassword()));
};


/**
 * optional bytes wallet_password = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getWalletPassword()`
 * @return {!Uint8Array}
 */
proto.lnrpc.InitWalletRequest.prototype.getWalletPassword_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getWalletPassword()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.InitWalletRequest.prototype.setWalletPassword = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated string cipher_seed_mnemonic = 2;
 * @return {!Array.<string>}
 */
proto.lnrpc.InitWalletRequest.prototype.getCipherSeedMnemonicList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/** @param {!Array.<string>} value */
proto.lnrpc.InitWalletRequest.prototype.setCipherSeedMnemonicList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.lnrpc.InitWalletRequest.prototype.addCipherSeedMnemonic = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.lnrpc.InitWalletRequest.prototype.clearCipherSeedMnemonicList = function() {
  this.setCipherSeedMnemonicList([]);
};


/**
 * optional bytes aezeed_passphrase = 3;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.InitWalletRequest.prototype.getAezeedPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes aezeed_passphrase = 3;
 * This is a type-conversion wrapper around `getAezeedPassphrase()`
 * @return {string}
 */
proto.lnrpc.InitWalletRequest.prototype.getAezeedPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAezeedPassphrase()));
};


/**
 * optional bytes aezeed_passphrase = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAezeedPassphrase()`
 * @return {!Uint8Array}
 */
proto.lnrpc.InitWalletRequest.prototype.getAezeedPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAezeedPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.InitWalletRequest.prototype.setAezeedPassphrase = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 recovery_window = 4;
 * @return {number}
 */
proto.lnrpc.InitWalletRequest.prototype.getRecoveryWindow = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.InitWalletRequest.prototype.setRecoveryWindow = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional ChanBackupSnapshot channel_backups = 5;
 * @return {?proto.lnrpc.ChanBackupSnapshot}
 */
proto.lnrpc.InitWalletRequest.prototype.getChannelBackups = function() {
  return /** @type{?proto.lnrpc.ChanBackupSnapshot} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChanBackupSnapshot, 5));
};


/** @param {?proto.lnrpc.ChanBackupSnapshot|undefined} value */
proto.lnrpc.InitWalletRequest.prototype.setChannelBackups = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.lnrpc.InitWalletRequest.prototype.clearChannelBackups = function() {
  this.setChannelBackups(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.InitWalletRequest.prototype.hasChannelBackups = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.InitWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.InitWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.InitWalletResponse.displayName = 'proto.lnrpc.InitWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.InitWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.InitWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.InitWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.InitWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.InitWalletResponse}
 */
proto.lnrpc.InitWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.InitWalletResponse;
  return proto.lnrpc.InitWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.InitWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.InitWalletResponse}
 */
proto.lnrpc.InitWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.InitWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.InitWalletResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.InitWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.InitWalletResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.UnlockWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.UnlockWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.UnlockWalletRequest.displayName = 'proto.lnrpc.UnlockWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.UnlockWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.UnlockWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.UnlockWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.UnlockWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    walletPassword: msg.getWalletPassword_asB64(),
    recoveryWindow: jspb.Message.getFieldWithDefault(msg, 2, 0),
    channelBackups: (f = msg.getChannelBackups()) && proto.lnrpc.ChanBackupSnapshot.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.UnlockWalletRequest}
 */
proto.lnrpc.UnlockWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.UnlockWalletRequest;
  return proto.lnrpc.UnlockWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.UnlockWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.UnlockWalletRequest}
 */
proto.lnrpc.UnlockWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setWalletPassword(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRecoveryWindow(value);
      break;
    case 3:
      var value = new proto.lnrpc.ChanBackupSnapshot;
      reader.readMessage(value,proto.lnrpc.ChanBackupSnapshot.deserializeBinaryFromReader);
      msg.setChannelBackups(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.UnlockWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.UnlockWalletRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.UnlockWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.UnlockWalletRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getWalletPassword_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getRecoveryWindow();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getChannelBackups();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.lnrpc.ChanBackupSnapshot.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes wallet_password = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.UnlockWalletRequest.prototype.getWalletPassword = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes wallet_password = 1;
 * This is a type-conversion wrapper around `getWalletPassword()`
 * @return {string}
 */
proto.lnrpc.UnlockWalletRequest.prototype.getWalletPassword_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getWalletPassword()));
};


/**
 * optional bytes wallet_password = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getWalletPassword()`
 * @return {!Uint8Array}
 */
proto.lnrpc.UnlockWalletRequest.prototype.getWalletPassword_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getWalletPassword()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.UnlockWalletRequest.prototype.setWalletPassword = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 recovery_window = 2;
 * @return {number}
 */
proto.lnrpc.UnlockWalletRequest.prototype.getRecoveryWindow = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.UnlockWalletRequest.prototype.setRecoveryWindow = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional ChanBackupSnapshot channel_backups = 3;
 * @return {?proto.lnrpc.ChanBackupSnapshot}
 */
proto.lnrpc.UnlockWalletRequest.prototype.getChannelBackups = function() {
  return /** @type{?proto.lnrpc.ChanBackupSnapshot} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChanBackupSnapshot, 3));
};


/** @param {?proto.lnrpc.ChanBackupSnapshot|undefined} value */
proto.lnrpc.UnlockWalletRequest.prototype.setChannelBackups = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.lnrpc.UnlockWalletRequest.prototype.clearChannelBackups = function() {
  this.setChannelBackups(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.UnlockWalletRequest.prototype.hasChannelBackups = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.UnlockWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.UnlockWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.UnlockWalletResponse.displayName = 'proto.lnrpc.UnlockWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.UnlockWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.UnlockWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.UnlockWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.UnlockWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.UnlockWalletResponse}
 */
proto.lnrpc.UnlockWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.UnlockWalletResponse;
  return proto.lnrpc.UnlockWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.UnlockWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.UnlockWalletResponse}
 */
proto.lnrpc.UnlockWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.UnlockWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.UnlockWalletResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.UnlockWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.UnlockWalletResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChangePasswordRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChangePasswordRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChangePasswordRequest.displayName = 'proto.lnrpc.ChangePasswordRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChangePasswordRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChangePasswordRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChangePasswordRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChangePasswordRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    currentPassword: msg.getCurrentPassword_asB64(),
    newPassword: msg.getNewPassword_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChangePasswordRequest}
 */
proto.lnrpc.ChangePasswordRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChangePasswordRequest;
  return proto.lnrpc.ChangePasswordRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChangePasswordRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChangePasswordRequest}
 */
proto.lnrpc.ChangePasswordRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCurrentPassword(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNewPassword(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChangePasswordRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChangePasswordRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChangePasswordRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChangePasswordRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCurrentPassword_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getNewPassword_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes current_password = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChangePasswordRequest.prototype.getCurrentPassword = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes current_password = 1;
 * This is a type-conversion wrapper around `getCurrentPassword()`
 * @return {string}
 */
proto.lnrpc.ChangePasswordRequest.prototype.getCurrentPassword_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCurrentPassword()));
};


/**
 * optional bytes current_password = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCurrentPassword()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChangePasswordRequest.prototype.getCurrentPassword_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCurrentPassword()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChangePasswordRequest.prototype.setCurrentPassword = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes new_password = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChangePasswordRequest.prototype.getNewPassword = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes new_password = 2;
 * This is a type-conversion wrapper around `getNewPassword()`
 * @return {string}
 */
proto.lnrpc.ChangePasswordRequest.prototype.getNewPassword_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNewPassword()));
};


/**
 * optional bytes new_password = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNewPassword()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChangePasswordRequest.prototype.getNewPassword_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNewPassword()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChangePasswordRequest.prototype.setNewPassword = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChangePasswordResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChangePasswordResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChangePasswordResponse.displayName = 'proto.lnrpc.ChangePasswordResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChangePasswordResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChangePasswordResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChangePasswordResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChangePasswordResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChangePasswordResponse}
 */
proto.lnrpc.ChangePasswordResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChangePasswordResponse;
  return proto.lnrpc.ChangePasswordResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChangePasswordResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChangePasswordResponse}
 */
proto.lnrpc.ChangePasswordResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChangePasswordResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChangePasswordResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChangePasswordResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChangePasswordResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Utxo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.Utxo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Utxo.displayName = 'proto.lnrpc.Utxo';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Utxo.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Utxo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Utxo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Utxo.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    address: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amountAtoms: jspb.Message.getFieldWithDefault(msg, 3, 0),
    pkScript: jspb.Message.getFieldWithDefault(msg, 4, ""),
    outpoint: (f = msg.getOutpoint()) && proto.lnrpc.OutPoint.toObject(includeInstance, f),
    confirmations: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Utxo}
 */
proto.lnrpc.Utxo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Utxo;
  return proto.lnrpc.Utxo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Utxo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Utxo}
 */
proto.lnrpc.Utxo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.lnrpc.AddressType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmountAtoms(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPkScript(value);
      break;
    case 5:
      var value = new proto.lnrpc.OutPoint;
      reader.readMessage(value,proto.lnrpc.OutPoint.deserializeBinaryFromReader);
      msg.setOutpoint(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setConfirmations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Utxo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Utxo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Utxo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Utxo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmountAtoms();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getPkScript();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getOutpoint();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.lnrpc.OutPoint.serializeBinaryToWriter
    );
  }
  f = message.getConfirmations();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
};


/**
 * optional AddressType type = 1;
 * @return {!proto.lnrpc.AddressType}
 */
proto.lnrpc.Utxo.prototype.getType = function() {
  return /** @type {!proto.lnrpc.AddressType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.lnrpc.AddressType} value */
proto.lnrpc.Utxo.prototype.setType = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string address = 2;
 * @return {string}
 */
proto.lnrpc.Utxo.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.Utxo.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 amount_atoms = 3;
 * @return {number}
 */
proto.lnrpc.Utxo.prototype.getAmountAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.Utxo.prototype.setAmountAtoms = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string pk_script = 4;
 * @return {string}
 */
proto.lnrpc.Utxo.prototype.getPkScript = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.lnrpc.Utxo.prototype.setPkScript = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional OutPoint outpoint = 5;
 * @return {?proto.lnrpc.OutPoint}
 */
proto.lnrpc.Utxo.prototype.getOutpoint = function() {
  return /** @type{?proto.lnrpc.OutPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.OutPoint, 5));
};


/** @param {?proto.lnrpc.OutPoint|undefined} value */
proto.lnrpc.Utxo.prototype.setOutpoint = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.lnrpc.Utxo.prototype.clearOutpoint = function() {
  this.setOutpoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.Utxo.prototype.hasOutpoint = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional int64 confirmations = 6;
 * @return {number}
 */
proto.lnrpc.Utxo.prototype.getConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.Utxo.prototype.setConfirmations = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Transaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.Transaction.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.Transaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Transaction.displayName = 'proto.lnrpc.Transaction';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.Transaction.repeatedFields_ = [8];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Transaction.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Transaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Transaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Transaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    txHash: jspb.Message.getFieldWithDefault(msg, 1, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    numConfirmations: jspb.Message.getFieldWithDefault(msg, 3, 0),
    blockHash: jspb.Message.getFieldWithDefault(msg, 4, ""),
    blockHeight: jspb.Message.getFieldWithDefault(msg, 5, 0),
    timeStamp: jspb.Message.getFieldWithDefault(msg, 6, 0),
    totalFees: jspb.Message.getFieldWithDefault(msg, 7, 0),
    destAddressesList: jspb.Message.getRepeatedField(msg, 8),
    rawTxHex: jspb.Message.getFieldWithDefault(msg, 9, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Transaction}
 */
proto.lnrpc.Transaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Transaction;
  return proto.lnrpc.Transaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Transaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Transaction}
 */
proto.lnrpc.Transaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTxHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setNumConfirmations(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setBlockHash(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlockHeight(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimeStamp(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalFees(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.addDestAddresses(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setRawTxHex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Transaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Transaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Transaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Transaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTxHash();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getNumConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getBlockHash();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = message.getTimeStamp();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getTotalFees();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getDestAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      8,
      f
    );
  }
  f = message.getRawTxHex();
  if (f.length > 0) {
    writer.writeString(
      9,
      f
    );
  }
};


/**
 * optional string tx_hash = 1;
 * @return {string}
 */
proto.lnrpc.Transaction.prototype.getTxHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.Transaction.prototype.setTxHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 amount = 2;
 * @return {number}
 */
proto.lnrpc.Transaction.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.Transaction.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 num_confirmations = 3;
 * @return {number}
 */
proto.lnrpc.Transaction.prototype.getNumConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.Transaction.prototype.setNumConfirmations = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string block_hash = 4;
 * @return {string}
 */
proto.lnrpc.Transaction.prototype.getBlockHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.lnrpc.Transaction.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 block_height = 5;
 * @return {number}
 */
proto.lnrpc.Transaction.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.Transaction.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 time_stamp = 6;
 * @return {number}
 */
proto.lnrpc.Transaction.prototype.getTimeStamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.Transaction.prototype.setTimeStamp = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 total_fees = 7;
 * @return {number}
 */
proto.lnrpc.Transaction.prototype.getTotalFees = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.Transaction.prototype.setTotalFees = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * repeated string dest_addresses = 8;
 * @return {!Array.<string>}
 */
proto.lnrpc.Transaction.prototype.getDestAddressesList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 8));
};


/** @param {!Array.<string>} value */
proto.lnrpc.Transaction.prototype.setDestAddressesList = function(value) {
  jspb.Message.setField(this, 8, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.lnrpc.Transaction.prototype.addDestAddresses = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 8, value, opt_index);
};


proto.lnrpc.Transaction.prototype.clearDestAddressesList = function() {
  this.setDestAddressesList([]);
};


/**
 * optional string raw_tx_hex = 9;
 * @return {string}
 */
proto.lnrpc.Transaction.prototype.getRawTxHex = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/** @param {string} value */
proto.lnrpc.Transaction.prototype.setRawTxHex = function(value) {
  jspb.Message.setField(this, 9, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.GetTransactionsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.GetTransactionsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.GetTransactionsRequest.displayName = 'proto.lnrpc.GetTransactionsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.GetTransactionsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.GetTransactionsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.GetTransactionsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GetTransactionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.GetTransactionsRequest}
 */
proto.lnrpc.GetTransactionsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.GetTransactionsRequest;
  return proto.lnrpc.GetTransactionsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.GetTransactionsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.GetTransactionsRequest}
 */
proto.lnrpc.GetTransactionsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.GetTransactionsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.GetTransactionsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.GetTransactionsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GetTransactionsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.TransactionDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.TransactionDetails.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.TransactionDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.TransactionDetails.displayName = 'proto.lnrpc.TransactionDetails';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.TransactionDetails.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.TransactionDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.TransactionDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.TransactionDetails} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.TransactionDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    proto.lnrpc.Transaction.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.TransactionDetails}
 */
proto.lnrpc.TransactionDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.TransactionDetails;
  return proto.lnrpc.TransactionDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.TransactionDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.TransactionDetails}
 */
proto.lnrpc.TransactionDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.Transaction;
      reader.readMessage(value,proto.lnrpc.Transaction.deserializeBinaryFromReader);
      msg.addTransactions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.TransactionDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.TransactionDetails.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.TransactionDetails} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.TransactionDetails.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.Transaction.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Transaction transactions = 1;
 * @return {!Array.<!proto.lnrpc.Transaction>}
 */
proto.lnrpc.TransactionDetails.prototype.getTransactionsList = function() {
  return /** @type{!Array.<!proto.lnrpc.Transaction>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Transaction, 1));
};


/** @param {!Array.<!proto.lnrpc.Transaction>} value */
proto.lnrpc.TransactionDetails.prototype.setTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.Transaction=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Transaction}
 */
proto.lnrpc.TransactionDetails.prototype.addTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.Transaction, opt_index);
};


proto.lnrpc.TransactionDetails.prototype.clearTransactionsList = function() {
  this.setTransactionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.FeeLimit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.FeeLimit.oneofGroups_);
};
goog.inherits(proto.lnrpc.FeeLimit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.FeeLimit.displayName = 'proto.lnrpc.FeeLimit';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.FeeLimit.oneofGroups_ = [[1,3,2]];

/**
 * @enum {number}
 */
proto.lnrpc.FeeLimit.LimitCase = {
  LIMIT_NOT_SET: 0,
  FIXED: 1,
  FIXED_M_ATOMS: 3,
  PERCENT: 2
};

/**
 * @return {proto.lnrpc.FeeLimit.LimitCase}
 */
proto.lnrpc.FeeLimit.prototype.getLimitCase = function() {
  return /** @type {proto.lnrpc.FeeLimit.LimitCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.FeeLimit.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.FeeLimit.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.FeeLimit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.FeeLimit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FeeLimit.toObject = function(includeInstance, msg) {
  var f, obj = {
    fixed: jspb.Message.getFieldWithDefault(msg, 1, 0),
    fixedMAtoms: jspb.Message.getFieldWithDefault(msg, 3, 0),
    percent: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.FeeLimit}
 */
proto.lnrpc.FeeLimit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.FeeLimit;
  return proto.lnrpc.FeeLimit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.FeeLimit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.FeeLimit}
 */
proto.lnrpc.FeeLimit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFixed(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFixedMAtoms(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setPercent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.FeeLimit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.FeeLimit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.FeeLimit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FeeLimit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional int64 fixed = 1;
 * @return {number}
 */
proto.lnrpc.FeeLimit.prototype.getFixed = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.FeeLimit.prototype.setFixed = function(value) {
  jspb.Message.setOneofField(this, 1, proto.lnrpc.FeeLimit.oneofGroups_[0], value);
};


proto.lnrpc.FeeLimit.prototype.clearFixed = function() {
  jspb.Message.setOneofField(this, 1, proto.lnrpc.FeeLimit.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.FeeLimit.prototype.hasFixed = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int64 fixed_m_atoms = 3;
 * @return {number}
 */
proto.lnrpc.FeeLimit.prototype.getFixedMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.FeeLimit.prototype.setFixedMAtoms = function(value) {
  jspb.Message.setOneofField(this, 3, proto.lnrpc.FeeLimit.oneofGroups_[0], value);
};


proto.lnrpc.FeeLimit.prototype.clearFixedMAtoms = function() {
  jspb.Message.setOneofField(this, 3, proto.lnrpc.FeeLimit.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.FeeLimit.prototype.hasFixedMAtoms = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional int64 percent = 2;
 * @return {number}
 */
proto.lnrpc.FeeLimit.prototype.getPercent = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.FeeLimit.prototype.setPercent = function(value) {
  jspb.Message.setOneofField(this, 2, proto.lnrpc.FeeLimit.oneofGroups_[0], value);
};


proto.lnrpc.FeeLimit.prototype.clearPercent = function() {
  jspb.Message.setOneofField(this, 2, proto.lnrpc.FeeLimit.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.FeeLimit.prototype.hasPercent = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SendRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.SendRequest.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.SendRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SendRequest.displayName = 'proto.lnrpc.SendRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.SendRequest.repeatedFields_ = [16];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SendRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SendRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SendRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    dest: msg.getDest_asB64(),
    destString: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amt: jspb.Message.getFieldWithDefault(msg, 3, 0),
    amtMAtoms: jspb.Message.getFieldWithDefault(msg, 13, 0),
    paymentHash: msg.getPaymentHash_asB64(),
    paymentHashString: jspb.Message.getFieldWithDefault(msg, 5, ""),
    paymentRequest: jspb.Message.getFieldWithDefault(msg, 6, ""),
    finalCltvDelta: jspb.Message.getFieldWithDefault(msg, 7, 0),
    feeLimit: (f = msg.getFeeLimit()) && proto.lnrpc.FeeLimit.toObject(includeInstance, f),
    outgoingChanId: jspb.Message.getFieldWithDefault(msg, 10, "0"),
    ignoreMaxOutboundAmt: jspb.Message.getFieldWithDefault(msg, 9, false),
    lastHopPubkey: msg.getLastHopPubkey_asB64(),
    cltvLimit: jspb.Message.getFieldWithDefault(msg, 11, 0),
    destCustomRecordsMap: (f = msg.getDestCustomRecordsMap()) ? f.toObject(includeInstance, undefined) : [],
    allowSelfPayment: jspb.Message.getFieldWithDefault(msg, 15, false),
    destFeaturesList: jspb.Message.getRepeatedField(msg, 16)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SendRequest}
 */
proto.lnrpc.SendRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SendRequest;
  return proto.lnrpc.SendRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SendRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SendRequest}
 */
proto.lnrpc.SendRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDest(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDestString(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmt(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmtMAtoms(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentHash(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentHashString(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentRequest(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFinalCltvDelta(value);
      break;
    case 8:
      var value = new proto.lnrpc.FeeLimit;
      reader.readMessage(value,proto.lnrpc.FeeLimit.deserializeBinaryFromReader);
      msg.setFeeLimit(value);
      break;
    case 10:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setOutgoingChanId(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIgnoreMaxOutboundAmt(value);
      break;
    case 14:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLastHopPubkey(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCltvLimit(value);
      break;
    case 12:
      var value = msg.getDestCustomRecordsMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint64, jspb.BinaryReader.prototype.readBytes);
         });
      break;
    case 15:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAllowSelfPayment(value);
      break;
    case 16:
      var value = /** @type {!Array.<!proto.lnrpc.FeatureBit>} */ (reader.readPackedEnum());
      msg.setDestFeaturesList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SendRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SendRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SendRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDest_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getDestString();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmt();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getAmtMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      13,
      f
    );
  }
  f = message.getPaymentHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getPaymentHashString();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getPaymentRequest();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = message.getFinalCltvDelta();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
  f = message.getFeeLimit();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.lnrpc.FeeLimit.serializeBinaryToWriter
    );
  }
  f = message.getOutgoingChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      10,
      f
    );
  }
  f = message.getIgnoreMaxOutboundAmt();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getLastHopPubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      14,
      f
    );
  }
  f = message.getCltvLimit();
  if (f !== 0) {
    writer.writeUint32(
      11,
      f
    );
  }
  f = message.getDestCustomRecordsMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(12, writer, jspb.BinaryWriter.prototype.writeUint64, jspb.BinaryWriter.prototype.writeBytes);
  }
  f = message.getAllowSelfPayment();
  if (f) {
    writer.writeBool(
      15,
      f
    );
  }
  f = message.getDestFeaturesList();
  if (f.length > 0) {
    writer.writePackedEnum(
      16,
      f
    );
  }
};


/**
 * optional bytes dest = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.SendRequest.prototype.getDest = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes dest = 1;
 * This is a type-conversion wrapper around `getDest()`
 * @return {string}
 */
proto.lnrpc.SendRequest.prototype.getDest_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDest()));
};


/**
 * optional bytes dest = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDest()`
 * @return {!Uint8Array}
 */
proto.lnrpc.SendRequest.prototype.getDest_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDest()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.SendRequest.prototype.setDest = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string dest_string = 2;
 * @return {string}
 */
proto.lnrpc.SendRequest.prototype.getDestString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.SendRequest.prototype.setDestString = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 amt = 3;
 * @return {number}
 */
proto.lnrpc.SendRequest.prototype.getAmt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.SendRequest.prototype.setAmt = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 amt_m_atoms = 13;
 * @return {number}
 */
proto.lnrpc.SendRequest.prototype.getAmtMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.lnrpc.SendRequest.prototype.setAmtMAtoms = function(value) {
  jspb.Message.setField(this, 13, value);
};


/**
 * optional bytes payment_hash = 4;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.SendRequest.prototype.getPaymentHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes payment_hash = 4;
 * This is a type-conversion wrapper around `getPaymentHash()`
 * @return {string}
 */
proto.lnrpc.SendRequest.prototype.getPaymentHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentHash()));
};


/**
 * optional bytes payment_hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentHash()`
 * @return {!Uint8Array}
 */
proto.lnrpc.SendRequest.prototype.getPaymentHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.SendRequest.prototype.setPaymentHash = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string payment_hash_string = 5;
 * @return {string}
 */
proto.lnrpc.SendRequest.prototype.getPaymentHashString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.lnrpc.SendRequest.prototype.setPaymentHashString = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional string payment_request = 6;
 * @return {string}
 */
proto.lnrpc.SendRequest.prototype.getPaymentRequest = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.lnrpc.SendRequest.prototype.setPaymentRequest = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int32 final_cltv_delta = 7;
 * @return {number}
 */
proto.lnrpc.SendRequest.prototype.getFinalCltvDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.SendRequest.prototype.setFinalCltvDelta = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional FeeLimit fee_limit = 8;
 * @return {?proto.lnrpc.FeeLimit}
 */
proto.lnrpc.SendRequest.prototype.getFeeLimit = function() {
  return /** @type{?proto.lnrpc.FeeLimit} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.FeeLimit, 8));
};


/** @param {?proto.lnrpc.FeeLimit|undefined} value */
proto.lnrpc.SendRequest.prototype.setFeeLimit = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.lnrpc.SendRequest.prototype.clearFeeLimit = function() {
  this.setFeeLimit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.SendRequest.prototype.hasFeeLimit = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional uint64 outgoing_chan_id = 10;
 * @return {string}
 */
proto.lnrpc.SendRequest.prototype.getOutgoingChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 10, "0"));
};


/** @param {string} value */
proto.lnrpc.SendRequest.prototype.setOutgoingChanId = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional bool ignore_max_outbound_amt = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.SendRequest.prototype.getIgnoreMaxOutboundAmt = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.lnrpc.SendRequest.prototype.setIgnoreMaxOutboundAmt = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional bytes last_hop_pubkey = 14;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.SendRequest.prototype.getLastHopPubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 14, ""));
};


/**
 * optional bytes last_hop_pubkey = 14;
 * This is a type-conversion wrapper around `getLastHopPubkey()`
 * @return {string}
 */
proto.lnrpc.SendRequest.prototype.getLastHopPubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLastHopPubkey()));
};


/**
 * optional bytes last_hop_pubkey = 14;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLastHopPubkey()`
 * @return {!Uint8Array}
 */
proto.lnrpc.SendRequest.prototype.getLastHopPubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLastHopPubkey()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.SendRequest.prototype.setLastHopPubkey = function(value) {
  jspb.Message.setField(this, 14, value);
};


/**
 * optional uint32 cltv_limit = 11;
 * @return {number}
 */
proto.lnrpc.SendRequest.prototype.getCltvLimit = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.lnrpc.SendRequest.prototype.setCltvLimit = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * map<uint64, bytes> dest_custom_records = 12;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!(string|Uint8Array)>}
 */
proto.lnrpc.SendRequest.prototype.getDestCustomRecordsMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!(string|Uint8Array)>} */ (
      jspb.Message.getMapField(this, 12, opt_noLazyCreate,
      null));
};


proto.lnrpc.SendRequest.prototype.clearDestCustomRecordsMap = function() {
  this.getDestCustomRecordsMap().clear();
};


/**
 * optional bool allow_self_payment = 15;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.SendRequest.prototype.getAllowSelfPayment = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 15, false));
};


/** @param {boolean} value */
proto.lnrpc.SendRequest.prototype.setAllowSelfPayment = function(value) {
  jspb.Message.setField(this, 15, value);
};


/**
 * repeated FeatureBit dest_features = 16;
 * @return {!Array.<!proto.lnrpc.FeatureBit>}
 */
proto.lnrpc.SendRequest.prototype.getDestFeaturesList = function() {
  return /** @type {!Array.<!proto.lnrpc.FeatureBit>} */ (jspb.Message.getRepeatedField(this, 16));
};


/** @param {!Array.<!proto.lnrpc.FeatureBit>} value */
proto.lnrpc.SendRequest.prototype.setDestFeaturesList = function(value) {
  jspb.Message.setField(this, 16, value || []);
};


/**
 * @param {!proto.lnrpc.FeatureBit} value
 * @param {number=} opt_index
 */
proto.lnrpc.SendRequest.prototype.addDestFeatures = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 16, value, opt_index);
};


proto.lnrpc.SendRequest.prototype.clearDestFeaturesList = function() {
  this.setDestFeaturesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SendResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.SendResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SendResponse.displayName = 'proto.lnrpc.SendResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SendResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SendResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SendResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    paymentError: jspb.Message.getFieldWithDefault(msg, 1, ""),
    paymentPreimage: msg.getPaymentPreimage_asB64(),
    paymentRoute: (f = msg.getPaymentRoute()) && proto.lnrpc.Route.toObject(includeInstance, f),
    paymentHash: msg.getPaymentHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SendResponse}
 */
proto.lnrpc.SendResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SendResponse;
  return proto.lnrpc.SendResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SendResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SendResponse}
 */
proto.lnrpc.SendResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentError(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentPreimage(value);
      break;
    case 3:
      var value = new proto.lnrpc.Route;
      reader.readMessage(value,proto.lnrpc.Route.deserializeBinaryFromReader);
      msg.setPaymentRoute(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SendResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SendResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SendResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPaymentError();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPaymentPreimage_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getPaymentRoute();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.lnrpc.Route.serializeBinaryToWriter
    );
  }
  f = message.getPaymentHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional string payment_error = 1;
 * @return {string}
 */
proto.lnrpc.SendResponse.prototype.getPaymentError = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.SendResponse.prototype.setPaymentError = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes payment_preimage = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.SendResponse.prototype.getPaymentPreimage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes payment_preimage = 2;
 * This is a type-conversion wrapper around `getPaymentPreimage()`
 * @return {string}
 */
proto.lnrpc.SendResponse.prototype.getPaymentPreimage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentPreimage()));
};


/**
 * optional bytes payment_preimage = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentPreimage()`
 * @return {!Uint8Array}
 */
proto.lnrpc.SendResponse.prototype.getPaymentPreimage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentPreimage()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.SendResponse.prototype.setPaymentPreimage = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional Route payment_route = 3;
 * @return {?proto.lnrpc.Route}
 */
proto.lnrpc.SendResponse.prototype.getPaymentRoute = function() {
  return /** @type{?proto.lnrpc.Route} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.Route, 3));
};


/** @param {?proto.lnrpc.Route|undefined} value */
proto.lnrpc.SendResponse.prototype.setPaymentRoute = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.lnrpc.SendResponse.prototype.clearPaymentRoute = function() {
  this.setPaymentRoute(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.SendResponse.prototype.hasPaymentRoute = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bytes payment_hash = 4;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.SendResponse.prototype.getPaymentHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes payment_hash = 4;
 * This is a type-conversion wrapper around `getPaymentHash()`
 * @return {string}
 */
proto.lnrpc.SendResponse.prototype.getPaymentHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentHash()));
};


/**
 * optional bytes payment_hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentHash()`
 * @return {!Uint8Array}
 */
proto.lnrpc.SendResponse.prototype.getPaymentHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.SendResponse.prototype.setPaymentHash = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SendToRouteRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.SendToRouteRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SendToRouteRequest.displayName = 'proto.lnrpc.SendToRouteRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SendToRouteRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SendToRouteRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SendToRouteRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendToRouteRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    paymentHash: msg.getPaymentHash_asB64(),
    paymentHashString: jspb.Message.getFieldWithDefault(msg, 2, ""),
    route: (f = msg.getRoute()) && proto.lnrpc.Route.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SendToRouteRequest}
 */
proto.lnrpc.SendToRouteRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SendToRouteRequest;
  return proto.lnrpc.SendToRouteRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SendToRouteRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SendToRouteRequest}
 */
proto.lnrpc.SendToRouteRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentHash(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentHashString(value);
      break;
    case 4:
      var value = new proto.lnrpc.Route;
      reader.readMessage(value,proto.lnrpc.Route.deserializeBinaryFromReader);
      msg.setRoute(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SendToRouteRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SendToRouteRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SendToRouteRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendToRouteRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPaymentHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPaymentHashString();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getRoute();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.lnrpc.Route.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes payment_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.SendToRouteRequest.prototype.getPaymentHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes payment_hash = 1;
 * This is a type-conversion wrapper around `getPaymentHash()`
 * @return {string}
 */
proto.lnrpc.SendToRouteRequest.prototype.getPaymentHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentHash()));
};


/**
 * optional bytes payment_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentHash()`
 * @return {!Uint8Array}
 */
proto.lnrpc.SendToRouteRequest.prototype.getPaymentHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.SendToRouteRequest.prototype.setPaymentHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string payment_hash_string = 2;
 * @return {string}
 */
proto.lnrpc.SendToRouteRequest.prototype.getPaymentHashString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.SendToRouteRequest.prototype.setPaymentHashString = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional Route route = 4;
 * @return {?proto.lnrpc.Route}
 */
proto.lnrpc.SendToRouteRequest.prototype.getRoute = function() {
  return /** @type{?proto.lnrpc.Route} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.Route, 4));
};


/** @param {?proto.lnrpc.Route|undefined} value */
proto.lnrpc.SendToRouteRequest.prototype.setRoute = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.lnrpc.SendToRouteRequest.prototype.clearRoute = function() {
  this.setRoute(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.SendToRouteRequest.prototype.hasRoute = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelAcceptRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelAcceptRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelAcceptRequest.displayName = 'proto.lnrpc.ChannelAcceptRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelAcceptRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelAcceptRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelAcceptRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodePubkey: msg.getNodePubkey_asB64(),
    chainHash: msg.getChainHash_asB64(),
    pendingChanId: msg.getPendingChanId_asB64(),
    fundingAmt: jspb.Message.getFieldWithDefault(msg, 4, 0),
    pushAmt: jspb.Message.getFieldWithDefault(msg, 5, 0),
    dustLimit: jspb.Message.getFieldWithDefault(msg, 6, 0),
    maxValueInFlight: jspb.Message.getFieldWithDefault(msg, 7, 0),
    channelReserve: jspb.Message.getFieldWithDefault(msg, 8, 0),
    minHtlc: jspb.Message.getFieldWithDefault(msg, 9, 0),
    feePerKb: jspb.Message.getFieldWithDefault(msg, 10, 0),
    csvDelay: jspb.Message.getFieldWithDefault(msg, 11, 0),
    maxAcceptedHtlcs: jspb.Message.getFieldWithDefault(msg, 12, 0),
    channelFlags: jspb.Message.getFieldWithDefault(msg, 13, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelAcceptRequest}
 */
proto.lnrpc.ChannelAcceptRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelAcceptRequest;
  return proto.lnrpc.ChannelAcceptRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelAcceptRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelAcceptRequest}
 */
proto.lnrpc.ChannelAcceptRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNodePubkey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChainHash(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPendingChanId(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFundingAmt(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setPushAmt(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setDustLimit(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMaxValueInFlight(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setChannelReserve(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMinHtlc(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeePerKb(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCsvDelay(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMaxAcceptedHtlcs(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChannelFlags(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelAcceptRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelAcceptRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelAcceptRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodePubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getChainHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getPendingChanId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getFundingAmt();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getPushAmt();
  if (f !== 0) {
    writer.writeUint64(
      5,
      f
    );
  }
  f = message.getDustLimit();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
  f = message.getMaxValueInFlight();
  if (f !== 0) {
    writer.writeUint64(
      7,
      f
    );
  }
  f = message.getChannelReserve();
  if (f !== 0) {
    writer.writeUint64(
      8,
      f
    );
  }
  f = message.getMinHtlc();
  if (f !== 0) {
    writer.writeUint64(
      9,
      f
    );
  }
  f = message.getFeePerKb();
  if (f !== 0) {
    writer.writeUint64(
      10,
      f
    );
  }
  f = message.getCsvDelay();
  if (f !== 0) {
    writer.writeUint32(
      11,
      f
    );
  }
  f = message.getMaxAcceptedHtlcs();
  if (f !== 0) {
    writer.writeUint32(
      12,
      f
    );
  }
  f = message.getChannelFlags();
  if (f !== 0) {
    writer.writeUint32(
      13,
      f
    );
  }
};


/**
 * optional bytes node_pubkey = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getNodePubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes node_pubkey = 1;
 * This is a type-conversion wrapper around `getNodePubkey()`
 * @return {string}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getNodePubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNodePubkey()));
};


/**
 * optional bytes node_pubkey = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNodePubkey()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getNodePubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNodePubkey()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setNodePubkey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes chain_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getChainHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes chain_hash = 2;
 * This is a type-conversion wrapper around `getChainHash()`
 * @return {string}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getChainHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChainHash()));
};


/**
 * optional bytes chain_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChainHash()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getChainHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChainHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setChainHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes pending_chan_id = 3;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getPendingChanId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes pending_chan_id = 3;
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {string}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getPendingChanId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPendingChanId()));
};


/**
 * optional bytes pending_chan_id = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getPendingChanId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPendingChanId()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setPendingChanId = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint64 funding_amt = 4;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getFundingAmt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setFundingAmt = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint64 push_amt = 5;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getPushAmt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setPushAmt = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint64 dust_limit = 6;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getDustLimit = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setDustLimit = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint64 max_value_in_flight = 7;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getMaxValueInFlight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setMaxValueInFlight = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional uint64 channel_reserve = 8;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getChannelReserve = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setChannelReserve = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional uint64 min_htlc = 9;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getMinHtlc = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setMinHtlc = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional uint64 fee_per_kb = 10;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setFeePerKb = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional uint32 csv_delay = 11;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getCsvDelay = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setCsvDelay = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * optional uint32 max_accepted_htlcs = 12;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getMaxAcceptedHtlcs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setMaxAcceptedHtlcs = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * optional uint32 channel_flags = 13;
 * @return {number}
 */
proto.lnrpc.ChannelAcceptRequest.prototype.getChannelFlags = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelAcceptRequest.prototype.setChannelFlags = function(value) {
  jspb.Message.setField(this, 13, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelAcceptResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelAcceptResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelAcceptResponse.displayName = 'proto.lnrpc.ChannelAcceptResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelAcceptResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelAcceptResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelAcceptResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelAcceptResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accept: jspb.Message.getFieldWithDefault(msg, 1, false),
    pendingChanId: msg.getPendingChanId_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelAcceptResponse}
 */
proto.lnrpc.ChannelAcceptResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelAcceptResponse;
  return proto.lnrpc.ChannelAcceptResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelAcceptResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelAcceptResponse}
 */
proto.lnrpc.ChannelAcceptResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAccept(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPendingChanId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelAcceptResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelAcceptResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelAcceptResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelAcceptResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccept();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getPendingChanId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bool accept = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ChannelAcceptResponse.prototype.getAccept = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.ChannelAcceptResponse.prototype.setAccept = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes pending_chan_id = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChannelAcceptResponse.prototype.getPendingChanId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes pending_chan_id = 2;
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {string}
 */
proto.lnrpc.ChannelAcceptResponse.prototype.getPendingChanId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPendingChanId()));
};


/**
 * optional bytes pending_chan_id = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelAcceptResponse.prototype.getPendingChanId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPendingChanId()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChannelAcceptResponse.prototype.setPendingChanId = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelPoint = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.ChannelPoint.oneofGroups_);
};
goog.inherits(proto.lnrpc.ChannelPoint, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelPoint.displayName = 'proto.lnrpc.ChannelPoint';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.ChannelPoint.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.lnrpc.ChannelPoint.FundingTxidCase = {
  FUNDING_TXID_NOT_SET: 0,
  FUNDING_TXID_BYTES: 1,
  FUNDING_TXID_STR: 2
};

/**
 * @return {proto.lnrpc.ChannelPoint.FundingTxidCase}
 */
proto.lnrpc.ChannelPoint.prototype.getFundingTxidCase = function() {
  return /** @type {proto.lnrpc.ChannelPoint.FundingTxidCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.ChannelPoint.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelPoint.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelPoint.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelPoint} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelPoint.toObject = function(includeInstance, msg) {
  var f, obj = {
    fundingTxidBytes: msg.getFundingTxidBytes_asB64(),
    fundingTxidStr: jspb.Message.getFieldWithDefault(msg, 2, ""),
    outputIndex: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ChannelPoint.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelPoint;
  return proto.lnrpc.ChannelPoint.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelPoint} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ChannelPoint.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setFundingTxidBytes(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setFundingTxidStr(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelPoint.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelPoint.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelPoint} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelPoint.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional bytes funding_txid_bytes = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChannelPoint.prototype.getFundingTxidBytes = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes funding_txid_bytes = 1;
 * This is a type-conversion wrapper around `getFundingTxidBytes()`
 * @return {string}
 */
proto.lnrpc.ChannelPoint.prototype.getFundingTxidBytes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getFundingTxidBytes()));
};


/**
 * optional bytes funding_txid_bytes = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFundingTxidBytes()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelPoint.prototype.getFundingTxidBytes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getFundingTxidBytes()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChannelPoint.prototype.setFundingTxidBytes = function(value) {
  jspb.Message.setOneofField(this, 1, proto.lnrpc.ChannelPoint.oneofGroups_[0], value);
};


proto.lnrpc.ChannelPoint.prototype.clearFundingTxidBytes = function() {
  jspb.Message.setOneofField(this, 1, proto.lnrpc.ChannelPoint.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelPoint.prototype.hasFundingTxidBytes = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string funding_txid_str = 2;
 * @return {string}
 */
proto.lnrpc.ChannelPoint.prototype.getFundingTxidStr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelPoint.prototype.setFundingTxidStr = function(value) {
  jspb.Message.setOneofField(this, 2, proto.lnrpc.ChannelPoint.oneofGroups_[0], value);
};


proto.lnrpc.ChannelPoint.prototype.clearFundingTxidStr = function() {
  jspb.Message.setOneofField(this, 2, proto.lnrpc.ChannelPoint.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelPoint.prototype.hasFundingTxidStr = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 output_index = 3;
 * @return {number}
 */
proto.lnrpc.ChannelPoint.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelPoint.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.OutPoint = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.OutPoint, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.OutPoint.displayName = 'proto.lnrpc.OutPoint';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.OutPoint.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.OutPoint.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.OutPoint} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.OutPoint.toObject = function(includeInstance, msg) {
  var f, obj = {
    txidBytes: msg.getTxidBytes_asB64(),
    txidStr: jspb.Message.getFieldWithDefault(msg, 2, ""),
    outputIndex: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.OutPoint}
 */
proto.lnrpc.OutPoint.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.OutPoint;
  return proto.lnrpc.OutPoint.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.OutPoint} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.OutPoint}
 */
proto.lnrpc.OutPoint.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTxidBytes(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setTxidStr(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.OutPoint.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.OutPoint.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.OutPoint} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.OutPoint.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTxidBytes_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getTxidStr();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional bytes txid_bytes = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.OutPoint.prototype.getTxidBytes = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes txid_bytes = 1;
 * This is a type-conversion wrapper around `getTxidBytes()`
 * @return {string}
 */
proto.lnrpc.OutPoint.prototype.getTxidBytes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTxidBytes()));
};


/**
 * optional bytes txid_bytes = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTxidBytes()`
 * @return {!Uint8Array}
 */
proto.lnrpc.OutPoint.prototype.getTxidBytes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTxidBytes()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.OutPoint.prototype.setTxidBytes = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string txid_str = 2;
 * @return {string}
 */
proto.lnrpc.OutPoint.prototype.getTxidStr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.OutPoint.prototype.setTxidStr = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 output_index = 3;
 * @return {number}
 */
proto.lnrpc.OutPoint.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.OutPoint.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.LightningAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.LightningAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.LightningAddress.displayName = 'proto.lnrpc.LightningAddress';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.LightningAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.LightningAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.LightningAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.LightningAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    pubkey: jspb.Message.getFieldWithDefault(msg, 1, ""),
    host: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.LightningAddress}
 */
proto.lnrpc.LightningAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.LightningAddress;
  return proto.lnrpc.LightningAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.LightningAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.LightningAddress}
 */
proto.lnrpc.LightningAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubkey(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setHost(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.LightningAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.LightningAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.LightningAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.LightningAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPubkey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getHost();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string pubkey = 1;
 * @return {string}
 */
proto.lnrpc.LightningAddress.prototype.getPubkey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.LightningAddress.prototype.setPubkey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string host = 2;
 * @return {string}
 */
proto.lnrpc.LightningAddress.prototype.getHost = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.LightningAddress.prototype.setHost = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.EstimateFeeRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.EstimateFeeRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.EstimateFeeRequest.displayName = 'proto.lnrpc.EstimateFeeRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.EstimateFeeRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.EstimateFeeRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.EstimateFeeRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.EstimateFeeRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    addrtoamountMap: (f = msg.getAddrtoamountMap()) ? f.toObject(includeInstance, undefined) : [],
    targetConf: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.EstimateFeeRequest}
 */
proto.lnrpc.EstimateFeeRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.EstimateFeeRequest;
  return proto.lnrpc.EstimateFeeRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.EstimateFeeRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.EstimateFeeRequest}
 */
proto.lnrpc.EstimateFeeRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = msg.getAddrtoamountMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64);
         });
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTargetConf(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.EstimateFeeRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.EstimateFeeRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.EstimateFeeRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.EstimateFeeRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddrtoamountMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(1, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
  }
  f = message.getTargetConf();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * map<string, int64> AddrToAmount = 1;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,number>}
 */
proto.lnrpc.EstimateFeeRequest.prototype.getAddrtoamountMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,number>} */ (
      jspb.Message.getMapField(this, 1, opt_noLazyCreate,
      null));
};


proto.lnrpc.EstimateFeeRequest.prototype.clearAddrtoamountMap = function() {
  this.getAddrtoamountMap().clear();
};


/**
 * optional int32 target_conf = 2;
 * @return {number}
 */
proto.lnrpc.EstimateFeeRequest.prototype.getTargetConf = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.EstimateFeeRequest.prototype.setTargetConf = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.EstimateFeeResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.EstimateFeeResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.EstimateFeeResponse.displayName = 'proto.lnrpc.EstimateFeeResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.EstimateFeeResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.EstimateFeeResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.EstimateFeeResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.EstimateFeeResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    feeAtoms: jspb.Message.getFieldWithDefault(msg, 1, 0),
    feerateAtomsPerByte: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.EstimateFeeResponse}
 */
proto.lnrpc.EstimateFeeResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.EstimateFeeResponse;
  return proto.lnrpc.EstimateFeeResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.EstimateFeeResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.EstimateFeeResponse}
 */
proto.lnrpc.EstimateFeeResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeeAtoms(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeerateAtomsPerByte(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.EstimateFeeResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.EstimateFeeResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.EstimateFeeResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.EstimateFeeResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getFeeAtoms();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getFeerateAtomsPerByte();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional int64 fee_atoms = 1;
 * @return {number}
 */
proto.lnrpc.EstimateFeeResponse.prototype.getFeeAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.EstimateFeeResponse.prototype.setFeeAtoms = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 feerate_atoms_per_byte = 2;
 * @return {number}
 */
proto.lnrpc.EstimateFeeResponse.prototype.getFeerateAtomsPerByte = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.EstimateFeeResponse.prototype.setFeerateAtomsPerByte = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SendManyRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.SendManyRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SendManyRequest.displayName = 'proto.lnrpc.SendManyRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SendManyRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SendManyRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SendManyRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendManyRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    addrtoamountMap: (f = msg.getAddrtoamountMap()) ? f.toObject(includeInstance, undefined) : [],
    targetConf: jspb.Message.getFieldWithDefault(msg, 3, 0),
    atomsPerByte: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SendManyRequest}
 */
proto.lnrpc.SendManyRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SendManyRequest;
  return proto.lnrpc.SendManyRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SendManyRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SendManyRequest}
 */
proto.lnrpc.SendManyRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = msg.getAddrtoamountMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readInt64);
         });
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTargetConf(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAtomsPerByte(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SendManyRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SendManyRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SendManyRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendManyRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddrtoamountMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(1, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeInt64);
  }
  f = message.getTargetConf();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getAtomsPerByte();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
};


/**
 * map<string, int64> AddrToAmount = 1;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,number>}
 */
proto.lnrpc.SendManyRequest.prototype.getAddrtoamountMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,number>} */ (
      jspb.Message.getMapField(this, 1, opt_noLazyCreate,
      null));
};


proto.lnrpc.SendManyRequest.prototype.clearAddrtoamountMap = function() {
  this.getAddrtoamountMap().clear();
};


/**
 * optional int32 target_conf = 3;
 * @return {number}
 */
proto.lnrpc.SendManyRequest.prototype.getTargetConf = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.SendManyRequest.prototype.setTargetConf = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 atoms_per_byte = 5;
 * @return {number}
 */
proto.lnrpc.SendManyRequest.prototype.getAtomsPerByte = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.SendManyRequest.prototype.setAtomsPerByte = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SendManyResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.SendManyResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SendManyResponse.displayName = 'proto.lnrpc.SendManyResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SendManyResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SendManyResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SendManyResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendManyResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    txid: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SendManyResponse}
 */
proto.lnrpc.SendManyResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SendManyResponse;
  return proto.lnrpc.SendManyResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SendManyResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SendManyResponse}
 */
proto.lnrpc.SendManyResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTxid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SendManyResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SendManyResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SendManyResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendManyResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTxid();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string txid = 1;
 * @return {string}
 */
proto.lnrpc.SendManyResponse.prototype.getTxid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.SendManyResponse.prototype.setTxid = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SendCoinsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.SendCoinsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SendCoinsRequest.displayName = 'proto.lnrpc.SendCoinsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SendCoinsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SendCoinsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SendCoinsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendCoinsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    addr: jspb.Message.getFieldWithDefault(msg, 1, ""),
    amount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    targetConf: jspb.Message.getFieldWithDefault(msg, 3, 0),
    atomsPerByte: jspb.Message.getFieldWithDefault(msg, 5, 0),
    sendAll: jspb.Message.getFieldWithDefault(msg, 6, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SendCoinsRequest}
 */
proto.lnrpc.SendCoinsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SendCoinsRequest;
  return proto.lnrpc.SendCoinsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SendCoinsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SendCoinsRequest}
 */
proto.lnrpc.SendCoinsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddr(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTargetConf(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAtomsPerByte(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSendAll(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SendCoinsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SendCoinsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SendCoinsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendCoinsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddr();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getTargetConf();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getAtomsPerByte();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getSendAll();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
};


/**
 * optional string addr = 1;
 * @return {string}
 */
proto.lnrpc.SendCoinsRequest.prototype.getAddr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.SendCoinsRequest.prototype.setAddr = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 amount = 2;
 * @return {number}
 */
proto.lnrpc.SendCoinsRequest.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.SendCoinsRequest.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 target_conf = 3;
 * @return {number}
 */
proto.lnrpc.SendCoinsRequest.prototype.getTargetConf = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.SendCoinsRequest.prototype.setTargetConf = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 atoms_per_byte = 5;
 * @return {number}
 */
proto.lnrpc.SendCoinsRequest.prototype.getAtomsPerByte = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.SendCoinsRequest.prototype.setAtomsPerByte = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool send_all = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.SendCoinsRequest.prototype.getSendAll = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.lnrpc.SendCoinsRequest.prototype.setSendAll = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SendCoinsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.SendCoinsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SendCoinsResponse.displayName = 'proto.lnrpc.SendCoinsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SendCoinsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SendCoinsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SendCoinsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendCoinsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    txid: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SendCoinsResponse}
 */
proto.lnrpc.SendCoinsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SendCoinsResponse;
  return proto.lnrpc.SendCoinsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SendCoinsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SendCoinsResponse}
 */
proto.lnrpc.SendCoinsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setTxid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SendCoinsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SendCoinsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SendCoinsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SendCoinsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTxid();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string txid = 1;
 * @return {string}
 */
proto.lnrpc.SendCoinsResponse.prototype.getTxid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.SendCoinsResponse.prototype.setTxid = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListUnspentRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ListUnspentRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListUnspentRequest.displayName = 'proto.lnrpc.ListUnspentRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListUnspentRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListUnspentRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListUnspentRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListUnspentRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    minConfs: jspb.Message.getFieldWithDefault(msg, 1, 0),
    maxConfs: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListUnspentRequest}
 */
proto.lnrpc.ListUnspentRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListUnspentRequest;
  return proto.lnrpc.ListUnspentRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListUnspentRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListUnspentRequest}
 */
proto.lnrpc.ListUnspentRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinConfs(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMaxConfs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListUnspentRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListUnspentRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListUnspentRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListUnspentRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMinConfs();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getMaxConfs();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int32 min_confs = 1;
 * @return {number}
 */
proto.lnrpc.ListUnspentRequest.prototype.getMinConfs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.ListUnspentRequest.prototype.setMinConfs = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 max_confs = 2;
 * @return {number}
 */
proto.lnrpc.ListUnspentRequest.prototype.getMaxConfs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.ListUnspentRequest.prototype.setMaxConfs = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListUnspentResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ListUnspentResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ListUnspentResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListUnspentResponse.displayName = 'proto.lnrpc.ListUnspentResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ListUnspentResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListUnspentResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListUnspentResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListUnspentResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListUnspentResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    utxosList: jspb.Message.toObjectList(msg.getUtxosList(),
    proto.lnrpc.Utxo.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListUnspentResponse}
 */
proto.lnrpc.ListUnspentResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListUnspentResponse;
  return proto.lnrpc.ListUnspentResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListUnspentResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListUnspentResponse}
 */
proto.lnrpc.ListUnspentResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.Utxo;
      reader.readMessage(value,proto.lnrpc.Utxo.deserializeBinaryFromReader);
      msg.addUtxos(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListUnspentResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListUnspentResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListUnspentResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListUnspentResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUtxosList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.Utxo.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Utxo utxos = 1;
 * @return {!Array.<!proto.lnrpc.Utxo>}
 */
proto.lnrpc.ListUnspentResponse.prototype.getUtxosList = function() {
  return /** @type{!Array.<!proto.lnrpc.Utxo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Utxo, 1));
};


/** @param {!Array.<!proto.lnrpc.Utxo>} value */
proto.lnrpc.ListUnspentResponse.prototype.setUtxosList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.Utxo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Utxo}
 */
proto.lnrpc.ListUnspentResponse.prototype.addUtxos = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.Utxo, opt_index);
};


proto.lnrpc.ListUnspentResponse.prototype.clearUtxosList = function() {
  this.setUtxosList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NewAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.NewAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NewAddressRequest.displayName = 'proto.lnrpc.NewAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NewAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NewAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NewAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NewAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NewAddressRequest}
 */
proto.lnrpc.NewAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NewAddressRequest;
  return proto.lnrpc.NewAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NewAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NewAddressRequest}
 */
proto.lnrpc.NewAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.lnrpc.AddressType} */ (reader.readEnum());
      msg.setType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NewAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NewAddressRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NewAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NewAddressRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * optional AddressType type = 1;
 * @return {!proto.lnrpc.AddressType}
 */
proto.lnrpc.NewAddressRequest.prototype.getType = function() {
  return /** @type {!proto.lnrpc.AddressType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.lnrpc.AddressType} value */
proto.lnrpc.NewAddressRequest.prototype.setType = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NewAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.NewAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NewAddressResponse.displayName = 'proto.lnrpc.NewAddressResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NewAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NewAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NewAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NewAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NewAddressResponse}
 */
proto.lnrpc.NewAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NewAddressResponse;
  return proto.lnrpc.NewAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NewAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NewAddressResponse}
 */
proto.lnrpc.NewAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NewAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NewAddressResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NewAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NewAddressResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.lnrpc.NewAddressResponse.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.NewAddressResponse.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SignMessageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.SignMessageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SignMessageRequest.displayName = 'proto.lnrpc.SignMessageRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SignMessageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SignMessageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SignMessageRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SignMessageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    msg: msg.getMsg_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SignMessageRequest}
 */
proto.lnrpc.SignMessageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SignMessageRequest;
  return proto.lnrpc.SignMessageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SignMessageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SignMessageRequest}
 */
proto.lnrpc.SignMessageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMsg(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SignMessageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SignMessageRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SignMessageRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SignMessageRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMsg_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes msg = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.SignMessageRequest.prototype.getMsg = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes msg = 1;
 * This is a type-conversion wrapper around `getMsg()`
 * @return {string}
 */
proto.lnrpc.SignMessageRequest.prototype.getMsg_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMsg()));
};


/**
 * optional bytes msg = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMsg()`
 * @return {!Uint8Array}
 */
proto.lnrpc.SignMessageRequest.prototype.getMsg_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMsg()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.SignMessageRequest.prototype.setMsg = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.SignMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.SignMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.SignMessageResponse.displayName = 'proto.lnrpc.SignMessageResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.SignMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.SignMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.SignMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SignMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.SignMessageResponse}
 */
proto.lnrpc.SignMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.SignMessageResponse;
  return proto.lnrpc.SignMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.SignMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.SignMessageResponse}
 */
proto.lnrpc.SignMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.SignMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.SignMessageResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.SignMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.SignMessageResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSignature();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string signature = 1;
 * @return {string}
 */
proto.lnrpc.SignMessageResponse.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.SignMessageResponse.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.VerifyMessageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.VerifyMessageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.VerifyMessageRequest.displayName = 'proto.lnrpc.VerifyMessageRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.VerifyMessageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.VerifyMessageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.VerifyMessageRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.VerifyMessageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    msg: msg.getMsg_asB64(),
    signature: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.VerifyMessageRequest}
 */
proto.lnrpc.VerifyMessageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.VerifyMessageRequest;
  return proto.lnrpc.VerifyMessageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.VerifyMessageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.VerifyMessageRequest}
 */
proto.lnrpc.VerifyMessageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMsg(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.VerifyMessageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.VerifyMessageRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.VerifyMessageRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.VerifyMessageRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMsg_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getSignature();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional bytes msg = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.VerifyMessageRequest.prototype.getMsg = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes msg = 1;
 * This is a type-conversion wrapper around `getMsg()`
 * @return {string}
 */
proto.lnrpc.VerifyMessageRequest.prototype.getMsg_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMsg()));
};


/**
 * optional bytes msg = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMsg()`
 * @return {!Uint8Array}
 */
proto.lnrpc.VerifyMessageRequest.prototype.getMsg_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMsg()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.VerifyMessageRequest.prototype.setMsg = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string signature = 2;
 * @return {string}
 */
proto.lnrpc.VerifyMessageRequest.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.VerifyMessageRequest.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.VerifyMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.VerifyMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.VerifyMessageResponse.displayName = 'proto.lnrpc.VerifyMessageResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.VerifyMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.VerifyMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.VerifyMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.VerifyMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    valid: jspb.Message.getFieldWithDefault(msg, 1, false),
    pubkey: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.VerifyMessageResponse}
 */
proto.lnrpc.VerifyMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.VerifyMessageResponse;
  return proto.lnrpc.VerifyMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.VerifyMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.VerifyMessageResponse}
 */
proto.lnrpc.VerifyMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setValid(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubkey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.VerifyMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.VerifyMessageResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.VerifyMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.VerifyMessageResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValid();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getPubkey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional bool valid = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.VerifyMessageResponse.prototype.getValid = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.VerifyMessageResponse.prototype.setValid = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string pubkey = 2;
 * @return {string}
 */
proto.lnrpc.VerifyMessageResponse.prototype.getPubkey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.VerifyMessageResponse.prototype.setPubkey = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ConnectPeerRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ConnectPeerRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ConnectPeerRequest.displayName = 'proto.lnrpc.ConnectPeerRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ConnectPeerRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ConnectPeerRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ConnectPeerRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ConnectPeerRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    addr: (f = msg.getAddr()) && proto.lnrpc.LightningAddress.toObject(includeInstance, f),
    perm: jspb.Message.getFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ConnectPeerRequest}
 */
proto.lnrpc.ConnectPeerRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ConnectPeerRequest;
  return proto.lnrpc.ConnectPeerRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ConnectPeerRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ConnectPeerRequest}
 */
proto.lnrpc.ConnectPeerRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.LightningAddress;
      reader.readMessage(value,proto.lnrpc.LightningAddress.deserializeBinaryFromReader);
      msg.setAddr(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPerm(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ConnectPeerRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ConnectPeerRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ConnectPeerRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ConnectPeerRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddr();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.LightningAddress.serializeBinaryToWriter
    );
  }
  f = message.getPerm();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional LightningAddress addr = 1;
 * @return {?proto.lnrpc.LightningAddress}
 */
proto.lnrpc.ConnectPeerRequest.prototype.getAddr = function() {
  return /** @type{?proto.lnrpc.LightningAddress} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.LightningAddress, 1));
};


/** @param {?proto.lnrpc.LightningAddress|undefined} value */
proto.lnrpc.ConnectPeerRequest.prototype.setAddr = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.ConnectPeerRequest.prototype.clearAddr = function() {
  this.setAddr(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ConnectPeerRequest.prototype.hasAddr = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool perm = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ConnectPeerRequest.prototype.getPerm = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.lnrpc.ConnectPeerRequest.prototype.setPerm = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ConnectPeerResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ConnectPeerResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ConnectPeerResponse.displayName = 'proto.lnrpc.ConnectPeerResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ConnectPeerResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ConnectPeerResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ConnectPeerResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ConnectPeerResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ConnectPeerResponse}
 */
proto.lnrpc.ConnectPeerResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ConnectPeerResponse;
  return proto.lnrpc.ConnectPeerResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ConnectPeerResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ConnectPeerResponse}
 */
proto.lnrpc.ConnectPeerResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ConnectPeerResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ConnectPeerResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ConnectPeerResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ConnectPeerResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.DisconnectPeerRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.DisconnectPeerRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.DisconnectPeerRequest.displayName = 'proto.lnrpc.DisconnectPeerRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.DisconnectPeerRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.DisconnectPeerRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.DisconnectPeerRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DisconnectPeerRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    pubKey: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.DisconnectPeerRequest}
 */
proto.lnrpc.DisconnectPeerRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.DisconnectPeerRequest;
  return proto.lnrpc.DisconnectPeerRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.DisconnectPeerRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.DisconnectPeerRequest}
 */
proto.lnrpc.DisconnectPeerRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.DisconnectPeerRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.DisconnectPeerRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.DisconnectPeerRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DisconnectPeerRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPubKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string pub_key = 1;
 * @return {string}
 */
proto.lnrpc.DisconnectPeerRequest.prototype.getPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.DisconnectPeerRequest.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.DisconnectPeerResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.DisconnectPeerResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.DisconnectPeerResponse.displayName = 'proto.lnrpc.DisconnectPeerResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.DisconnectPeerResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.DisconnectPeerResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.DisconnectPeerResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DisconnectPeerResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.DisconnectPeerResponse}
 */
proto.lnrpc.DisconnectPeerResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.DisconnectPeerResponse;
  return proto.lnrpc.DisconnectPeerResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.DisconnectPeerResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.DisconnectPeerResponse}
 */
proto.lnrpc.DisconnectPeerResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.DisconnectPeerResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.DisconnectPeerResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.DisconnectPeerResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DisconnectPeerResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.HTLC = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.HTLC, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.HTLC.displayName = 'proto.lnrpc.HTLC';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.HTLC.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.HTLC.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.HTLC} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.HTLC.toObject = function(includeInstance, msg) {
  var f, obj = {
    incoming: jspb.Message.getFieldWithDefault(msg, 1, false),
    amount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    hashLock: msg.getHashLock_asB64(),
    expirationHeight: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.HTLC}
 */
proto.lnrpc.HTLC.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.HTLC;
  return proto.lnrpc.HTLC.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.HTLC} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.HTLC}
 */
proto.lnrpc.HTLC.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncoming(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHashLock(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpirationHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.HTLC.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.HTLC.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.HTLC} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.HTLC.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIncoming();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getHashLock_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getExpirationHeight();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional bool incoming = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.HTLC.prototype.getIncoming = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.HTLC.prototype.setIncoming = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 amount = 2;
 * @return {number}
 */
proto.lnrpc.HTLC.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.HTLC.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes hash_lock = 3;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.HTLC.prototype.getHashLock = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes hash_lock = 3;
 * This is a type-conversion wrapper around `getHashLock()`
 * @return {string}
 */
proto.lnrpc.HTLC.prototype.getHashLock_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHashLock()));
};


/**
 * optional bytes hash_lock = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHashLock()`
 * @return {!Uint8Array}
 */
proto.lnrpc.HTLC.prototype.getHashLock_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHashLock()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.HTLC.prototype.setHashLock = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 expiration_height = 4;
 * @return {number}
 */
proto.lnrpc.HTLC.prototype.getExpirationHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.HTLC.prototype.setExpirationHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Channel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.Channel.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.Channel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Channel.displayName = 'proto.lnrpc.Channel';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.Channel.repeatedFields_ = [15];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Channel.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Channel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Channel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Channel.toObject = function(includeInstance, msg) {
  var f, obj = {
    active: jspb.Message.getFieldWithDefault(msg, 1, false),
    remotePubkey: jspb.Message.getFieldWithDefault(msg, 2, ""),
    channelPoint: jspb.Message.getFieldWithDefault(msg, 3, ""),
    chanId: jspb.Message.getFieldWithDefault(msg, 4, "0"),
    capacity: jspb.Message.getFieldWithDefault(msg, 5, 0),
    localBalance: jspb.Message.getFieldWithDefault(msg, 6, 0),
    remoteBalance: jspb.Message.getFieldWithDefault(msg, 7, 0),
    commitFee: jspb.Message.getFieldWithDefault(msg, 8, 0),
    commitSize: jspb.Message.getFieldWithDefault(msg, 9, 0),
    feePerKb: jspb.Message.getFieldWithDefault(msg, 10, 0),
    unsettledBalance: jspb.Message.getFieldWithDefault(msg, 11, 0),
    totalAtomsSent: jspb.Message.getFieldWithDefault(msg, 12, 0),
    totalAtomsReceived: jspb.Message.getFieldWithDefault(msg, 13, 0),
    numUpdates: jspb.Message.getFieldWithDefault(msg, 14, 0),
    pendingHtlcsList: jspb.Message.toObjectList(msg.getPendingHtlcsList(),
    proto.lnrpc.HTLC.toObject, includeInstance),
    csvDelay: jspb.Message.getFieldWithDefault(msg, 16, 0),
    pb_private: jspb.Message.getFieldWithDefault(msg, 17, false),
    initiator: jspb.Message.getFieldWithDefault(msg, 18, false),
    chanStatusFlags: jspb.Message.getFieldWithDefault(msg, 19, ""),
    localChanReserveAtoms: jspb.Message.getFieldWithDefault(msg, 20, 0),
    remoteChanReserveAtoms: jspb.Message.getFieldWithDefault(msg, 21, 0),
    staticRemoteKey: jspb.Message.getFieldWithDefault(msg, 22, false),
    lifetime: jspb.Message.getFieldWithDefault(msg, 23, 0),
    uptime: jspb.Message.getFieldWithDefault(msg, 24, 0),
    closeAddress: jspb.Message.getFieldWithDefault(msg, 25, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Channel}
 */
proto.lnrpc.Channel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Channel;
  return proto.lnrpc.Channel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Channel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Channel}
 */
proto.lnrpc.Channel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setActive(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setRemotePubkey(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setChannelPoint(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanId(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCapacity(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLocalBalance(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setRemoteBalance(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCommitFee(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCommitSize(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeePerKb(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUnsettledBalance(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalAtomsSent(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalAtomsReceived(value);
      break;
    case 14:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNumUpdates(value);
      break;
    case 15:
      var value = new proto.lnrpc.HTLC;
      reader.readMessage(value,proto.lnrpc.HTLC.deserializeBinaryFromReader);
      msg.addPendingHtlcs(value);
      break;
    case 16:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCsvDelay(value);
      break;
    case 17:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPrivate(value);
      break;
    case 18:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setInitiator(value);
      break;
    case 19:
      var value = /** @type {string} */ (reader.readString());
      msg.setChanStatusFlags(value);
      break;
    case 20:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLocalChanReserveAtoms(value);
      break;
    case 21:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setRemoteChanReserveAtoms(value);
      break;
    case 22:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setStaticRemoteKey(value);
      break;
    case 23:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLifetime(value);
      break;
    case 24:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUptime(value);
      break;
    case 25:
      var value = /** @type {string} */ (reader.readString());
      msg.setCloseAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Channel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Channel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Channel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Channel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActive();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getRemotePubkey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getChannelPoint();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      4,
      f
    );
  }
  f = message.getCapacity();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getLocalBalance();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getRemoteBalance();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getCommitFee();
  if (f !== 0) {
    writer.writeInt64(
      8,
      f
    );
  }
  f = message.getCommitSize();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
  f = message.getFeePerKb();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = message.getUnsettledBalance();
  if (f !== 0) {
    writer.writeInt64(
      11,
      f
    );
  }
  f = message.getTotalAtomsSent();
  if (f !== 0) {
    writer.writeInt64(
      12,
      f
    );
  }
  f = message.getTotalAtomsReceived();
  if (f !== 0) {
    writer.writeInt64(
      13,
      f
    );
  }
  f = message.getNumUpdates();
  if (f !== 0) {
    writer.writeUint64(
      14,
      f
    );
  }
  f = message.getPendingHtlcsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      15,
      f,
      proto.lnrpc.HTLC.serializeBinaryToWriter
    );
  }
  f = message.getCsvDelay();
  if (f !== 0) {
    writer.writeUint32(
      16,
      f
    );
  }
  f = message.getPrivate();
  if (f) {
    writer.writeBool(
      17,
      f
    );
  }
  f = message.getInitiator();
  if (f) {
    writer.writeBool(
      18,
      f
    );
  }
  f = message.getChanStatusFlags();
  if (f.length > 0) {
    writer.writeString(
      19,
      f
    );
  }
  f = message.getLocalChanReserveAtoms();
  if (f !== 0) {
    writer.writeInt64(
      20,
      f
    );
  }
  f = message.getRemoteChanReserveAtoms();
  if (f !== 0) {
    writer.writeInt64(
      21,
      f
    );
  }
  f = message.getStaticRemoteKey();
  if (f) {
    writer.writeBool(
      22,
      f
    );
  }
  f = message.getLifetime();
  if (f !== 0) {
    writer.writeInt64(
      23,
      f
    );
  }
  f = message.getUptime();
  if (f !== 0) {
    writer.writeInt64(
      24,
      f
    );
  }
  f = message.getCloseAddress();
  if (f.length > 0) {
    writer.writeString(
      25,
      f
    );
  }
};


/**
 * optional bool active = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Channel.prototype.getActive = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.Channel.prototype.setActive = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string remote_pubkey = 2;
 * @return {string}
 */
proto.lnrpc.Channel.prototype.getRemotePubkey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.Channel.prototype.setRemotePubkey = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string channel_point = 3;
 * @return {string}
 */
proto.lnrpc.Channel.prototype.getChannelPoint = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.lnrpc.Channel.prototype.setChannelPoint = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint64 chan_id = 4;
 * @return {string}
 */
proto.lnrpc.Channel.prototype.getChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, "0"));
};


/** @param {string} value */
proto.lnrpc.Channel.prototype.setChanId = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 capacity = 5;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setCapacity = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 local_balance = 6;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getLocalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setLocalBalance = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 remote_balance = 7;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getRemoteBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setRemoteBalance = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional int64 commit_fee = 8;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getCommitFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setCommitFee = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional int64 commit_size = 9;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getCommitSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setCommitSize = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 fee_per_kb = 10;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setFeePerKb = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int64 unsettled_balance = 11;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getUnsettledBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setUnsettledBalance = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * optional int64 total_atoms_sent = 12;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getTotalAtomsSent = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setTotalAtomsSent = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * optional int64 total_atoms_received = 13;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getTotalAtomsReceived = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setTotalAtomsReceived = function(value) {
  jspb.Message.setField(this, 13, value);
};


/**
 * optional uint64 num_updates = 14;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getNumUpdates = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 14, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setNumUpdates = function(value) {
  jspb.Message.setField(this, 14, value);
};


/**
 * repeated HTLC pending_htlcs = 15;
 * @return {!Array.<!proto.lnrpc.HTLC>}
 */
proto.lnrpc.Channel.prototype.getPendingHtlcsList = function() {
  return /** @type{!Array.<!proto.lnrpc.HTLC>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.HTLC, 15));
};


/** @param {!Array.<!proto.lnrpc.HTLC>} value */
proto.lnrpc.Channel.prototype.setPendingHtlcsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 15, value);
};


/**
 * @param {!proto.lnrpc.HTLC=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.HTLC}
 */
proto.lnrpc.Channel.prototype.addPendingHtlcs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 15, opt_value, proto.lnrpc.HTLC, opt_index);
};


proto.lnrpc.Channel.prototype.clearPendingHtlcsList = function() {
  this.setPendingHtlcsList([]);
};


/**
 * optional uint32 csv_delay = 16;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getCsvDelay = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 16, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setCsvDelay = function(value) {
  jspb.Message.setField(this, 16, value);
};


/**
 * optional bool private = 17;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Channel.prototype.getPrivate = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 17, false));
};


/** @param {boolean} value */
proto.lnrpc.Channel.prototype.setPrivate = function(value) {
  jspb.Message.setField(this, 17, value);
};


/**
 * optional bool initiator = 18;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Channel.prototype.getInitiator = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 18, false));
};


/** @param {boolean} value */
proto.lnrpc.Channel.prototype.setInitiator = function(value) {
  jspb.Message.setField(this, 18, value);
};


/**
 * optional string chan_status_flags = 19;
 * @return {string}
 */
proto.lnrpc.Channel.prototype.getChanStatusFlags = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 19, ""));
};


/** @param {string} value */
proto.lnrpc.Channel.prototype.setChanStatusFlags = function(value) {
  jspb.Message.setField(this, 19, value);
};


/**
 * optional int64 local_chan_reserve_atoms = 20;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getLocalChanReserveAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 20, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setLocalChanReserveAtoms = function(value) {
  jspb.Message.setField(this, 20, value);
};


/**
 * optional int64 remote_chan_reserve_atoms = 21;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getRemoteChanReserveAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 21, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setRemoteChanReserveAtoms = function(value) {
  jspb.Message.setField(this, 21, value);
};


/**
 * optional bool static_remote_key = 22;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Channel.prototype.getStaticRemoteKey = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 22, false));
};


/** @param {boolean} value */
proto.lnrpc.Channel.prototype.setStaticRemoteKey = function(value) {
  jspb.Message.setField(this, 22, value);
};


/**
 * optional int64 lifetime = 23;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getLifetime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 23, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setLifetime = function(value) {
  jspb.Message.setField(this, 23, value);
};


/**
 * optional int64 uptime = 24;
 * @return {number}
 */
proto.lnrpc.Channel.prototype.getUptime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 24, 0));
};


/** @param {number} value */
proto.lnrpc.Channel.prototype.setUptime = function(value) {
  jspb.Message.setField(this, 24, value);
};


/**
 * optional string close_address = 25;
 * @return {string}
 */
proto.lnrpc.Channel.prototype.getCloseAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 25, ""));
};


/** @param {string} value */
proto.lnrpc.Channel.prototype.setCloseAddress = function(value) {
  jspb.Message.setField(this, 25, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListChannelsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ListChannelsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListChannelsRequest.displayName = 'proto.lnrpc.ListChannelsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListChannelsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListChannelsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListChannelsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListChannelsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    activeOnly: jspb.Message.getFieldWithDefault(msg, 1, false),
    inactiveOnly: jspb.Message.getFieldWithDefault(msg, 2, false),
    publicOnly: jspb.Message.getFieldWithDefault(msg, 3, false),
    privateOnly: jspb.Message.getFieldWithDefault(msg, 4, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListChannelsRequest}
 */
proto.lnrpc.ListChannelsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListChannelsRequest;
  return proto.lnrpc.ListChannelsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListChannelsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListChannelsRequest}
 */
proto.lnrpc.ListChannelsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setActiveOnly(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setInactiveOnly(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPublicOnly(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPrivateOnly(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListChannelsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListChannelsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListChannelsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListChannelsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActiveOnly();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getInactiveOnly();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getPublicOnly();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getPrivateOnly();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * optional bool active_only = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ListChannelsRequest.prototype.getActiveOnly = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.ListChannelsRequest.prototype.setActiveOnly = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool inactive_only = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ListChannelsRequest.prototype.getInactiveOnly = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.lnrpc.ListChannelsRequest.prototype.setInactiveOnly = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool public_only = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ListChannelsRequest.prototype.getPublicOnly = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.lnrpc.ListChannelsRequest.prototype.setPublicOnly = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool private_only = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ListChannelsRequest.prototype.getPrivateOnly = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.lnrpc.ListChannelsRequest.prototype.setPrivateOnly = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListChannelsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ListChannelsResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ListChannelsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListChannelsResponse.displayName = 'proto.lnrpc.ListChannelsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ListChannelsResponse.repeatedFields_ = [11];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListChannelsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListChannelsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListChannelsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListChannelsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelsList: jspb.Message.toObjectList(msg.getChannelsList(),
    proto.lnrpc.Channel.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListChannelsResponse}
 */
proto.lnrpc.ListChannelsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListChannelsResponse;
  return proto.lnrpc.ListChannelsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListChannelsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListChannelsResponse}
 */
proto.lnrpc.ListChannelsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 11:
      var value = new proto.lnrpc.Channel;
      reader.readMessage(value,proto.lnrpc.Channel.deserializeBinaryFromReader);
      msg.addChannels(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListChannelsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListChannelsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListChannelsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListChannelsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      11,
      f,
      proto.lnrpc.Channel.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Channel channels = 11;
 * @return {!Array.<!proto.lnrpc.Channel>}
 */
proto.lnrpc.ListChannelsResponse.prototype.getChannelsList = function() {
  return /** @type{!Array.<!proto.lnrpc.Channel>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Channel, 11));
};


/** @param {!Array.<!proto.lnrpc.Channel>} value */
proto.lnrpc.ListChannelsResponse.prototype.setChannelsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 11, value);
};


/**
 * @param {!proto.lnrpc.Channel=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Channel}
 */
proto.lnrpc.ListChannelsResponse.prototype.addChannels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 11, opt_value, proto.lnrpc.Channel, opt_index);
};


proto.lnrpc.ListChannelsResponse.prototype.clearChannelsList = function() {
  this.setChannelsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelCloseSummary = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelCloseSummary, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelCloseSummary.displayName = 'proto.lnrpc.ChannelCloseSummary';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelCloseSummary.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelCloseSummary.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelCloseSummary} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelCloseSummary.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelPoint: jspb.Message.getFieldWithDefault(msg, 1, ""),
    chanId: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    chainHash: jspb.Message.getFieldWithDefault(msg, 3, ""),
    closingTxHash: jspb.Message.getFieldWithDefault(msg, 4, ""),
    remotePubkey: jspb.Message.getFieldWithDefault(msg, 5, ""),
    capacity: jspb.Message.getFieldWithDefault(msg, 6, 0),
    closeHeight: jspb.Message.getFieldWithDefault(msg, 7, 0),
    settledBalance: jspb.Message.getFieldWithDefault(msg, 8, 0),
    timeLockedBalance: jspb.Message.getFieldWithDefault(msg, 9, 0),
    closeType: jspb.Message.getFieldWithDefault(msg, 10, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelCloseSummary}
 */
proto.lnrpc.ChannelCloseSummary.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelCloseSummary;
  return proto.lnrpc.ChannelCloseSummary.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelCloseSummary} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelCloseSummary}
 */
proto.lnrpc.ChannelCloseSummary.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setChannelPoint(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanId(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setChainHash(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setClosingTxHash(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setRemotePubkey(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCapacity(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCloseHeight(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSettledBalance(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimeLockedBalance(value);
      break;
    case 10:
      var value = /** @type {!proto.lnrpc.ChannelCloseSummary.ClosureType} */ (reader.readEnum());
      msg.setCloseType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelCloseSummary.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelCloseSummary.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelCloseSummary} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelCloseSummary.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelPoint();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      2,
      f
    );
  }
  f = message.getChainHash();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getClosingTxHash();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getRemotePubkey();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getCapacity();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getCloseHeight();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = message.getSettledBalance();
  if (f !== 0) {
    writer.writeInt64(
      8,
      f
    );
  }
  f = message.getTimeLockedBalance();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
  f = message.getCloseType();
  if (f !== 0.0) {
    writer.writeEnum(
      10,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.lnrpc.ChannelCloseSummary.ClosureType = {
  COOPERATIVE_CLOSE: 0,
  LOCAL_FORCE_CLOSE: 1,
  REMOTE_FORCE_CLOSE: 2,
  BREACH_CLOSE: 3,
  FUNDING_CANCELED: 4,
  ABANDONED: 5
};

/**
 * optional string channel_point = 1;
 * @return {string}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getChannelPoint = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelCloseSummary.prototype.setChannelPoint = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint64 chan_id = 2;
 * @return {string}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/** @param {string} value */
proto.lnrpc.ChannelCloseSummary.prototype.setChanId = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string chain_hash = 3;
 * @return {string}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getChainHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelCloseSummary.prototype.setChainHash = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string closing_tx_hash = 4;
 * @return {string}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getClosingTxHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelCloseSummary.prototype.setClosingTxHash = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string remote_pubkey = 5;
 * @return {string}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getRemotePubkey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelCloseSummary.prototype.setRemotePubkey = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 capacity = 6;
 * @return {number}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelCloseSummary.prototype.setCapacity = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint32 close_height = 7;
 * @return {number}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getCloseHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelCloseSummary.prototype.setCloseHeight = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional int64 settled_balance = 8;
 * @return {number}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getSettledBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelCloseSummary.prototype.setSettledBalance = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional int64 time_locked_balance = 9;
 * @return {number}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getTimeLockedBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelCloseSummary.prototype.setTimeLockedBalance = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional ClosureType close_type = 10;
 * @return {!proto.lnrpc.ChannelCloseSummary.ClosureType}
 */
proto.lnrpc.ChannelCloseSummary.prototype.getCloseType = function() {
  return /** @type {!proto.lnrpc.ChannelCloseSummary.ClosureType} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {!proto.lnrpc.ChannelCloseSummary.ClosureType} value */
proto.lnrpc.ChannelCloseSummary.prototype.setCloseType = function(value) {
  jspb.Message.setField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ClosedChannelsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ClosedChannelsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ClosedChannelsRequest.displayName = 'proto.lnrpc.ClosedChannelsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ClosedChannelsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ClosedChannelsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ClosedChannelsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ClosedChannelsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    cooperative: jspb.Message.getFieldWithDefault(msg, 1, false),
    localForce: jspb.Message.getFieldWithDefault(msg, 2, false),
    remoteForce: jspb.Message.getFieldWithDefault(msg, 3, false),
    breach: jspb.Message.getFieldWithDefault(msg, 4, false),
    fundingCanceled: jspb.Message.getFieldWithDefault(msg, 5, false),
    abandoned: jspb.Message.getFieldWithDefault(msg, 6, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ClosedChannelsRequest}
 */
proto.lnrpc.ClosedChannelsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ClosedChannelsRequest;
  return proto.lnrpc.ClosedChannelsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ClosedChannelsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ClosedChannelsRequest}
 */
proto.lnrpc.ClosedChannelsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setCooperative(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setLocalForce(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRemoteForce(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setBreach(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFundingCanceled(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAbandoned(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ClosedChannelsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ClosedChannelsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ClosedChannelsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ClosedChannelsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCooperative();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getLocalForce();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getRemoteForce();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getBreach();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getFundingCanceled();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getAbandoned();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
};


/**
 * optional bool cooperative = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ClosedChannelsRequest.prototype.getCooperative = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.ClosedChannelsRequest.prototype.setCooperative = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool local_force = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ClosedChannelsRequest.prototype.getLocalForce = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.lnrpc.ClosedChannelsRequest.prototype.setLocalForce = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool remote_force = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ClosedChannelsRequest.prototype.getRemoteForce = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.lnrpc.ClosedChannelsRequest.prototype.setRemoteForce = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool breach = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ClosedChannelsRequest.prototype.getBreach = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.lnrpc.ClosedChannelsRequest.prototype.setBreach = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool funding_canceled = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ClosedChannelsRequest.prototype.getFundingCanceled = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.lnrpc.ClosedChannelsRequest.prototype.setFundingCanceled = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool abandoned = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ClosedChannelsRequest.prototype.getAbandoned = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.lnrpc.ClosedChannelsRequest.prototype.setAbandoned = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ClosedChannelsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ClosedChannelsResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ClosedChannelsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ClosedChannelsResponse.displayName = 'proto.lnrpc.ClosedChannelsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ClosedChannelsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ClosedChannelsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ClosedChannelsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ClosedChannelsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ClosedChannelsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelsList: jspb.Message.toObjectList(msg.getChannelsList(),
    proto.lnrpc.ChannelCloseSummary.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ClosedChannelsResponse}
 */
proto.lnrpc.ClosedChannelsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ClosedChannelsResponse;
  return proto.lnrpc.ClosedChannelsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ClosedChannelsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ClosedChannelsResponse}
 */
proto.lnrpc.ClosedChannelsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelCloseSummary;
      reader.readMessage(value,proto.lnrpc.ChannelCloseSummary.deserializeBinaryFromReader);
      msg.addChannels(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ClosedChannelsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ClosedChannelsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ClosedChannelsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ClosedChannelsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.ChannelCloseSummary.serializeBinaryToWriter
    );
  }
};


/**
 * repeated ChannelCloseSummary channels = 1;
 * @return {!Array.<!proto.lnrpc.ChannelCloseSummary>}
 */
proto.lnrpc.ClosedChannelsResponse.prototype.getChannelsList = function() {
  return /** @type{!Array.<!proto.lnrpc.ChannelCloseSummary>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ChannelCloseSummary, 1));
};


/** @param {!Array.<!proto.lnrpc.ChannelCloseSummary>} value */
proto.lnrpc.ClosedChannelsResponse.prototype.setChannelsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.ChannelCloseSummary=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ChannelCloseSummary}
 */
proto.lnrpc.ClosedChannelsResponse.prototype.addChannels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.ChannelCloseSummary, opt_index);
};


proto.lnrpc.ClosedChannelsResponse.prototype.clearChannelsList = function() {
  this.setChannelsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Peer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.Peer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Peer.displayName = 'proto.lnrpc.Peer';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Peer.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Peer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Peer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Peer.toObject = function(includeInstance, msg) {
  var f, obj = {
    pubKey: jspb.Message.getFieldWithDefault(msg, 1, ""),
    address: jspb.Message.getFieldWithDefault(msg, 3, ""),
    bytesSent: jspb.Message.getFieldWithDefault(msg, 4, 0),
    bytesRecv: jspb.Message.getFieldWithDefault(msg, 5, 0),
    atomsSent: jspb.Message.getFieldWithDefault(msg, 6, 0),
    atomsRecv: jspb.Message.getFieldWithDefault(msg, 7, 0),
    inbound: jspb.Message.getFieldWithDefault(msg, 8, false),
    pingTime: jspb.Message.getFieldWithDefault(msg, 9, 0),
    syncType: jspb.Message.getFieldWithDefault(msg, 10, 0),
    featuresMap: (f = msg.getFeaturesMap()) ? f.toObject(includeInstance, proto.lnrpc.Feature.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Peer}
 */
proto.lnrpc.Peer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Peer;
  return proto.lnrpc.Peer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Peer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Peer}
 */
proto.lnrpc.Peer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKey(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBytesSent(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setBytesRecv(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAtomsSent(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAtomsRecv(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setInbound(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setPingTime(value);
      break;
    case 10:
      var value = /** @type {!proto.lnrpc.Peer.SyncType} */ (reader.readEnum());
      msg.setSyncType(value);
      break;
    case 11:
      var value = msg.getFeaturesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint32, jspb.BinaryReader.prototype.readMessage, proto.lnrpc.Feature.deserializeBinaryFromReader);
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Peer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Peer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Peer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Peer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPubKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getBytesSent();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getBytesRecv();
  if (f !== 0) {
    writer.writeUint64(
      5,
      f
    );
  }
  f = message.getAtomsSent();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getAtomsRecv();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getInbound();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
  f = message.getPingTime();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
  f = message.getSyncType();
  if (f !== 0.0) {
    writer.writeEnum(
      10,
      f
    );
  }
  f = message.getFeaturesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(11, writer, jspb.BinaryWriter.prototype.writeUint32, jspb.BinaryWriter.prototype.writeMessage, proto.lnrpc.Feature.serializeBinaryToWriter);
  }
};


/**
 * @enum {number}
 */
proto.lnrpc.Peer.SyncType = {
  UNKNOWN_SYNC: 0,
  ACTIVE_SYNC: 1,
  PASSIVE_SYNC: 2
};

/**
 * optional string pub_key = 1;
 * @return {string}
 */
proto.lnrpc.Peer.prototype.getPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.Peer.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string address = 3;
 * @return {string}
 */
proto.lnrpc.Peer.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.lnrpc.Peer.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint64 bytes_sent = 4;
 * @return {number}
 */
proto.lnrpc.Peer.prototype.getBytesSent = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.Peer.prototype.setBytesSent = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint64 bytes_recv = 5;
 * @return {number}
 */
proto.lnrpc.Peer.prototype.getBytesRecv = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.Peer.prototype.setBytesRecv = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 atoms_sent = 6;
 * @return {number}
 */
proto.lnrpc.Peer.prototype.getAtomsSent = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.Peer.prototype.setAtomsSent = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 atoms_recv = 7;
 * @return {number}
 */
proto.lnrpc.Peer.prototype.getAtomsRecv = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.Peer.prototype.setAtomsRecv = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional bool inbound = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Peer.prototype.getInbound = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.lnrpc.Peer.prototype.setInbound = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional int64 ping_time = 9;
 * @return {number}
 */
proto.lnrpc.Peer.prototype.getPingTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.lnrpc.Peer.prototype.setPingTime = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional SyncType sync_type = 10;
 * @return {!proto.lnrpc.Peer.SyncType}
 */
proto.lnrpc.Peer.prototype.getSyncType = function() {
  return /** @type {!proto.lnrpc.Peer.SyncType} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {!proto.lnrpc.Peer.SyncType} value */
proto.lnrpc.Peer.prototype.setSyncType = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * map<uint32, Feature> features = 11;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!proto.lnrpc.Feature>}
 */
proto.lnrpc.Peer.prototype.getFeaturesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!proto.lnrpc.Feature>} */ (
      jspb.Message.getMapField(this, 11, opt_noLazyCreate,
      proto.lnrpc.Feature));
};


proto.lnrpc.Peer.prototype.clearFeaturesMap = function() {
  this.getFeaturesMap().clear();
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListPeersRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ListPeersRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListPeersRequest.displayName = 'proto.lnrpc.ListPeersRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListPeersRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListPeersRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListPeersRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListPeersRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListPeersRequest}
 */
proto.lnrpc.ListPeersRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListPeersRequest;
  return proto.lnrpc.ListPeersRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListPeersRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListPeersRequest}
 */
proto.lnrpc.ListPeersRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListPeersRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListPeersRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListPeersRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListPeersRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListPeersResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ListPeersResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ListPeersResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListPeersResponse.displayName = 'proto.lnrpc.ListPeersResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ListPeersResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListPeersResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListPeersResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListPeersResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListPeersResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    peersList: jspb.Message.toObjectList(msg.getPeersList(),
    proto.lnrpc.Peer.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListPeersResponse}
 */
proto.lnrpc.ListPeersResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListPeersResponse;
  return proto.lnrpc.ListPeersResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListPeersResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListPeersResponse}
 */
proto.lnrpc.ListPeersResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.Peer;
      reader.readMessage(value,proto.lnrpc.Peer.deserializeBinaryFromReader);
      msg.addPeers(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListPeersResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListPeersResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListPeersResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListPeersResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPeersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.Peer.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Peer peers = 1;
 * @return {!Array.<!proto.lnrpc.Peer>}
 */
proto.lnrpc.ListPeersResponse.prototype.getPeersList = function() {
  return /** @type{!Array.<!proto.lnrpc.Peer>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Peer, 1));
};


/** @param {!Array.<!proto.lnrpc.Peer>} value */
proto.lnrpc.ListPeersResponse.prototype.setPeersList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.Peer=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Peer}
 */
proto.lnrpc.ListPeersResponse.prototype.addPeers = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.Peer, opt_index);
};


proto.lnrpc.ListPeersResponse.prototype.clearPeersList = function() {
  this.setPeersList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PeerEventSubscription = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PeerEventSubscription, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PeerEventSubscription.displayName = 'proto.lnrpc.PeerEventSubscription';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PeerEventSubscription.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PeerEventSubscription.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PeerEventSubscription} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PeerEventSubscription.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PeerEventSubscription}
 */
proto.lnrpc.PeerEventSubscription.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PeerEventSubscription;
  return proto.lnrpc.PeerEventSubscription.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PeerEventSubscription} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PeerEventSubscription}
 */
proto.lnrpc.PeerEventSubscription.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PeerEventSubscription.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PeerEventSubscription.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PeerEventSubscription} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PeerEventSubscription.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PeerEvent = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PeerEvent, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PeerEvent.displayName = 'proto.lnrpc.PeerEvent';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PeerEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PeerEvent.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PeerEvent} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PeerEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    pubKey: jspb.Message.getFieldWithDefault(msg, 1, ""),
    type: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PeerEvent}
 */
proto.lnrpc.PeerEvent.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PeerEvent;
  return proto.lnrpc.PeerEvent.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PeerEvent} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PeerEvent}
 */
proto.lnrpc.PeerEvent.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKey(value);
      break;
    case 2:
      var value = /** @type {!proto.lnrpc.PeerEvent.EventType} */ (reader.readEnum());
      msg.setType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PeerEvent.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PeerEvent.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PeerEvent} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PeerEvent.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPubKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.lnrpc.PeerEvent.EventType = {
  PEER_ONLINE: 0,
  PEER_OFFLINE: 1
};

/**
 * optional string pub_key = 1;
 * @return {string}
 */
proto.lnrpc.PeerEvent.prototype.getPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.PeerEvent.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional EventType type = 2;
 * @return {!proto.lnrpc.PeerEvent.EventType}
 */
proto.lnrpc.PeerEvent.prototype.getType = function() {
  return /** @type {!proto.lnrpc.PeerEvent.EventType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.lnrpc.PeerEvent.EventType} value */
proto.lnrpc.PeerEvent.prototype.setType = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.GetInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.GetInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.GetInfoRequest.displayName = 'proto.lnrpc.GetInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.GetInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.GetInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.GetInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GetInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.GetInfoRequest}
 */
proto.lnrpc.GetInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.GetInfoRequest;
  return proto.lnrpc.GetInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.GetInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.GetInfoRequest}
 */
proto.lnrpc.GetInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.GetInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.GetInfoRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.GetInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GetInfoRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.GetInfoResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 500, proto.lnrpc.GetInfoResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.GetInfoResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.GetInfoResponse.displayName = 'proto.lnrpc.GetInfoResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.GetInfoResponse.repeatedFields_ = [16,12];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.GetInfoResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.GetInfoResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.GetInfoResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GetInfoResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: jspb.Message.getFieldWithDefault(msg, 14, ""),
    identityPubkey: jspb.Message.getFieldWithDefault(msg, 1, ""),
    alias: jspb.Message.getFieldWithDefault(msg, 2, ""),
    color: jspb.Message.getFieldWithDefault(msg, 17, ""),
    numPendingChannels: jspb.Message.getFieldWithDefault(msg, 3, 0),
    numActiveChannels: jspb.Message.getFieldWithDefault(msg, 4, 0),
    numInactiveChannels: jspb.Message.getFieldWithDefault(msg, 15, 0),
    numPeers: jspb.Message.getFieldWithDefault(msg, 5, 0),
    blockHeight: jspb.Message.getFieldWithDefault(msg, 6, 0),
    blockHash: jspb.Message.getFieldWithDefault(msg, 8, ""),
    bestHeaderTimestamp: jspb.Message.getFieldWithDefault(msg, 13, 0),
    syncedToChain: jspb.Message.getFieldWithDefault(msg, 9, false),
    syncedToGraph: jspb.Message.getFieldWithDefault(msg, 18, false),
    testnet: jspb.Message.getFieldWithDefault(msg, 10, false),
    chainsList: jspb.Message.toObjectList(msg.getChainsList(),
    proto.lnrpc.Chain.toObject, includeInstance),
    urisList: jspb.Message.getRepeatedField(msg, 12),
    featuresMap: (f = msg.getFeaturesMap()) ? f.toObject(includeInstance, proto.lnrpc.Feature.toObject) : [],
    serverActive: jspb.Message.getFieldWithDefault(msg, 901, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.GetInfoResponse}
 */
proto.lnrpc.GetInfoResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.GetInfoResponse;
  return proto.lnrpc.GetInfoResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.GetInfoResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.GetInfoResponse}
 */
proto.lnrpc.GetInfoResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 14:
      var value = /** @type {string} */ (reader.readString());
      msg.setVersion(value);
      break;
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setIdentityPubkey(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAlias(value);
      break;
    case 17:
      var value = /** @type {string} */ (reader.readString());
      msg.setColor(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumPendingChannels(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumActiveChannels(value);
      break;
    case 15:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumInactiveChannels(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumPeers(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBlockHeight(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setBlockHash(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBestHeaderTimestamp(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSyncedToChain(value);
      break;
    case 18:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSyncedToGraph(value);
      break;
    case 10:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setTestnet(value);
      break;
    case 16:
      var value = new proto.lnrpc.Chain;
      reader.readMessage(value,proto.lnrpc.Chain.deserializeBinaryFromReader);
      msg.addChains(value);
      break;
    case 12:
      var value = /** @type {string} */ (reader.readString());
      msg.addUris(value);
      break;
    case 19:
      var value = msg.getFeaturesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint32, jspb.BinaryReader.prototype.readMessage, proto.lnrpc.Feature.deserializeBinaryFromReader);
         });
      break;
    case 901:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setServerActive(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.GetInfoResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.GetInfoResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.GetInfoResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GetInfoResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVersion();
  if (f.length > 0) {
    writer.writeString(
      14,
      f
    );
  }
  f = message.getIdentityPubkey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAlias();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getColor();
  if (f.length > 0) {
    writer.writeString(
      17,
      f
    );
  }
  f = message.getNumPendingChannels();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getNumActiveChannels();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getNumInactiveChannels();
  if (f !== 0) {
    writer.writeUint32(
      15,
      f
    );
  }
  f = message.getNumPeers();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getBlockHeight();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getBlockHash();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getBestHeaderTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      13,
      f
    );
  }
  f = message.getSyncedToChain();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getSyncedToGraph();
  if (f) {
    writer.writeBool(
      18,
      f
    );
  }
  f = message.getTestnet();
  if (f) {
    writer.writeBool(
      10,
      f
    );
  }
  f = message.getChainsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      16,
      f,
      proto.lnrpc.Chain.serializeBinaryToWriter
    );
  }
  f = message.getUrisList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      12,
      f
    );
  }
  f = message.getFeaturesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(19, writer, jspb.BinaryWriter.prototype.writeUint32, jspb.BinaryWriter.prototype.writeMessage, proto.lnrpc.Feature.serializeBinaryToWriter);
  }
  f = message.getServerActive();
  if (f) {
    writer.writeBool(
      901,
      f
    );
  }
};


/**
 * optional string version = 14;
 * @return {string}
 */
proto.lnrpc.GetInfoResponse.prototype.getVersion = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 14, ""));
};


/** @param {string} value */
proto.lnrpc.GetInfoResponse.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 14, value);
};


/**
 * optional string identity_pubkey = 1;
 * @return {string}
 */
proto.lnrpc.GetInfoResponse.prototype.getIdentityPubkey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.GetInfoResponse.prototype.setIdentityPubkey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string alias = 2;
 * @return {string}
 */
proto.lnrpc.GetInfoResponse.prototype.getAlias = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.GetInfoResponse.prototype.setAlias = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string color = 17;
 * @return {string}
 */
proto.lnrpc.GetInfoResponse.prototype.getColor = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 17, ""));
};


/** @param {string} value */
proto.lnrpc.GetInfoResponse.prototype.setColor = function(value) {
  jspb.Message.setField(this, 17, value);
};


/**
 * optional uint32 num_pending_channels = 3;
 * @return {number}
 */
proto.lnrpc.GetInfoResponse.prototype.getNumPendingChannels = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.GetInfoResponse.prototype.setNumPendingChannels = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 num_active_channels = 4;
 * @return {number}
 */
proto.lnrpc.GetInfoResponse.prototype.getNumActiveChannels = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.GetInfoResponse.prototype.setNumActiveChannels = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 num_inactive_channels = 15;
 * @return {number}
 */
proto.lnrpc.GetInfoResponse.prototype.getNumInactiveChannels = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 15, 0));
};


/** @param {number} value */
proto.lnrpc.GetInfoResponse.prototype.setNumInactiveChannels = function(value) {
  jspb.Message.setField(this, 15, value);
};


/**
 * optional uint32 num_peers = 5;
 * @return {number}
 */
proto.lnrpc.GetInfoResponse.prototype.getNumPeers = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.GetInfoResponse.prototype.setNumPeers = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 block_height = 6;
 * @return {number}
 */
proto.lnrpc.GetInfoResponse.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.GetInfoResponse.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional string block_hash = 8;
 * @return {string}
 */
proto.lnrpc.GetInfoResponse.prototype.getBlockHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.lnrpc.GetInfoResponse.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional int64 best_header_timestamp = 13;
 * @return {number}
 */
proto.lnrpc.GetInfoResponse.prototype.getBestHeaderTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.lnrpc.GetInfoResponse.prototype.setBestHeaderTimestamp = function(value) {
  jspb.Message.setField(this, 13, value);
};


/**
 * optional bool synced_to_chain = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.GetInfoResponse.prototype.getSyncedToChain = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.lnrpc.GetInfoResponse.prototype.setSyncedToChain = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional bool synced_to_graph = 18;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.GetInfoResponse.prototype.getSyncedToGraph = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 18, false));
};


/** @param {boolean} value */
proto.lnrpc.GetInfoResponse.prototype.setSyncedToGraph = function(value) {
  jspb.Message.setField(this, 18, value);
};


/**
 * optional bool testnet = 10;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.GetInfoResponse.prototype.getTestnet = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 10, false));
};


/** @param {boolean} value */
proto.lnrpc.GetInfoResponse.prototype.setTestnet = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * repeated Chain chains = 16;
 * @return {!Array.<!proto.lnrpc.Chain>}
 */
proto.lnrpc.GetInfoResponse.prototype.getChainsList = function() {
  return /** @type{!Array.<!proto.lnrpc.Chain>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Chain, 16));
};


/** @param {!Array.<!proto.lnrpc.Chain>} value */
proto.lnrpc.GetInfoResponse.prototype.setChainsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 16, value);
};


/**
 * @param {!proto.lnrpc.Chain=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Chain}
 */
proto.lnrpc.GetInfoResponse.prototype.addChains = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 16, opt_value, proto.lnrpc.Chain, opt_index);
};


proto.lnrpc.GetInfoResponse.prototype.clearChainsList = function() {
  this.setChainsList([]);
};


/**
 * repeated string uris = 12;
 * @return {!Array.<string>}
 */
proto.lnrpc.GetInfoResponse.prototype.getUrisList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 12));
};


/** @param {!Array.<string>} value */
proto.lnrpc.GetInfoResponse.prototype.setUrisList = function(value) {
  jspb.Message.setField(this, 12, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.lnrpc.GetInfoResponse.prototype.addUris = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 12, value, opt_index);
};


proto.lnrpc.GetInfoResponse.prototype.clearUrisList = function() {
  this.setUrisList([]);
};


/**
 * map<uint32, Feature> features = 19;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!proto.lnrpc.Feature>}
 */
proto.lnrpc.GetInfoResponse.prototype.getFeaturesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!proto.lnrpc.Feature>} */ (
      jspb.Message.getMapField(this, 19, opt_noLazyCreate,
      proto.lnrpc.Feature));
};


proto.lnrpc.GetInfoResponse.prototype.clearFeaturesMap = function() {
  this.getFeaturesMap().clear();
};


/**
 * optional bool server_active = 901;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.GetInfoResponse.prototype.getServerActive = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 901, false));
};


/** @param {boolean} value */
proto.lnrpc.GetInfoResponse.prototype.setServerActive = function(value) {
  jspb.Message.setField(this, 901, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Chain = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.Chain, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Chain.displayName = 'proto.lnrpc.Chain';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Chain.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Chain.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Chain} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Chain.toObject = function(includeInstance, msg) {
  var f, obj = {
    chain: jspb.Message.getFieldWithDefault(msg, 1, ""),
    network: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Chain}
 */
proto.lnrpc.Chain.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Chain;
  return proto.lnrpc.Chain.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Chain} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Chain}
 */
proto.lnrpc.Chain.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setChain(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setNetwork(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Chain.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Chain.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Chain} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Chain.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChain();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getNetwork();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string chain = 1;
 * @return {string}
 */
proto.lnrpc.Chain.prototype.getChain = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.Chain.prototype.setChain = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string network = 2;
 * @return {string}
 */
proto.lnrpc.Chain.prototype.getNetwork = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.Chain.prototype.setNetwork = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ConfirmationUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ConfirmationUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ConfirmationUpdate.displayName = 'proto.lnrpc.ConfirmationUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ConfirmationUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ConfirmationUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ConfirmationUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ConfirmationUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    blockSha: msg.getBlockSha_asB64(),
    blockHeight: jspb.Message.getFieldWithDefault(msg, 2, 0),
    numConfsLeft: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ConfirmationUpdate}
 */
proto.lnrpc.ConfirmationUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ConfirmationUpdate;
  return proto.lnrpc.ConfirmationUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ConfirmationUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ConfirmationUpdate}
 */
proto.lnrpc.ConfirmationUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockSha(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlockHeight(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumConfsLeft(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ConfirmationUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ConfirmationUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ConfirmationUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ConfirmationUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlockSha_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getNumConfsLeft();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional bytes block_sha = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ConfirmationUpdate.prototype.getBlockSha = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes block_sha = 1;
 * This is a type-conversion wrapper around `getBlockSha()`
 * @return {string}
 */
proto.lnrpc.ConfirmationUpdate.prototype.getBlockSha_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockSha()));
};


/**
 * optional bytes block_sha = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockSha()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ConfirmationUpdate.prototype.getBlockSha_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockSha()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ConfirmationUpdate.prototype.setBlockSha = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 block_height = 2;
 * @return {number}
 */
proto.lnrpc.ConfirmationUpdate.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.ConfirmationUpdate.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 num_confs_left = 3;
 * @return {number}
 */
proto.lnrpc.ConfirmationUpdate.prototype.getNumConfsLeft = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ConfirmationUpdate.prototype.setNumConfsLeft = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelOpenUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelOpenUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelOpenUpdate.displayName = 'proto.lnrpc.ChannelOpenUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelOpenUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelOpenUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelOpenUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelOpenUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelPoint: (f = msg.getChannelPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelOpenUpdate}
 */
proto.lnrpc.ChannelOpenUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelOpenUpdate;
  return proto.lnrpc.ChannelOpenUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelOpenUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelOpenUpdate}
 */
proto.lnrpc.ChannelOpenUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChannelPoint(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelOpenUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelOpenUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelOpenUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelOpenUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelPoint();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChannelPoint channel_point = 1;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ChannelOpenUpdate.prototype.getChannelPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 1));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.ChannelOpenUpdate.prototype.setChannelPoint = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.ChannelOpenUpdate.prototype.clearChannelPoint = function() {
  this.setChannelPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelOpenUpdate.prototype.hasChannelPoint = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelCloseUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelCloseUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelCloseUpdate.displayName = 'proto.lnrpc.ChannelCloseUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelCloseUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelCloseUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelCloseUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelCloseUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    closingTxid: msg.getClosingTxid_asB64(),
    success: jspb.Message.getFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelCloseUpdate}
 */
proto.lnrpc.ChannelCloseUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelCloseUpdate;
  return proto.lnrpc.ChannelCloseUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelCloseUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelCloseUpdate}
 */
proto.lnrpc.ChannelCloseUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setClosingTxid(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSuccess(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelCloseUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelCloseUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelCloseUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelCloseUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClosingTxid_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getSuccess();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional bytes closing_txid = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChannelCloseUpdate.prototype.getClosingTxid = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes closing_txid = 1;
 * This is a type-conversion wrapper around `getClosingTxid()`
 * @return {string}
 */
proto.lnrpc.ChannelCloseUpdate.prototype.getClosingTxid_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getClosingTxid()));
};


/**
 * optional bytes closing_txid = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getClosingTxid()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelCloseUpdate.prototype.getClosingTxid_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getClosingTxid()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChannelCloseUpdate.prototype.setClosingTxid = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool success = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ChannelCloseUpdate.prototype.getSuccess = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.lnrpc.ChannelCloseUpdate.prototype.setSuccess = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.CloseChannelRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.CloseChannelRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.CloseChannelRequest.displayName = 'proto.lnrpc.CloseChannelRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.CloseChannelRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.CloseChannelRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.CloseChannelRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.CloseChannelRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelPoint: (f = msg.getChannelPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f),
    force: jspb.Message.getFieldWithDefault(msg, 2, false),
    targetConf: jspb.Message.getFieldWithDefault(msg, 3, 0),
    atomsPerByte: jspb.Message.getFieldWithDefault(msg, 4, 0),
    deliveryAddress: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.CloseChannelRequest}
 */
proto.lnrpc.CloseChannelRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.CloseChannelRequest;
  return proto.lnrpc.CloseChannelRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.CloseChannelRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.CloseChannelRequest}
 */
proto.lnrpc.CloseChannelRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChannelPoint(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setForce(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTargetConf(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAtomsPerByte(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setDeliveryAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.CloseChannelRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.CloseChannelRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.CloseChannelRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.CloseChannelRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelPoint();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
  f = message.getForce();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getTargetConf();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getAtomsPerByte();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getDeliveryAddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional ChannelPoint channel_point = 1;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.CloseChannelRequest.prototype.getChannelPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 1));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.CloseChannelRequest.prototype.setChannelPoint = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.CloseChannelRequest.prototype.clearChannelPoint = function() {
  this.setChannelPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.CloseChannelRequest.prototype.hasChannelPoint = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool force = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.CloseChannelRequest.prototype.getForce = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.lnrpc.CloseChannelRequest.prototype.setForce = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 target_conf = 3;
 * @return {number}
 */
proto.lnrpc.CloseChannelRequest.prototype.getTargetConf = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.CloseChannelRequest.prototype.setTargetConf = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 atoms_per_byte = 4;
 * @return {number}
 */
proto.lnrpc.CloseChannelRequest.prototype.getAtomsPerByte = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.CloseChannelRequest.prototype.setAtomsPerByte = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string delivery_address = 5;
 * @return {string}
 */
proto.lnrpc.CloseChannelRequest.prototype.getDeliveryAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.lnrpc.CloseChannelRequest.prototype.setDeliveryAddress = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.CloseStatusUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.CloseStatusUpdate.oneofGroups_);
};
goog.inherits(proto.lnrpc.CloseStatusUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.CloseStatusUpdate.displayName = 'proto.lnrpc.CloseStatusUpdate';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.CloseStatusUpdate.oneofGroups_ = [[1,3]];

/**
 * @enum {number}
 */
proto.lnrpc.CloseStatusUpdate.UpdateCase = {
  UPDATE_NOT_SET: 0,
  CLOSE_PENDING: 1,
  CHAN_CLOSE: 3
};

/**
 * @return {proto.lnrpc.CloseStatusUpdate.UpdateCase}
 */
proto.lnrpc.CloseStatusUpdate.prototype.getUpdateCase = function() {
  return /** @type {proto.lnrpc.CloseStatusUpdate.UpdateCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.CloseStatusUpdate.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.CloseStatusUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.CloseStatusUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.CloseStatusUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.CloseStatusUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    closePending: (f = msg.getClosePending()) && proto.lnrpc.PendingUpdate.toObject(includeInstance, f),
    chanClose: (f = msg.getChanClose()) && proto.lnrpc.ChannelCloseUpdate.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.CloseStatusUpdate}
 */
proto.lnrpc.CloseStatusUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.CloseStatusUpdate;
  return proto.lnrpc.CloseStatusUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.CloseStatusUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.CloseStatusUpdate}
 */
proto.lnrpc.CloseStatusUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.PendingUpdate;
      reader.readMessage(value,proto.lnrpc.PendingUpdate.deserializeBinaryFromReader);
      msg.setClosePending(value);
      break;
    case 3:
      var value = new proto.lnrpc.ChannelCloseUpdate;
      reader.readMessage(value,proto.lnrpc.ChannelCloseUpdate.deserializeBinaryFromReader);
      msg.setChanClose(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.CloseStatusUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.CloseStatusUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.CloseStatusUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.CloseStatusUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getClosePending();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.PendingUpdate.serializeBinaryToWriter
    );
  }
  f = message.getChanClose();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.lnrpc.ChannelCloseUpdate.serializeBinaryToWriter
    );
  }
};


/**
 * optional PendingUpdate close_pending = 1;
 * @return {?proto.lnrpc.PendingUpdate}
 */
proto.lnrpc.CloseStatusUpdate.prototype.getClosePending = function() {
  return /** @type{?proto.lnrpc.PendingUpdate} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.PendingUpdate, 1));
};


/** @param {?proto.lnrpc.PendingUpdate|undefined} value */
proto.lnrpc.CloseStatusUpdate.prototype.setClosePending = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.lnrpc.CloseStatusUpdate.oneofGroups_[0], value);
};


proto.lnrpc.CloseStatusUpdate.prototype.clearClosePending = function() {
  this.setClosePending(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.CloseStatusUpdate.prototype.hasClosePending = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ChannelCloseUpdate chan_close = 3;
 * @return {?proto.lnrpc.ChannelCloseUpdate}
 */
proto.lnrpc.CloseStatusUpdate.prototype.getChanClose = function() {
  return /** @type{?proto.lnrpc.ChannelCloseUpdate} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelCloseUpdate, 3));
};


/** @param {?proto.lnrpc.ChannelCloseUpdate|undefined} value */
proto.lnrpc.CloseStatusUpdate.prototype.setChanClose = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.lnrpc.CloseStatusUpdate.oneofGroups_[0], value);
};


proto.lnrpc.CloseStatusUpdate.prototype.clearChanClose = function() {
  this.setChanClose(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.CloseStatusUpdate.prototype.hasChanClose = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PendingUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingUpdate.displayName = 'proto.lnrpc.PendingUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    txid: msg.getTxid_asB64(),
    outputIndex: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingUpdate}
 */
proto.lnrpc.PendingUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingUpdate;
  return proto.lnrpc.PendingUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingUpdate}
 */
proto.lnrpc.PendingUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTxid(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTxid_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional bytes txid = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.PendingUpdate.prototype.getTxid = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes txid = 1;
 * This is a type-conversion wrapper around `getTxid()`
 * @return {string}
 */
proto.lnrpc.PendingUpdate.prototype.getTxid_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTxid()));
};


/**
 * optional bytes txid = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTxid()`
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingUpdate.prototype.getTxid_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTxid()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.PendingUpdate.prototype.setTxid = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.lnrpc.PendingUpdate.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.PendingUpdate.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.OpenChannelRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.OpenChannelRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.OpenChannelRequest.displayName = 'proto.lnrpc.OpenChannelRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.OpenChannelRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.OpenChannelRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.OpenChannelRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.OpenChannelRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodePubkey: msg.getNodePubkey_asB64(),
    nodePubkeyString: jspb.Message.getFieldWithDefault(msg, 3, ""),
    localFundingAmount: jspb.Message.getFieldWithDefault(msg, 4, 0),
    pushAtoms: jspb.Message.getFieldWithDefault(msg, 5, 0),
    targetConf: jspb.Message.getFieldWithDefault(msg, 6, 0),
    atomsPerByte: jspb.Message.getFieldWithDefault(msg, 7, 0),
    pb_private: jspb.Message.getFieldWithDefault(msg, 8, false),
    minHtlcMAtoms: jspb.Message.getFieldWithDefault(msg, 9, 0),
    remoteCsvDelay: jspb.Message.getFieldWithDefault(msg, 10, 0),
    minConfs: jspb.Message.getFieldWithDefault(msg, 11, 0),
    spendUnconfirmed: jspb.Message.getFieldWithDefault(msg, 12, false),
    closeAddress: jspb.Message.getFieldWithDefault(msg, 13, ""),
    fundingShim: (f = msg.getFundingShim()) && proto.lnrpc.FundingShim.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.OpenChannelRequest}
 */
proto.lnrpc.OpenChannelRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.OpenChannelRequest;
  return proto.lnrpc.OpenChannelRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.OpenChannelRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.OpenChannelRequest}
 */
proto.lnrpc.OpenChannelRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNodePubkey(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setNodePubkeyString(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLocalFundingAmount(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setPushAtoms(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTargetConf(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAtomsPerByte(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPrivate(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMinHtlcMAtoms(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRemoteCsvDelay(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinConfs(value);
      break;
    case 12:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSpendUnconfirmed(value);
      break;
    case 13:
      var value = /** @type {string} */ (reader.readString());
      msg.setCloseAddress(value);
      break;
    case 14:
      var value = new proto.lnrpc.FundingShim;
      reader.readMessage(value,proto.lnrpc.FundingShim.deserializeBinaryFromReader);
      msg.setFundingShim(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.OpenChannelRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.OpenChannelRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.OpenChannelRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.OpenChannelRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodePubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getNodePubkeyString();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getLocalFundingAmount();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getPushAtoms();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getTargetConf();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = message.getAtomsPerByte();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getPrivate();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
  f = message.getMinHtlcMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
  f = message.getRemoteCsvDelay();
  if (f !== 0) {
    writer.writeUint32(
      10,
      f
    );
  }
  f = message.getMinConfs();
  if (f !== 0) {
    writer.writeInt32(
      11,
      f
    );
  }
  f = message.getSpendUnconfirmed();
  if (f) {
    writer.writeBool(
      12,
      f
    );
  }
  f = message.getCloseAddress();
  if (f.length > 0) {
    writer.writeString(
      13,
      f
    );
  }
  f = message.getFundingShim();
  if (f != null) {
    writer.writeMessage(
      14,
      f,
      proto.lnrpc.FundingShim.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes node_pubkey = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.OpenChannelRequest.prototype.getNodePubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes node_pubkey = 2;
 * This is a type-conversion wrapper around `getNodePubkey()`
 * @return {string}
 */
proto.lnrpc.OpenChannelRequest.prototype.getNodePubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNodePubkey()));
};


/**
 * optional bytes node_pubkey = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNodePubkey()`
 * @return {!Uint8Array}
 */
proto.lnrpc.OpenChannelRequest.prototype.getNodePubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNodePubkey()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.OpenChannelRequest.prototype.setNodePubkey = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string node_pubkey_string = 3;
 * @return {string}
 */
proto.lnrpc.OpenChannelRequest.prototype.getNodePubkeyString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.lnrpc.OpenChannelRequest.prototype.setNodePubkeyString = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 local_funding_amount = 4;
 * @return {number}
 */
proto.lnrpc.OpenChannelRequest.prototype.getLocalFundingAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.OpenChannelRequest.prototype.setLocalFundingAmount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 push_atoms = 5;
 * @return {number}
 */
proto.lnrpc.OpenChannelRequest.prototype.getPushAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.OpenChannelRequest.prototype.setPushAtoms = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int32 target_conf = 6;
 * @return {number}
 */
proto.lnrpc.OpenChannelRequest.prototype.getTargetConf = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.OpenChannelRequest.prototype.setTargetConf = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 atoms_per_byte = 7;
 * @return {number}
 */
proto.lnrpc.OpenChannelRequest.prototype.getAtomsPerByte = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.OpenChannelRequest.prototype.setAtomsPerByte = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional bool private = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.OpenChannelRequest.prototype.getPrivate = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.lnrpc.OpenChannelRequest.prototype.setPrivate = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional int64 min_htlc_m_atoms = 9;
 * @return {number}
 */
proto.lnrpc.OpenChannelRequest.prototype.getMinHtlcMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.lnrpc.OpenChannelRequest.prototype.setMinHtlcMAtoms = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional uint32 remote_csv_delay = 10;
 * @return {number}
 */
proto.lnrpc.OpenChannelRequest.prototype.getRemoteCsvDelay = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.lnrpc.OpenChannelRequest.prototype.setRemoteCsvDelay = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int32 min_confs = 11;
 * @return {number}
 */
proto.lnrpc.OpenChannelRequest.prototype.getMinConfs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.lnrpc.OpenChannelRequest.prototype.setMinConfs = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * optional bool spend_unconfirmed = 12;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.OpenChannelRequest.prototype.getSpendUnconfirmed = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 12, false));
};


/** @param {boolean} value */
proto.lnrpc.OpenChannelRequest.prototype.setSpendUnconfirmed = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * optional string close_address = 13;
 * @return {string}
 */
proto.lnrpc.OpenChannelRequest.prototype.getCloseAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 13, ""));
};


/** @param {string} value */
proto.lnrpc.OpenChannelRequest.prototype.setCloseAddress = function(value) {
  jspb.Message.setField(this, 13, value);
};


/**
 * optional FundingShim funding_shim = 14;
 * @return {?proto.lnrpc.FundingShim}
 */
proto.lnrpc.OpenChannelRequest.prototype.getFundingShim = function() {
  return /** @type{?proto.lnrpc.FundingShim} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.FundingShim, 14));
};


/** @param {?proto.lnrpc.FundingShim|undefined} value */
proto.lnrpc.OpenChannelRequest.prototype.setFundingShim = function(value) {
  jspb.Message.setWrapperField(this, 14, value);
};


proto.lnrpc.OpenChannelRequest.prototype.clearFundingShim = function() {
  this.setFundingShim(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.OpenChannelRequest.prototype.hasFundingShim = function() {
  return jspb.Message.getField(this, 14) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.OpenStatusUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.OpenStatusUpdate.oneofGroups_);
};
goog.inherits(proto.lnrpc.OpenStatusUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.OpenStatusUpdate.displayName = 'proto.lnrpc.OpenStatusUpdate';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.OpenStatusUpdate.oneofGroups_ = [[1,3]];

/**
 * @enum {number}
 */
proto.lnrpc.OpenStatusUpdate.UpdateCase = {
  UPDATE_NOT_SET: 0,
  CHAN_PENDING: 1,
  CHAN_OPEN: 3
};

/**
 * @return {proto.lnrpc.OpenStatusUpdate.UpdateCase}
 */
proto.lnrpc.OpenStatusUpdate.prototype.getUpdateCase = function() {
  return /** @type {proto.lnrpc.OpenStatusUpdate.UpdateCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.OpenStatusUpdate.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.OpenStatusUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.OpenStatusUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.OpenStatusUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.OpenStatusUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanPending: (f = msg.getChanPending()) && proto.lnrpc.PendingUpdate.toObject(includeInstance, f),
    chanOpen: (f = msg.getChanOpen()) && proto.lnrpc.ChannelOpenUpdate.toObject(includeInstance, f),
    pendingChanId: msg.getPendingChanId_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.OpenStatusUpdate}
 */
proto.lnrpc.OpenStatusUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.OpenStatusUpdate;
  return proto.lnrpc.OpenStatusUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.OpenStatusUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.OpenStatusUpdate}
 */
proto.lnrpc.OpenStatusUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.PendingUpdate;
      reader.readMessage(value,proto.lnrpc.PendingUpdate.deserializeBinaryFromReader);
      msg.setChanPending(value);
      break;
    case 3:
      var value = new proto.lnrpc.ChannelOpenUpdate;
      reader.readMessage(value,proto.lnrpc.ChannelOpenUpdate.deserializeBinaryFromReader);
      msg.setChanOpen(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPendingChanId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.OpenStatusUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.OpenStatusUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.OpenStatusUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.OpenStatusUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanPending();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.PendingUpdate.serializeBinaryToWriter
    );
  }
  f = message.getChanOpen();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.lnrpc.ChannelOpenUpdate.serializeBinaryToWriter
    );
  }
  f = message.getPendingChanId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional PendingUpdate chan_pending = 1;
 * @return {?proto.lnrpc.PendingUpdate}
 */
proto.lnrpc.OpenStatusUpdate.prototype.getChanPending = function() {
  return /** @type{?proto.lnrpc.PendingUpdate} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.PendingUpdate, 1));
};


/** @param {?proto.lnrpc.PendingUpdate|undefined} value */
proto.lnrpc.OpenStatusUpdate.prototype.setChanPending = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.lnrpc.OpenStatusUpdate.oneofGroups_[0], value);
};


proto.lnrpc.OpenStatusUpdate.prototype.clearChanPending = function() {
  this.setChanPending(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.OpenStatusUpdate.prototype.hasChanPending = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ChannelOpenUpdate chan_open = 3;
 * @return {?proto.lnrpc.ChannelOpenUpdate}
 */
proto.lnrpc.OpenStatusUpdate.prototype.getChanOpen = function() {
  return /** @type{?proto.lnrpc.ChannelOpenUpdate} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelOpenUpdate, 3));
};


/** @param {?proto.lnrpc.ChannelOpenUpdate|undefined} value */
proto.lnrpc.OpenStatusUpdate.prototype.setChanOpen = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.lnrpc.OpenStatusUpdate.oneofGroups_[0], value);
};


proto.lnrpc.OpenStatusUpdate.prototype.clearChanOpen = function() {
  this.setChanOpen(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.OpenStatusUpdate.prototype.hasChanOpen = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bytes pending_chan_id = 4;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.OpenStatusUpdate.prototype.getPendingChanId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes pending_chan_id = 4;
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {string}
 */
proto.lnrpc.OpenStatusUpdate.prototype.getPendingChanId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPendingChanId()));
};


/**
 * optional bytes pending_chan_id = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {!Uint8Array}
 */
proto.lnrpc.OpenStatusUpdate.prototype.getPendingChanId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPendingChanId()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.OpenStatusUpdate.prototype.setPendingChanId = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.KeyLocator = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.KeyLocator, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.KeyLocator.displayName = 'proto.lnrpc.KeyLocator';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.KeyLocator.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.KeyLocator.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.KeyLocator} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.KeyLocator.toObject = function(includeInstance, msg) {
  var f, obj = {
    keyFamily: jspb.Message.getFieldWithDefault(msg, 1, 0),
    keyIndex: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.KeyLocator}
 */
proto.lnrpc.KeyLocator.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.KeyLocator;
  return proto.lnrpc.KeyLocator.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.KeyLocator} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.KeyLocator}
 */
proto.lnrpc.KeyLocator.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setKeyFamily(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setKeyIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.KeyLocator.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.KeyLocator.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.KeyLocator} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.KeyLocator.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKeyFamily();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
  f = message.getKeyIndex();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int32 key_family = 1;
 * @return {number}
 */
proto.lnrpc.KeyLocator.prototype.getKeyFamily = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.KeyLocator.prototype.setKeyFamily = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 key_index = 2;
 * @return {number}
 */
proto.lnrpc.KeyLocator.prototype.getKeyIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.KeyLocator.prototype.setKeyIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.KeyDescriptor = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.KeyDescriptor, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.KeyDescriptor.displayName = 'proto.lnrpc.KeyDescriptor';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.KeyDescriptor.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.KeyDescriptor.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.KeyDescriptor} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.KeyDescriptor.toObject = function(includeInstance, msg) {
  var f, obj = {
    rawKeyBytes: msg.getRawKeyBytes_asB64(),
    keyLoc: (f = msg.getKeyLoc()) && proto.lnrpc.KeyLocator.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.KeyDescriptor}
 */
proto.lnrpc.KeyDescriptor.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.KeyDescriptor;
  return proto.lnrpc.KeyDescriptor.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.KeyDescriptor} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.KeyDescriptor}
 */
proto.lnrpc.KeyDescriptor.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRawKeyBytes(value);
      break;
    case 2:
      var value = new proto.lnrpc.KeyLocator;
      reader.readMessage(value,proto.lnrpc.KeyLocator.deserializeBinaryFromReader);
      msg.setKeyLoc(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.KeyDescriptor.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.KeyDescriptor.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.KeyDescriptor} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.KeyDescriptor.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRawKeyBytes_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getKeyLoc();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.lnrpc.KeyLocator.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes raw_key_bytes = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.KeyDescriptor.prototype.getRawKeyBytes = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes raw_key_bytes = 1;
 * This is a type-conversion wrapper around `getRawKeyBytes()`
 * @return {string}
 */
proto.lnrpc.KeyDescriptor.prototype.getRawKeyBytes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRawKeyBytes()));
};


/**
 * optional bytes raw_key_bytes = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRawKeyBytes()`
 * @return {!Uint8Array}
 */
proto.lnrpc.KeyDescriptor.prototype.getRawKeyBytes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRawKeyBytes()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.KeyDescriptor.prototype.setRawKeyBytes = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional KeyLocator key_loc = 2;
 * @return {?proto.lnrpc.KeyLocator}
 */
proto.lnrpc.KeyDescriptor.prototype.getKeyLoc = function() {
  return /** @type{?proto.lnrpc.KeyLocator} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.KeyLocator, 2));
};


/** @param {?proto.lnrpc.KeyLocator|undefined} value */
proto.lnrpc.KeyDescriptor.prototype.setKeyLoc = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.lnrpc.KeyDescriptor.prototype.clearKeyLoc = function() {
  this.setKeyLoc(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.KeyDescriptor.prototype.hasKeyLoc = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChanPointShim = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChanPointShim, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChanPointShim.displayName = 'proto.lnrpc.ChanPointShim';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChanPointShim.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChanPointShim.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChanPointShim} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChanPointShim.toObject = function(includeInstance, msg) {
  var f, obj = {
    amt: jspb.Message.getFieldWithDefault(msg, 1, 0),
    chanPoint: (f = msg.getChanPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f),
    localKey: (f = msg.getLocalKey()) && proto.lnrpc.KeyDescriptor.toObject(includeInstance, f),
    remoteKey: msg.getRemoteKey_asB64(),
    pendingChanId: msg.getPendingChanId_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChanPointShim}
 */
proto.lnrpc.ChanPointShim.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChanPointShim;
  return proto.lnrpc.ChanPointShim.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChanPointShim} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChanPointShim}
 */
proto.lnrpc.ChanPointShim.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmt(value);
      break;
    case 2:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChanPoint(value);
      break;
    case 3:
      var value = new proto.lnrpc.KeyDescriptor;
      reader.readMessage(value,proto.lnrpc.KeyDescriptor.deserializeBinaryFromReader);
      msg.setLocalKey(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRemoteKey(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPendingChanId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChanPointShim.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChanPointShim.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChanPointShim} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChanPointShim.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmt();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getChanPoint();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
  f = message.getLocalKey();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.lnrpc.KeyDescriptor.serializeBinaryToWriter
    );
  }
  f = message.getRemoteKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getPendingChanId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
};


/**
 * optional int64 amt = 1;
 * @return {number}
 */
proto.lnrpc.ChanPointShim.prototype.getAmt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.ChanPointShim.prototype.setAmt = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional ChannelPoint chan_point = 2;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ChanPointShim.prototype.getChanPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 2));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.ChanPointShim.prototype.setChanPoint = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.lnrpc.ChanPointShim.prototype.clearChanPoint = function() {
  this.setChanPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChanPointShim.prototype.hasChanPoint = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional KeyDescriptor local_key = 3;
 * @return {?proto.lnrpc.KeyDescriptor}
 */
proto.lnrpc.ChanPointShim.prototype.getLocalKey = function() {
  return /** @type{?proto.lnrpc.KeyDescriptor} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.KeyDescriptor, 3));
};


/** @param {?proto.lnrpc.KeyDescriptor|undefined} value */
proto.lnrpc.ChanPointShim.prototype.setLocalKey = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.lnrpc.ChanPointShim.prototype.clearLocalKey = function() {
  this.setLocalKey(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChanPointShim.prototype.hasLocalKey = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bytes remote_key = 4;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChanPointShim.prototype.getRemoteKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes remote_key = 4;
 * This is a type-conversion wrapper around `getRemoteKey()`
 * @return {string}
 */
proto.lnrpc.ChanPointShim.prototype.getRemoteKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRemoteKey()));
};


/**
 * optional bytes remote_key = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRemoteKey()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChanPointShim.prototype.getRemoteKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRemoteKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChanPointShim.prototype.setRemoteKey = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bytes pending_chan_id = 5;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChanPointShim.prototype.getPendingChanId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes pending_chan_id = 5;
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {string}
 */
proto.lnrpc.ChanPointShim.prototype.getPendingChanId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPendingChanId()));
};


/**
 * optional bytes pending_chan_id = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChanPointShim.prototype.getPendingChanId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPendingChanId()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChanPointShim.prototype.setPendingChanId = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.FundingShim = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.FundingShim.oneofGroups_);
};
goog.inherits(proto.lnrpc.FundingShim, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.FundingShim.displayName = 'proto.lnrpc.FundingShim';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.FundingShim.oneofGroups_ = [[1]];

/**
 * @enum {number}
 */
proto.lnrpc.FundingShim.ShimCase = {
  SHIM_NOT_SET: 0,
  CHAN_POINT_SHIM: 1
};

/**
 * @return {proto.lnrpc.FundingShim.ShimCase}
 */
proto.lnrpc.FundingShim.prototype.getShimCase = function() {
  return /** @type {proto.lnrpc.FundingShim.ShimCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.FundingShim.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.FundingShim.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.FundingShim.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.FundingShim} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FundingShim.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanPointShim: (f = msg.getChanPointShim()) && proto.lnrpc.ChanPointShim.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.FundingShim}
 */
proto.lnrpc.FundingShim.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.FundingShim;
  return proto.lnrpc.FundingShim.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.FundingShim} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.FundingShim}
 */
proto.lnrpc.FundingShim.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChanPointShim;
      reader.readMessage(value,proto.lnrpc.ChanPointShim.deserializeBinaryFromReader);
      msg.setChanPointShim(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.FundingShim.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.FundingShim.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.FundingShim} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FundingShim.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanPointShim();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.ChanPointShim.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChanPointShim chan_point_shim = 1;
 * @return {?proto.lnrpc.ChanPointShim}
 */
proto.lnrpc.FundingShim.prototype.getChanPointShim = function() {
  return /** @type{?proto.lnrpc.ChanPointShim} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChanPointShim, 1));
};


/** @param {?proto.lnrpc.ChanPointShim|undefined} value */
proto.lnrpc.FundingShim.prototype.setChanPointShim = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.lnrpc.FundingShim.oneofGroups_[0], value);
};


proto.lnrpc.FundingShim.prototype.clearChanPointShim = function() {
  this.setChanPointShim(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.FundingShim.prototype.hasChanPointShim = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.FundingShimCancel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.FundingShimCancel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.FundingShimCancel.displayName = 'proto.lnrpc.FundingShimCancel';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.FundingShimCancel.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.FundingShimCancel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.FundingShimCancel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FundingShimCancel.toObject = function(includeInstance, msg) {
  var f, obj = {
    pendingChanId: msg.getPendingChanId_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.FundingShimCancel}
 */
proto.lnrpc.FundingShimCancel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.FundingShimCancel;
  return proto.lnrpc.FundingShimCancel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.FundingShimCancel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.FundingShimCancel}
 */
proto.lnrpc.FundingShimCancel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPendingChanId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.FundingShimCancel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.FundingShimCancel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.FundingShimCancel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FundingShimCancel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPendingChanId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes pending_chan_id = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.FundingShimCancel.prototype.getPendingChanId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes pending_chan_id = 1;
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {string}
 */
proto.lnrpc.FundingShimCancel.prototype.getPendingChanId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPendingChanId()));
};


/**
 * optional bytes pending_chan_id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPendingChanId()`
 * @return {!Uint8Array}
 */
proto.lnrpc.FundingShimCancel.prototype.getPendingChanId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPendingChanId()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.FundingShimCancel.prototype.setPendingChanId = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.FundingTransitionMsg = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.FundingTransitionMsg.oneofGroups_);
};
goog.inherits(proto.lnrpc.FundingTransitionMsg, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.FundingTransitionMsg.displayName = 'proto.lnrpc.FundingTransitionMsg';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.FundingTransitionMsg.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.lnrpc.FundingTransitionMsg.TriggerCase = {
  TRIGGER_NOT_SET: 0,
  SHIM_REGISTER: 1,
  SHIM_CANCEL: 2
};

/**
 * @return {proto.lnrpc.FundingTransitionMsg.TriggerCase}
 */
proto.lnrpc.FundingTransitionMsg.prototype.getTriggerCase = function() {
  return /** @type {proto.lnrpc.FundingTransitionMsg.TriggerCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.FundingTransitionMsg.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.FundingTransitionMsg.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.FundingTransitionMsg.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.FundingTransitionMsg} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FundingTransitionMsg.toObject = function(includeInstance, msg) {
  var f, obj = {
    shimRegister: (f = msg.getShimRegister()) && proto.lnrpc.FundingShim.toObject(includeInstance, f),
    shimCancel: (f = msg.getShimCancel()) && proto.lnrpc.FundingShimCancel.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.FundingTransitionMsg}
 */
proto.lnrpc.FundingTransitionMsg.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.FundingTransitionMsg;
  return proto.lnrpc.FundingTransitionMsg.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.FundingTransitionMsg} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.FundingTransitionMsg}
 */
proto.lnrpc.FundingTransitionMsg.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.FundingShim;
      reader.readMessage(value,proto.lnrpc.FundingShim.deserializeBinaryFromReader);
      msg.setShimRegister(value);
      break;
    case 2:
      var value = new proto.lnrpc.FundingShimCancel;
      reader.readMessage(value,proto.lnrpc.FundingShimCancel.deserializeBinaryFromReader);
      msg.setShimCancel(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.FundingTransitionMsg.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.FundingTransitionMsg.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.FundingTransitionMsg} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FundingTransitionMsg.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getShimRegister();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.FundingShim.serializeBinaryToWriter
    );
  }
  f = message.getShimCancel();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.lnrpc.FundingShimCancel.serializeBinaryToWriter
    );
  }
};


/**
 * optional FundingShim shim_register = 1;
 * @return {?proto.lnrpc.FundingShim}
 */
proto.lnrpc.FundingTransitionMsg.prototype.getShimRegister = function() {
  return /** @type{?proto.lnrpc.FundingShim} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.FundingShim, 1));
};


/** @param {?proto.lnrpc.FundingShim|undefined} value */
proto.lnrpc.FundingTransitionMsg.prototype.setShimRegister = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.lnrpc.FundingTransitionMsg.oneofGroups_[0], value);
};


proto.lnrpc.FundingTransitionMsg.prototype.clearShimRegister = function() {
  this.setShimRegister(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.FundingTransitionMsg.prototype.hasShimRegister = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional FundingShimCancel shim_cancel = 2;
 * @return {?proto.lnrpc.FundingShimCancel}
 */
proto.lnrpc.FundingTransitionMsg.prototype.getShimCancel = function() {
  return /** @type{?proto.lnrpc.FundingShimCancel} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.FundingShimCancel, 2));
};


/** @param {?proto.lnrpc.FundingShimCancel|undefined} value */
proto.lnrpc.FundingTransitionMsg.prototype.setShimCancel = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.lnrpc.FundingTransitionMsg.oneofGroups_[0], value);
};


proto.lnrpc.FundingTransitionMsg.prototype.clearShimCancel = function() {
  this.setShimCancel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.FundingTransitionMsg.prototype.hasShimCancel = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.FundingStateStepResp = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.FundingStateStepResp, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.FundingStateStepResp.displayName = 'proto.lnrpc.FundingStateStepResp';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.FundingStateStepResp.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.FundingStateStepResp.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.FundingStateStepResp} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FundingStateStepResp.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.FundingStateStepResp}
 */
proto.lnrpc.FundingStateStepResp.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.FundingStateStepResp;
  return proto.lnrpc.FundingStateStepResp.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.FundingStateStepResp} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.FundingStateStepResp}
 */
proto.lnrpc.FundingStateStepResp.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.FundingStateStepResp.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.FundingStateStepResp.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.FundingStateStepResp} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FundingStateStepResp.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingHTLC = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PendingHTLC, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingHTLC.displayName = 'proto.lnrpc.PendingHTLC';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingHTLC.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingHTLC.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingHTLC} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingHTLC.toObject = function(includeInstance, msg) {
  var f, obj = {
    incoming: jspb.Message.getFieldWithDefault(msg, 1, false),
    amount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    outpoint: jspb.Message.getFieldWithDefault(msg, 3, ""),
    maturityHeight: jspb.Message.getFieldWithDefault(msg, 4, 0),
    blocksTilMaturity: jspb.Message.getFieldWithDefault(msg, 5, 0),
    stage: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingHTLC}
 */
proto.lnrpc.PendingHTLC.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingHTLC;
  return proto.lnrpc.PendingHTLC.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingHTLC} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingHTLC}
 */
proto.lnrpc.PendingHTLC.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncoming(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setOutpoint(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMaturityHeight(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlocksTilMaturity(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setStage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingHTLC.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingHTLC.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingHTLC} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingHTLC.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIncoming();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getOutpoint();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getMaturityHeight();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getBlocksTilMaturity();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = message.getStage();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional bool incoming = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.PendingHTLC.prototype.getIncoming = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.PendingHTLC.prototype.setIncoming = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 amount = 2;
 * @return {number}
 */
proto.lnrpc.PendingHTLC.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.PendingHTLC.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string outpoint = 3;
 * @return {string}
 */
proto.lnrpc.PendingHTLC.prototype.getOutpoint = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.lnrpc.PendingHTLC.prototype.setOutpoint = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 maturity_height = 4;
 * @return {number}
 */
proto.lnrpc.PendingHTLC.prototype.getMaturityHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.PendingHTLC.prototype.setMaturityHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 blocks_til_maturity = 5;
 * @return {number}
 */
proto.lnrpc.PendingHTLC.prototype.getBlocksTilMaturity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.PendingHTLC.prototype.setBlocksTilMaturity = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 stage = 6;
 * @return {number}
 */
proto.lnrpc.PendingHTLC.prototype.getStage = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.PendingHTLC.prototype.setStage = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingChannelsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PendingChannelsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingChannelsRequest.displayName = 'proto.lnrpc.PendingChannelsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingChannelsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingChannelsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingChannelsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingChannelsRequest}
 */
proto.lnrpc.PendingChannelsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingChannelsRequest;
  return proto.lnrpc.PendingChannelsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingChannelsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingChannelsRequest}
 */
proto.lnrpc.PendingChannelsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingChannelsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingChannelsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingChannelsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingChannelsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.PendingChannelsResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.PendingChannelsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingChannelsResponse.displayName = 'proto.lnrpc.PendingChannelsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.PendingChannelsResponse.repeatedFields_ = [2,3,4,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingChannelsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingChannelsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingChannelsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    totalLimboBalance: jspb.Message.getFieldWithDefault(msg, 1, 0),
    pendingOpenChannelsList: jspb.Message.toObjectList(msg.getPendingOpenChannelsList(),
    proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.toObject, includeInstance),
    pendingClosingChannelsList: jspb.Message.toObjectList(msg.getPendingClosingChannelsList(),
    proto.lnrpc.PendingChannelsResponse.ClosedChannel.toObject, includeInstance),
    pendingForceClosingChannelsList: jspb.Message.toObjectList(msg.getPendingForceClosingChannelsList(),
    proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.toObject, includeInstance),
    waitingCloseChannelsList: jspb.Message.toObjectList(msg.getWaitingCloseChannelsList(),
    proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingChannelsResponse}
 */
proto.lnrpc.PendingChannelsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingChannelsResponse;
  return proto.lnrpc.PendingChannelsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingChannelsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingChannelsResponse}
 */
proto.lnrpc.PendingChannelsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalLimboBalance(value);
      break;
    case 2:
      var value = new proto.lnrpc.PendingChannelsResponse.PendingOpenChannel;
      reader.readMessage(value,proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.deserializeBinaryFromReader);
      msg.addPendingOpenChannels(value);
      break;
    case 3:
      var value = new proto.lnrpc.PendingChannelsResponse.ClosedChannel;
      reader.readMessage(value,proto.lnrpc.PendingChannelsResponse.ClosedChannel.deserializeBinaryFromReader);
      msg.addPendingClosingChannels(value);
      break;
    case 4:
      var value = new proto.lnrpc.PendingChannelsResponse.ForceClosedChannel;
      reader.readMessage(value,proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.deserializeBinaryFromReader);
      msg.addPendingForceClosingChannels(value);
      break;
    case 5:
      var value = new proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel;
      reader.readMessage(value,proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.deserializeBinaryFromReader);
      msg.addWaitingCloseChannels(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingChannelsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingChannelsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingChannelsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTotalLimboBalance();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getPendingOpenChannelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.serializeBinaryToWriter
    );
  }
  f = message.getPendingClosingChannelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.lnrpc.PendingChannelsResponse.ClosedChannel.serializeBinaryToWriter
    );
  }
  f = message.getPendingForceClosingChannelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.serializeBinaryToWriter
    );
  }
  f = message.getWaitingCloseChannelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PendingChannelsResponse.PendingChannel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingChannelsResponse.PendingChannel.displayName = 'proto.lnrpc.PendingChannelsResponse.PendingChannel';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingChannelsResponse.PendingChannel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingChannelsResponse.PendingChannel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.toObject = function(includeInstance, msg) {
  var f, obj = {
    remoteNodePub: jspb.Message.getFieldWithDefault(msg, 1, ""),
    channelPoint: jspb.Message.getFieldWithDefault(msg, 2, ""),
    capacity: jspb.Message.getFieldWithDefault(msg, 3, 0),
    localBalance: jspb.Message.getFieldWithDefault(msg, 4, 0),
    remoteBalance: jspb.Message.getFieldWithDefault(msg, 5, 0),
    localChanReserveAtoms: jspb.Message.getFieldWithDefault(msg, 6, 0),
    remoteChanReserveAtoms: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingChannelsResponse.PendingChannel}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingChannelsResponse.PendingChannel;
  return proto.lnrpc.PendingChannelsResponse.PendingChannel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingChannelsResponse.PendingChannel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingChannelsResponse.PendingChannel}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setRemoteNodePub(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setChannelPoint(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCapacity(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLocalBalance(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setRemoteBalance(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLocalChanReserveAtoms(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setRemoteChanReserveAtoms(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingChannelsResponse.PendingChannel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingChannelsResponse.PendingChannel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRemoteNodePub();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getChannelPoint();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getCapacity();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getLocalBalance();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getRemoteBalance();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getLocalChanReserveAtoms();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getRemoteChanReserveAtoms();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
};


/**
 * optional string remote_node_pub = 1;
 * @return {string}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.getRemoteNodePub = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.setRemoteNodePub = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string channel_point = 2;
 * @return {string}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.getChannelPoint = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.setChannelPoint = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 capacity = 3;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.getCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.setCapacity = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 local_balance = 4;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.getLocalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.setLocalBalance = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 remote_balance = 5;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.getRemoteBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.setRemoteBalance = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 local_chan_reserve_atoms = 6;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.getLocalChanReserveAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.setLocalChanReserveAtoms = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 remote_chan_reserve_atoms = 7;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.getRemoteChanReserveAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingChannel.prototype.setRemoteChanReserveAtoms = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PendingChannelsResponse.PendingOpenChannel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.displayName = 'proto.lnrpc.PendingChannelsResponse.PendingOpenChannel';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.toObject = function(includeInstance, msg) {
  var f, obj = {
    channel: (f = msg.getChannel()) && proto.lnrpc.PendingChannelsResponse.PendingChannel.toObject(includeInstance, f),
    confirmationHeight: jspb.Message.getFieldWithDefault(msg, 2, 0),
    commitFee: jspb.Message.getFieldWithDefault(msg, 4, 0),
    commitSize: jspb.Message.getFieldWithDefault(msg, 5, 0),
    feePerKb: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingChannelsResponse.PendingOpenChannel;
  return proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.PendingChannelsResponse.PendingChannel;
      reader.readMessage(value,proto.lnrpc.PendingChannelsResponse.PendingChannel.deserializeBinaryFromReader);
      msg.setChannel(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setConfirmationHeight(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCommitFee(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCommitSize(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeePerKb(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannel();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.PendingChannelsResponse.PendingChannel.serializeBinaryToWriter
    );
  }
  f = message.getConfirmationHeight();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getCommitFee();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getCommitSize();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getFeePerKb();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
};


/**
 * optional PendingChannel channel = 1;
 * @return {?proto.lnrpc.PendingChannelsResponse.PendingChannel}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.getChannel = function() {
  return /** @type{?proto.lnrpc.PendingChannelsResponse.PendingChannel} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.PendingChannelsResponse.PendingChannel, 1));
};


/** @param {?proto.lnrpc.PendingChannelsResponse.PendingChannel|undefined} value */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.setChannel = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.clearChannel = function() {
  this.setChannel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.hasChannel = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 confirmation_height = 2;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.getConfirmationHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.setConfirmationHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 commit_fee = 4;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.getCommitFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.setCommitFee = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 commit_size = 5;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.getCommitSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.setCommitSize = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 fee_per_kb = 6;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.getFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.PendingOpenChannel.prototype.setFeePerKb = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.displayName = 'proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.toObject = function(includeInstance, msg) {
  var f, obj = {
    channel: (f = msg.getChannel()) && proto.lnrpc.PendingChannelsResponse.PendingChannel.toObject(includeInstance, f),
    limboBalance: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel}
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel;
  return proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel}
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.PendingChannelsResponse.PendingChannel;
      reader.readMessage(value,proto.lnrpc.PendingChannelsResponse.PendingChannel.deserializeBinaryFromReader);
      msg.setChannel(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLimboBalance(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannel();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.PendingChannelsResponse.PendingChannel.serializeBinaryToWriter
    );
  }
  f = message.getLimboBalance();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional PendingChannel channel = 1;
 * @return {?proto.lnrpc.PendingChannelsResponse.PendingChannel}
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.prototype.getChannel = function() {
  return /** @type{?proto.lnrpc.PendingChannelsResponse.PendingChannel} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.PendingChannelsResponse.PendingChannel, 1));
};


/** @param {?proto.lnrpc.PendingChannelsResponse.PendingChannel|undefined} value */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.prototype.setChannel = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.prototype.clearChannel = function() {
  this.setChannel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.prototype.hasChannel = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int64 limbo_balance = 2;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.prototype.getLimboBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel.prototype.setLimboBalance = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PendingChannelsResponse.ClosedChannel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingChannelsResponse.ClosedChannel.displayName = 'proto.lnrpc.PendingChannelsResponse.ClosedChannel';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingChannelsResponse.ClosedChannel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingChannelsResponse.ClosedChannel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.toObject = function(includeInstance, msg) {
  var f, obj = {
    channel: (f = msg.getChannel()) && proto.lnrpc.PendingChannelsResponse.PendingChannel.toObject(includeInstance, f),
    closingTxid: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingChannelsResponse.ClosedChannel}
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingChannelsResponse.ClosedChannel;
  return proto.lnrpc.PendingChannelsResponse.ClosedChannel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingChannelsResponse.ClosedChannel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingChannelsResponse.ClosedChannel}
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.PendingChannelsResponse.PendingChannel;
      reader.readMessage(value,proto.lnrpc.PendingChannelsResponse.PendingChannel.deserializeBinaryFromReader);
      msg.setChannel(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setClosingTxid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingChannelsResponse.ClosedChannel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingChannelsResponse.ClosedChannel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannel();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.PendingChannelsResponse.PendingChannel.serializeBinaryToWriter
    );
  }
  f = message.getClosingTxid();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional PendingChannel channel = 1;
 * @return {?proto.lnrpc.PendingChannelsResponse.PendingChannel}
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.prototype.getChannel = function() {
  return /** @type{?proto.lnrpc.PendingChannelsResponse.PendingChannel} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.PendingChannelsResponse.PendingChannel, 1));
};


/** @param {?proto.lnrpc.PendingChannelsResponse.PendingChannel|undefined} value */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.prototype.setChannel = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.PendingChannelsResponse.ClosedChannel.prototype.clearChannel = function() {
  this.setChannel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.prototype.hasChannel = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string closing_txid = 2;
 * @return {string}
 */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.prototype.getClosingTxid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.PendingChannelsResponse.ClosedChannel.prototype.setClosingTxid = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.PendingChannelsResponse.ForceClosedChannel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.displayName = 'proto.lnrpc.PendingChannelsResponse.ForceClosedChannel';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.repeatedFields_ = [8];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.toObject = function(includeInstance, msg) {
  var f, obj = {
    channel: (f = msg.getChannel()) && proto.lnrpc.PendingChannelsResponse.PendingChannel.toObject(includeInstance, f),
    closingTxid: jspb.Message.getFieldWithDefault(msg, 2, ""),
    limboBalance: jspb.Message.getFieldWithDefault(msg, 3, 0),
    maturityHeight: jspb.Message.getFieldWithDefault(msg, 4, 0),
    blocksTilMaturity: jspb.Message.getFieldWithDefault(msg, 5, 0),
    recoveredBalance: jspb.Message.getFieldWithDefault(msg, 6, 0),
    pendingHtlcsList: jspb.Message.toObjectList(msg.getPendingHtlcsList(),
    proto.lnrpc.PendingHTLC.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PendingChannelsResponse.ForceClosedChannel;
  return proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.PendingChannelsResponse.PendingChannel;
      reader.readMessage(value,proto.lnrpc.PendingChannelsResponse.PendingChannel.deserializeBinaryFromReader);
      msg.setChannel(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setClosingTxid(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLimboBalance(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMaturityHeight(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlocksTilMaturity(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setRecoveredBalance(value);
      break;
    case 8:
      var value = new proto.lnrpc.PendingHTLC;
      reader.readMessage(value,proto.lnrpc.PendingHTLC.deserializeBinaryFromReader);
      msg.addPendingHtlcs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannel();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.PendingChannelsResponse.PendingChannel.serializeBinaryToWriter
    );
  }
  f = message.getClosingTxid();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getLimboBalance();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getMaturityHeight();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getBlocksTilMaturity();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = message.getRecoveredBalance();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getPendingHtlcsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      8,
      f,
      proto.lnrpc.PendingHTLC.serializeBinaryToWriter
    );
  }
};


/**
 * optional PendingChannel channel = 1;
 * @return {?proto.lnrpc.PendingChannelsResponse.PendingChannel}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.getChannel = function() {
  return /** @type{?proto.lnrpc.PendingChannelsResponse.PendingChannel} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.PendingChannelsResponse.PendingChannel, 1));
};


/** @param {?proto.lnrpc.PendingChannelsResponse.PendingChannel|undefined} value */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.setChannel = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.clearChannel = function() {
  this.setChannel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.hasChannel = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string closing_txid = 2;
 * @return {string}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.getClosingTxid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.setClosingTxid = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 limbo_balance = 3;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.getLimboBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.setLimboBalance = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 maturity_height = 4;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.getMaturityHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.setMaturityHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 blocks_til_maturity = 5;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.getBlocksTilMaturity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.setBlocksTilMaturity = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 recovered_balance = 6;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.getRecoveredBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.setRecoveredBalance = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * repeated PendingHTLC pending_htlcs = 8;
 * @return {!Array.<!proto.lnrpc.PendingHTLC>}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.getPendingHtlcsList = function() {
  return /** @type{!Array.<!proto.lnrpc.PendingHTLC>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.PendingHTLC, 8));
};


/** @param {!Array.<!proto.lnrpc.PendingHTLC>} value */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.setPendingHtlcsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 8, value);
};


/**
 * @param {!proto.lnrpc.PendingHTLC=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.PendingHTLC}
 */
proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.addPendingHtlcs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 8, opt_value, proto.lnrpc.PendingHTLC, opt_index);
};


proto.lnrpc.PendingChannelsResponse.ForceClosedChannel.prototype.clearPendingHtlcsList = function() {
  this.setPendingHtlcsList([]);
};


/**
 * optional int64 total_limbo_balance = 1;
 * @return {number}
 */
proto.lnrpc.PendingChannelsResponse.prototype.getTotalLimboBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.PendingChannelsResponse.prototype.setTotalLimboBalance = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated PendingOpenChannel pending_open_channels = 2;
 * @return {!Array.<!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel>}
 */
proto.lnrpc.PendingChannelsResponse.prototype.getPendingOpenChannelsList = function() {
  return /** @type{!Array.<!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.PendingChannelsResponse.PendingOpenChannel, 2));
};


/** @param {!Array.<!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel>} value */
proto.lnrpc.PendingChannelsResponse.prototype.setPendingOpenChannelsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.PendingChannelsResponse.PendingOpenChannel}
 */
proto.lnrpc.PendingChannelsResponse.prototype.addPendingOpenChannels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.lnrpc.PendingChannelsResponse.PendingOpenChannel, opt_index);
};


proto.lnrpc.PendingChannelsResponse.prototype.clearPendingOpenChannelsList = function() {
  this.setPendingOpenChannelsList([]);
};


/**
 * repeated ClosedChannel pending_closing_channels = 3;
 * @return {!Array.<!proto.lnrpc.PendingChannelsResponse.ClosedChannel>}
 */
proto.lnrpc.PendingChannelsResponse.prototype.getPendingClosingChannelsList = function() {
  return /** @type{!Array.<!proto.lnrpc.PendingChannelsResponse.ClosedChannel>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.PendingChannelsResponse.ClosedChannel, 3));
};


/** @param {!Array.<!proto.lnrpc.PendingChannelsResponse.ClosedChannel>} value */
proto.lnrpc.PendingChannelsResponse.prototype.setPendingClosingChannelsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.lnrpc.PendingChannelsResponse.ClosedChannel=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.PendingChannelsResponse.ClosedChannel}
 */
proto.lnrpc.PendingChannelsResponse.prototype.addPendingClosingChannels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.lnrpc.PendingChannelsResponse.ClosedChannel, opt_index);
};


proto.lnrpc.PendingChannelsResponse.prototype.clearPendingClosingChannelsList = function() {
  this.setPendingClosingChannelsList([]);
};


/**
 * repeated ForceClosedChannel pending_force_closing_channels = 4;
 * @return {!Array.<!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel>}
 */
proto.lnrpc.PendingChannelsResponse.prototype.getPendingForceClosingChannelsList = function() {
  return /** @type{!Array.<!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.PendingChannelsResponse.ForceClosedChannel, 4));
};


/** @param {!Array.<!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel>} value */
proto.lnrpc.PendingChannelsResponse.prototype.setPendingForceClosingChannelsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.PendingChannelsResponse.ForceClosedChannel}
 */
proto.lnrpc.PendingChannelsResponse.prototype.addPendingForceClosingChannels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.lnrpc.PendingChannelsResponse.ForceClosedChannel, opt_index);
};


proto.lnrpc.PendingChannelsResponse.prototype.clearPendingForceClosingChannelsList = function() {
  this.setPendingForceClosingChannelsList([]);
};


/**
 * repeated WaitingCloseChannel waiting_close_channels = 5;
 * @return {!Array.<!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel>}
 */
proto.lnrpc.PendingChannelsResponse.prototype.getWaitingCloseChannelsList = function() {
  return /** @type{!Array.<!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel, 5));
};


/** @param {!Array.<!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel>} value */
proto.lnrpc.PendingChannelsResponse.prototype.setWaitingCloseChannelsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel}
 */
proto.lnrpc.PendingChannelsResponse.prototype.addWaitingCloseChannels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.lnrpc.PendingChannelsResponse.WaitingCloseChannel, opt_index);
};


proto.lnrpc.PendingChannelsResponse.prototype.clearWaitingCloseChannelsList = function() {
  this.setWaitingCloseChannelsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelEventSubscription = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelEventSubscription, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelEventSubscription.displayName = 'proto.lnrpc.ChannelEventSubscription';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelEventSubscription.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelEventSubscription.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelEventSubscription} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelEventSubscription.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelEventSubscription}
 */
proto.lnrpc.ChannelEventSubscription.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelEventSubscription;
  return proto.lnrpc.ChannelEventSubscription.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelEventSubscription} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelEventSubscription}
 */
proto.lnrpc.ChannelEventSubscription.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelEventSubscription.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelEventSubscription.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelEventSubscription} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelEventSubscription.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelEventUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.ChannelEventUpdate.oneofGroups_);
};
goog.inherits(proto.lnrpc.ChannelEventUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelEventUpdate.displayName = 'proto.lnrpc.ChannelEventUpdate';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.ChannelEventUpdate.oneofGroups_ = [[1,2,3,4]];

/**
 * @enum {number}
 */
proto.lnrpc.ChannelEventUpdate.ChannelCase = {
  CHANNEL_NOT_SET: 0,
  OPEN_CHANNEL: 1,
  CLOSED_CHANNEL: 2,
  ACTIVE_CHANNEL: 3,
  INACTIVE_CHANNEL: 4
};

/**
 * @return {proto.lnrpc.ChannelEventUpdate.ChannelCase}
 */
proto.lnrpc.ChannelEventUpdate.prototype.getChannelCase = function() {
  return /** @type {proto.lnrpc.ChannelEventUpdate.ChannelCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.ChannelEventUpdate.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelEventUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelEventUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelEventUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelEventUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    openChannel: (f = msg.getOpenChannel()) && proto.lnrpc.Channel.toObject(includeInstance, f),
    closedChannel: (f = msg.getClosedChannel()) && proto.lnrpc.ChannelCloseSummary.toObject(includeInstance, f),
    activeChannel: (f = msg.getActiveChannel()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f),
    inactiveChannel: (f = msg.getInactiveChannel()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f),
    type: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelEventUpdate}
 */
proto.lnrpc.ChannelEventUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelEventUpdate;
  return proto.lnrpc.ChannelEventUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelEventUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelEventUpdate}
 */
proto.lnrpc.ChannelEventUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.Channel;
      reader.readMessage(value,proto.lnrpc.Channel.deserializeBinaryFromReader);
      msg.setOpenChannel(value);
      break;
    case 2:
      var value = new proto.lnrpc.ChannelCloseSummary;
      reader.readMessage(value,proto.lnrpc.ChannelCloseSummary.deserializeBinaryFromReader);
      msg.setClosedChannel(value);
      break;
    case 3:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setActiveChannel(value);
      break;
    case 4:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setInactiveChannel(value);
      break;
    case 5:
      var value = /** @type {!proto.lnrpc.ChannelEventUpdate.UpdateType} */ (reader.readEnum());
      msg.setType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelEventUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelEventUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelEventUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelEventUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getOpenChannel();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.Channel.serializeBinaryToWriter
    );
  }
  f = message.getClosedChannel();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.lnrpc.ChannelCloseSummary.serializeBinaryToWriter
    );
  }
  f = message.getActiveChannel();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
  f = message.getInactiveChannel();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.lnrpc.ChannelEventUpdate.UpdateType = {
  OPEN_CHANNEL: 0,
  CLOSED_CHANNEL: 1,
  ACTIVE_CHANNEL: 2,
  INACTIVE_CHANNEL: 3
};

/**
 * optional Channel open_channel = 1;
 * @return {?proto.lnrpc.Channel}
 */
proto.lnrpc.ChannelEventUpdate.prototype.getOpenChannel = function() {
  return /** @type{?proto.lnrpc.Channel} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.Channel, 1));
};


/** @param {?proto.lnrpc.Channel|undefined} value */
proto.lnrpc.ChannelEventUpdate.prototype.setOpenChannel = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.lnrpc.ChannelEventUpdate.oneofGroups_[0], value);
};


proto.lnrpc.ChannelEventUpdate.prototype.clearOpenChannel = function() {
  this.setOpenChannel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelEventUpdate.prototype.hasOpenChannel = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ChannelCloseSummary closed_channel = 2;
 * @return {?proto.lnrpc.ChannelCloseSummary}
 */
proto.lnrpc.ChannelEventUpdate.prototype.getClosedChannel = function() {
  return /** @type{?proto.lnrpc.ChannelCloseSummary} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelCloseSummary, 2));
};


/** @param {?proto.lnrpc.ChannelCloseSummary|undefined} value */
proto.lnrpc.ChannelEventUpdate.prototype.setClosedChannel = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.lnrpc.ChannelEventUpdate.oneofGroups_[0], value);
};


proto.lnrpc.ChannelEventUpdate.prototype.clearClosedChannel = function() {
  this.setClosedChannel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelEventUpdate.prototype.hasClosedChannel = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ChannelPoint active_channel = 3;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ChannelEventUpdate.prototype.getActiveChannel = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 3));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.ChannelEventUpdate.prototype.setActiveChannel = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.lnrpc.ChannelEventUpdate.oneofGroups_[0], value);
};


proto.lnrpc.ChannelEventUpdate.prototype.clearActiveChannel = function() {
  this.setActiveChannel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelEventUpdate.prototype.hasActiveChannel = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional ChannelPoint inactive_channel = 4;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ChannelEventUpdate.prototype.getInactiveChannel = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 4));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.ChannelEventUpdate.prototype.setInactiveChannel = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.lnrpc.ChannelEventUpdate.oneofGroups_[0], value);
};


proto.lnrpc.ChannelEventUpdate.prototype.clearInactiveChannel = function() {
  this.setInactiveChannel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelEventUpdate.prototype.hasInactiveChannel = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional UpdateType type = 5;
 * @return {!proto.lnrpc.ChannelEventUpdate.UpdateType}
 */
proto.lnrpc.ChannelEventUpdate.prototype.getType = function() {
  return /** @type {!proto.lnrpc.ChannelEventUpdate.UpdateType} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {!proto.lnrpc.ChannelEventUpdate.UpdateType} value */
proto.lnrpc.ChannelEventUpdate.prototype.setType = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.WalletBalanceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.WalletBalanceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.WalletBalanceRequest.displayName = 'proto.lnrpc.WalletBalanceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.WalletBalanceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.WalletBalanceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.WalletBalanceRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.WalletBalanceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.WalletBalanceRequest}
 */
proto.lnrpc.WalletBalanceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.WalletBalanceRequest;
  return proto.lnrpc.WalletBalanceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.WalletBalanceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.WalletBalanceRequest}
 */
proto.lnrpc.WalletBalanceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.WalletBalanceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.WalletBalanceRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.WalletBalanceRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.WalletBalanceRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.WalletBalanceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.WalletBalanceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.WalletBalanceResponse.displayName = 'proto.lnrpc.WalletBalanceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.WalletBalanceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.WalletBalanceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.WalletBalanceResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.WalletBalanceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    totalBalance: jspb.Message.getFieldWithDefault(msg, 1, 0),
    confirmedBalance: jspb.Message.getFieldWithDefault(msg, 2, 0),
    unconfirmedBalance: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.WalletBalanceResponse}
 */
proto.lnrpc.WalletBalanceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.WalletBalanceResponse;
  return proto.lnrpc.WalletBalanceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.WalletBalanceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.WalletBalanceResponse}
 */
proto.lnrpc.WalletBalanceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalBalance(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setConfirmedBalance(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUnconfirmedBalance(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.WalletBalanceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.WalletBalanceResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.WalletBalanceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.WalletBalanceResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTotalBalance();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getConfirmedBalance();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getUnconfirmedBalance();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * optional int64 total_balance = 1;
 * @return {number}
 */
proto.lnrpc.WalletBalanceResponse.prototype.getTotalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.WalletBalanceResponse.prototype.setTotalBalance = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 confirmed_balance = 2;
 * @return {number}
 */
proto.lnrpc.WalletBalanceResponse.prototype.getConfirmedBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.WalletBalanceResponse.prototype.setConfirmedBalance = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 unconfirmed_balance = 3;
 * @return {number}
 */
proto.lnrpc.WalletBalanceResponse.prototype.getUnconfirmedBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.WalletBalanceResponse.prototype.setUnconfirmedBalance = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelBalanceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelBalanceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelBalanceRequest.displayName = 'proto.lnrpc.ChannelBalanceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelBalanceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelBalanceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelBalanceRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBalanceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelBalanceRequest}
 */
proto.lnrpc.ChannelBalanceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelBalanceRequest;
  return proto.lnrpc.ChannelBalanceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelBalanceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelBalanceRequest}
 */
proto.lnrpc.ChannelBalanceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelBalanceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelBalanceRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelBalanceRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBalanceRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelBalanceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelBalanceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelBalanceResponse.displayName = 'proto.lnrpc.ChannelBalanceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelBalanceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelBalanceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelBalanceResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBalanceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    balance: jspb.Message.getFieldWithDefault(msg, 1, 0),
    pendingOpenBalance: jspb.Message.getFieldWithDefault(msg, 2, 0),
    maxInboundAmount: jspb.Message.getFieldWithDefault(msg, 3, 0),
    maxOutboundAmount: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelBalanceResponse}
 */
proto.lnrpc.ChannelBalanceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelBalanceResponse;
  return proto.lnrpc.ChannelBalanceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelBalanceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelBalanceResponse}
 */
proto.lnrpc.ChannelBalanceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBalance(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setPendingOpenBalance(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxInboundAmount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxOutboundAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelBalanceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelBalanceResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelBalanceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBalanceResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBalance();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getPendingOpenBalance();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getMaxInboundAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getMaxOutboundAmount();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
};


/**
 * optional int64 balance = 1;
 * @return {number}
 */
proto.lnrpc.ChannelBalanceResponse.prototype.getBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelBalanceResponse.prototype.setBalance = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 pending_open_balance = 2;
 * @return {number}
 */
proto.lnrpc.ChannelBalanceResponse.prototype.getPendingOpenBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelBalanceResponse.prototype.setPendingOpenBalance = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 max_inbound_amount = 3;
 * @return {number}
 */
proto.lnrpc.ChannelBalanceResponse.prototype.getMaxInboundAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelBalanceResponse.prototype.setMaxInboundAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 max_outbound_amount = 4;
 * @return {number}
 */
proto.lnrpc.ChannelBalanceResponse.prototype.getMaxOutboundAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelBalanceResponse.prototype.setMaxOutboundAmount = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.QueryRoutesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.QueryRoutesRequest.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.QueryRoutesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.QueryRoutesRequest.displayName = 'proto.lnrpc.QueryRoutesRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.QueryRoutesRequest.repeatedFields_ = [6,7,10,16,17];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.QueryRoutesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.QueryRoutesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.QueryRoutesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.QueryRoutesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    pubKey: jspb.Message.getFieldWithDefault(msg, 1, ""),
    amt: jspb.Message.getFieldWithDefault(msg, 2, 0),
    amtMAtoms: jspb.Message.getFieldWithDefault(msg, 12, 0),
    finalCltvDelta: jspb.Message.getFieldWithDefault(msg, 4, 0),
    feeLimit: (f = msg.getFeeLimit()) && proto.lnrpc.FeeLimit.toObject(includeInstance, f),
    ignoredNodesList: msg.getIgnoredNodesList_asB64(),
    ignoredEdgesList: jspb.Message.toObjectList(msg.getIgnoredEdgesList(),
    proto.lnrpc.EdgeLocator.toObject, includeInstance),
    sourcePubKey: jspb.Message.getFieldWithDefault(msg, 8, ""),
    useMissionControl: jspb.Message.getFieldWithDefault(msg, 9, false),
    ignoredPairsList: jspb.Message.toObjectList(msg.getIgnoredPairsList(),
    proto.lnrpc.NodePair.toObject, includeInstance),
    cltvLimit: jspb.Message.getFieldWithDefault(msg, 11, 0),
    destCustomRecordsMap: (f = msg.getDestCustomRecordsMap()) ? f.toObject(includeInstance, undefined) : [],
    outgoingChanId: jspb.Message.getFieldWithDefault(msg, 14, "0"),
    lastHopPubkey: msg.getLastHopPubkey_asB64(),
    routeHintsList: jspb.Message.toObjectList(msg.getRouteHintsList(),
    proto.lnrpc.RouteHint.toObject, includeInstance),
    destFeaturesList: jspb.Message.getRepeatedField(msg, 17)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.QueryRoutesRequest}
 */
proto.lnrpc.QueryRoutesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.QueryRoutesRequest;
  return proto.lnrpc.QueryRoutesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.QueryRoutesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.QueryRoutesRequest}
 */
proto.lnrpc.QueryRoutesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKey(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmt(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmtMAtoms(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFinalCltvDelta(value);
      break;
    case 5:
      var value = new proto.lnrpc.FeeLimit;
      reader.readMessage(value,proto.lnrpc.FeeLimit.deserializeBinaryFromReader);
      msg.setFeeLimit(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addIgnoredNodes(value);
      break;
    case 7:
      var value = new proto.lnrpc.EdgeLocator;
      reader.readMessage(value,proto.lnrpc.EdgeLocator.deserializeBinaryFromReader);
      msg.addIgnoredEdges(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setSourcePubKey(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUseMissionControl(value);
      break;
    case 10:
      var value = new proto.lnrpc.NodePair;
      reader.readMessage(value,proto.lnrpc.NodePair.deserializeBinaryFromReader);
      msg.addIgnoredPairs(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCltvLimit(value);
      break;
    case 13:
      var value = msg.getDestCustomRecordsMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint64, jspb.BinaryReader.prototype.readBytes);
         });
      break;
    case 14:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setOutgoingChanId(value);
      break;
    case 15:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLastHopPubkey(value);
      break;
    case 16:
      var value = new proto.lnrpc.RouteHint;
      reader.readMessage(value,proto.lnrpc.RouteHint.deserializeBinaryFromReader);
      msg.addRouteHints(value);
      break;
    case 17:
      var value = /** @type {!Array.<!proto.lnrpc.FeatureBit>} */ (reader.readPackedEnum());
      msg.setDestFeaturesList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.QueryRoutesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.QueryRoutesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.QueryRoutesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.QueryRoutesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPubKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAmt();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getAmtMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      12,
      f
    );
  }
  f = message.getFinalCltvDelta();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getFeeLimit();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.lnrpc.FeeLimit.serializeBinaryToWriter
    );
  }
  f = message.getIgnoredNodesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      6,
      f
    );
  }
  f = message.getIgnoredEdgesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      7,
      f,
      proto.lnrpc.EdgeLocator.serializeBinaryToWriter
    );
  }
  f = message.getSourcePubKey();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getUseMissionControl();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getIgnoredPairsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      10,
      f,
      proto.lnrpc.NodePair.serializeBinaryToWriter
    );
  }
  f = message.getCltvLimit();
  if (f !== 0) {
    writer.writeUint32(
      11,
      f
    );
  }
  f = message.getDestCustomRecordsMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(13, writer, jspb.BinaryWriter.prototype.writeUint64, jspb.BinaryWriter.prototype.writeBytes);
  }
  f = message.getOutgoingChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      14,
      f
    );
  }
  f = message.getLastHopPubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      15,
      f
    );
  }
  f = message.getRouteHintsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      16,
      f,
      proto.lnrpc.RouteHint.serializeBinaryToWriter
    );
  }
  f = message.getDestFeaturesList();
  if (f.length > 0) {
    writer.writePackedEnum(
      17,
      f
    );
  }
};


/**
 * optional string pub_key = 1;
 * @return {string}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.QueryRoutesRequest.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 amt = 2;
 * @return {number}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getAmt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.QueryRoutesRequest.prototype.setAmt = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 amt_m_atoms = 12;
 * @return {number}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getAmtMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.lnrpc.QueryRoutesRequest.prototype.setAmtMAtoms = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * optional int32 final_cltv_delta = 4;
 * @return {number}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getFinalCltvDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.QueryRoutesRequest.prototype.setFinalCltvDelta = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional FeeLimit fee_limit = 5;
 * @return {?proto.lnrpc.FeeLimit}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getFeeLimit = function() {
  return /** @type{?proto.lnrpc.FeeLimit} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.FeeLimit, 5));
};


/** @param {?proto.lnrpc.FeeLimit|undefined} value */
proto.lnrpc.QueryRoutesRequest.prototype.setFeeLimit = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.lnrpc.QueryRoutesRequest.prototype.clearFeeLimit = function() {
  this.setFeeLimit(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.QueryRoutesRequest.prototype.hasFeeLimit = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * repeated bytes ignored_nodes = 6;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getIgnoredNodesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 6));
};


/**
 * repeated bytes ignored_nodes = 6;
 * This is a type-conversion wrapper around `getIgnoredNodesList()`
 * @return {!Array.<string>}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getIgnoredNodesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getIgnoredNodesList()));
};


/**
 * repeated bytes ignored_nodes = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getIgnoredNodesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getIgnoredNodesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getIgnoredNodesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.lnrpc.QueryRoutesRequest.prototype.setIgnoredNodesList = function(value) {
  jspb.Message.setField(this, 6, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.lnrpc.QueryRoutesRequest.prototype.addIgnoredNodes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 6, value, opt_index);
};


proto.lnrpc.QueryRoutesRequest.prototype.clearIgnoredNodesList = function() {
  this.setIgnoredNodesList([]);
};


/**
 * repeated EdgeLocator ignored_edges = 7;
 * @return {!Array.<!proto.lnrpc.EdgeLocator>}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getIgnoredEdgesList = function() {
  return /** @type{!Array.<!proto.lnrpc.EdgeLocator>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.EdgeLocator, 7));
};


/** @param {!Array.<!proto.lnrpc.EdgeLocator>} value */
proto.lnrpc.QueryRoutesRequest.prototype.setIgnoredEdgesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 7, value);
};


/**
 * @param {!proto.lnrpc.EdgeLocator=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.EdgeLocator}
 */
proto.lnrpc.QueryRoutesRequest.prototype.addIgnoredEdges = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.lnrpc.EdgeLocator, opt_index);
};


proto.lnrpc.QueryRoutesRequest.prototype.clearIgnoredEdgesList = function() {
  this.setIgnoredEdgesList([]);
};


/**
 * optional string source_pub_key = 8;
 * @return {string}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getSourcePubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.lnrpc.QueryRoutesRequest.prototype.setSourcePubKey = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional bool use_mission_control = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getUseMissionControl = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.lnrpc.QueryRoutesRequest.prototype.setUseMissionControl = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * repeated NodePair ignored_pairs = 10;
 * @return {!Array.<!proto.lnrpc.NodePair>}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getIgnoredPairsList = function() {
  return /** @type{!Array.<!proto.lnrpc.NodePair>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.NodePair, 10));
};


/** @param {!Array.<!proto.lnrpc.NodePair>} value */
proto.lnrpc.QueryRoutesRequest.prototype.setIgnoredPairsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 10, value);
};


/**
 * @param {!proto.lnrpc.NodePair=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.NodePair}
 */
proto.lnrpc.QueryRoutesRequest.prototype.addIgnoredPairs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 10, opt_value, proto.lnrpc.NodePair, opt_index);
};


proto.lnrpc.QueryRoutesRequest.prototype.clearIgnoredPairsList = function() {
  this.setIgnoredPairsList([]);
};


/**
 * optional uint32 cltv_limit = 11;
 * @return {number}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getCltvLimit = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.lnrpc.QueryRoutesRequest.prototype.setCltvLimit = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * map<uint64, bytes> dest_custom_records = 13;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!(string|Uint8Array)>}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getDestCustomRecordsMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!(string|Uint8Array)>} */ (
      jspb.Message.getMapField(this, 13, opt_noLazyCreate,
      null));
};


proto.lnrpc.QueryRoutesRequest.prototype.clearDestCustomRecordsMap = function() {
  this.getDestCustomRecordsMap().clear();
};


/**
 * optional uint64 outgoing_chan_id = 14;
 * @return {string}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getOutgoingChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 14, "0"));
};


/** @param {string} value */
proto.lnrpc.QueryRoutesRequest.prototype.setOutgoingChanId = function(value) {
  jspb.Message.setField(this, 14, value);
};


/**
 * optional bytes last_hop_pubkey = 15;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getLastHopPubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 15, ""));
};


/**
 * optional bytes last_hop_pubkey = 15;
 * This is a type-conversion wrapper around `getLastHopPubkey()`
 * @return {string}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getLastHopPubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLastHopPubkey()));
};


/**
 * optional bytes last_hop_pubkey = 15;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLastHopPubkey()`
 * @return {!Uint8Array}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getLastHopPubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLastHopPubkey()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.QueryRoutesRequest.prototype.setLastHopPubkey = function(value) {
  jspb.Message.setField(this, 15, value);
};


/**
 * repeated RouteHint route_hints = 16;
 * @return {!Array.<!proto.lnrpc.RouteHint>}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getRouteHintsList = function() {
  return /** @type{!Array.<!proto.lnrpc.RouteHint>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.RouteHint, 16));
};


/** @param {!Array.<!proto.lnrpc.RouteHint>} value */
proto.lnrpc.QueryRoutesRequest.prototype.setRouteHintsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 16, value);
};


/**
 * @param {!proto.lnrpc.RouteHint=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.RouteHint}
 */
proto.lnrpc.QueryRoutesRequest.prototype.addRouteHints = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 16, opt_value, proto.lnrpc.RouteHint, opt_index);
};


proto.lnrpc.QueryRoutesRequest.prototype.clearRouteHintsList = function() {
  this.setRouteHintsList([]);
};


/**
 * repeated FeatureBit dest_features = 17;
 * @return {!Array.<!proto.lnrpc.FeatureBit>}
 */
proto.lnrpc.QueryRoutesRequest.prototype.getDestFeaturesList = function() {
  return /** @type {!Array.<!proto.lnrpc.FeatureBit>} */ (jspb.Message.getRepeatedField(this, 17));
};


/** @param {!Array.<!proto.lnrpc.FeatureBit>} value */
proto.lnrpc.QueryRoutesRequest.prototype.setDestFeaturesList = function(value) {
  jspb.Message.setField(this, 17, value || []);
};


/**
 * @param {!proto.lnrpc.FeatureBit} value
 * @param {number=} opt_index
 */
proto.lnrpc.QueryRoutesRequest.prototype.addDestFeatures = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 17, value, opt_index);
};


proto.lnrpc.QueryRoutesRequest.prototype.clearDestFeaturesList = function() {
  this.setDestFeaturesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NodePair = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.NodePair, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NodePair.displayName = 'proto.lnrpc.NodePair';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NodePair.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NodePair.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NodePair} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodePair.toObject = function(includeInstance, msg) {
  var f, obj = {
    from: msg.getFrom_asB64(),
    to: msg.getTo_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NodePair}
 */
proto.lnrpc.NodePair.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NodePair;
  return proto.lnrpc.NodePair.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NodePair} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NodePair}
 */
proto.lnrpc.NodePair.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setFrom(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NodePair.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NodePair.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NodePair} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodePair.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getFrom_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getTo_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes from = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.NodePair.prototype.getFrom = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes from = 1;
 * This is a type-conversion wrapper around `getFrom()`
 * @return {string}
 */
proto.lnrpc.NodePair.prototype.getFrom_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getFrom()));
};


/**
 * optional bytes from = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFrom()`
 * @return {!Uint8Array}
 */
proto.lnrpc.NodePair.prototype.getFrom_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getFrom()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.NodePair.prototype.setFrom = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes to = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.NodePair.prototype.getTo = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes to = 2;
 * This is a type-conversion wrapper around `getTo()`
 * @return {string}
 */
proto.lnrpc.NodePair.prototype.getTo_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTo()));
};


/**
 * optional bytes to = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTo()`
 * @return {!Uint8Array}
 */
proto.lnrpc.NodePair.prototype.getTo_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTo()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.NodePair.prototype.setTo = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.EdgeLocator = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.EdgeLocator, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.EdgeLocator.displayName = 'proto.lnrpc.EdgeLocator';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.EdgeLocator.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.EdgeLocator.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.EdgeLocator} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.EdgeLocator.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelId: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    directionReverse: jspb.Message.getFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.EdgeLocator}
 */
proto.lnrpc.EdgeLocator.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.EdgeLocator;
  return proto.lnrpc.EdgeLocator.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.EdgeLocator} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.EdgeLocator}
 */
proto.lnrpc.EdgeLocator.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChannelId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDirectionReverse(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.EdgeLocator.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.EdgeLocator.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.EdgeLocator} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.EdgeLocator.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getDirectionReverse();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional uint64 channel_id = 1;
 * @return {string}
 */
proto.lnrpc.EdgeLocator.prototype.getChannelId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/** @param {string} value */
proto.lnrpc.EdgeLocator.prototype.setChannelId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool direction_reverse = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.EdgeLocator.prototype.getDirectionReverse = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.lnrpc.EdgeLocator.prototype.setDirectionReverse = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.QueryRoutesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.QueryRoutesResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.QueryRoutesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.QueryRoutesResponse.displayName = 'proto.lnrpc.QueryRoutesResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.QueryRoutesResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.QueryRoutesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.QueryRoutesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.QueryRoutesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.QueryRoutesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    routesList: jspb.Message.toObjectList(msg.getRoutesList(),
    proto.lnrpc.Route.toObject, includeInstance),
    successProb: +jspb.Message.getFieldWithDefault(msg, 2, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.QueryRoutesResponse}
 */
proto.lnrpc.QueryRoutesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.QueryRoutesResponse;
  return proto.lnrpc.QueryRoutesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.QueryRoutesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.QueryRoutesResponse}
 */
proto.lnrpc.QueryRoutesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.Route;
      reader.readMessage(value,proto.lnrpc.Route.deserializeBinaryFromReader);
      msg.addRoutes(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setSuccessProb(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.QueryRoutesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.QueryRoutesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.QueryRoutesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.QueryRoutesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRoutesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.Route.serializeBinaryToWriter
    );
  }
  f = message.getSuccessProb();
  if (f !== 0.0) {
    writer.writeDouble(
      2,
      f
    );
  }
};


/**
 * repeated Route routes = 1;
 * @return {!Array.<!proto.lnrpc.Route>}
 */
proto.lnrpc.QueryRoutesResponse.prototype.getRoutesList = function() {
  return /** @type{!Array.<!proto.lnrpc.Route>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Route, 1));
};


/** @param {!Array.<!proto.lnrpc.Route>} value */
proto.lnrpc.QueryRoutesResponse.prototype.setRoutesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.Route=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Route}
 */
proto.lnrpc.QueryRoutesResponse.prototype.addRoutes = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.Route, opt_index);
};


proto.lnrpc.QueryRoutesResponse.prototype.clearRoutesList = function() {
  this.setRoutesList([]);
};


/**
 * optional double success_prob = 2;
 * @return {number}
 */
proto.lnrpc.QueryRoutesResponse.prototype.getSuccessProb = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.lnrpc.QueryRoutesResponse.prototype.setSuccessProb = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Hop = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.Hop, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Hop.displayName = 'proto.lnrpc.Hop';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Hop.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Hop.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Hop} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Hop.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanId: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    chanCapacity: jspb.Message.getFieldWithDefault(msg, 2, 0),
    amtToForward: jspb.Message.getFieldWithDefault(msg, 3, 0),
    fee: jspb.Message.getFieldWithDefault(msg, 4, 0),
    expiry: jspb.Message.getFieldWithDefault(msg, 5, 0),
    amtToForwardMAtoms: jspb.Message.getFieldWithDefault(msg, 6, 0),
    feeMAtoms: jspb.Message.getFieldWithDefault(msg, 7, 0),
    pubKey: jspb.Message.getFieldWithDefault(msg, 8, ""),
    tlvPayload: jspb.Message.getFieldWithDefault(msg, 9, false),
    mppRecord: (f = msg.getMppRecord()) && proto.lnrpc.MPPRecord.toObject(includeInstance, f),
    customRecordsMap: (f = msg.getCustomRecordsMap()) ? f.toObject(includeInstance, undefined) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Hop}
 */
proto.lnrpc.Hop.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Hop;
  return proto.lnrpc.Hop.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Hop} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Hop}
 */
proto.lnrpc.Hop.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setChanCapacity(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmtToForward(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFee(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpiry(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmtToForwardMAtoms(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeeMAtoms(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKey(value);
      break;
    case 9:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setTlvPayload(value);
      break;
    case 10:
      var value = new proto.lnrpc.MPPRecord;
      reader.readMessage(value,proto.lnrpc.MPPRecord.deserializeBinaryFromReader);
      msg.setMppRecord(value);
      break;
    case 11:
      var value = msg.getCustomRecordsMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint64, jspb.BinaryReader.prototype.readBytes);
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Hop.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Hop.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Hop} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Hop.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getChanCapacity();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getAmtToForward();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getFee();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getAmtToForwardMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getFeeMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getPubKey();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getTlvPayload();
  if (f) {
    writer.writeBool(
      9,
      f
    );
  }
  f = message.getMppRecord();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.lnrpc.MPPRecord.serializeBinaryToWriter
    );
  }
  f = message.getCustomRecordsMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(11, writer, jspb.BinaryWriter.prototype.writeUint64, jspb.BinaryWriter.prototype.writeBytes);
  }
};


/**
 * optional uint64 chan_id = 1;
 * @return {string}
 */
proto.lnrpc.Hop.prototype.getChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/** @param {string} value */
proto.lnrpc.Hop.prototype.setChanId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 chan_capacity = 2;
 * @return {number}
 */
proto.lnrpc.Hop.prototype.getChanCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.Hop.prototype.setChanCapacity = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 amt_to_forward = 3;
 * @return {number}
 */
proto.lnrpc.Hop.prototype.getAmtToForward = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.Hop.prototype.setAmtToForward = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 fee = 4;
 * @return {number}
 */
proto.lnrpc.Hop.prototype.getFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.Hop.prototype.setFee = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 expiry = 5;
 * @return {number}
 */
proto.lnrpc.Hop.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.Hop.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 amt_to_forward_m_atoms = 6;
 * @return {number}
 */
proto.lnrpc.Hop.prototype.getAmtToForwardMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.Hop.prototype.setAmtToForwardMAtoms = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 fee_m_atoms = 7;
 * @return {number}
 */
proto.lnrpc.Hop.prototype.getFeeMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.Hop.prototype.setFeeMAtoms = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional string pub_key = 8;
 * @return {string}
 */
proto.lnrpc.Hop.prototype.getPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.lnrpc.Hop.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional bool tlv_payload = 9;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Hop.prototype.getTlvPayload = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 9, false));
};


/** @param {boolean} value */
proto.lnrpc.Hop.prototype.setTlvPayload = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional MPPRecord mpp_record = 10;
 * @return {?proto.lnrpc.MPPRecord}
 */
proto.lnrpc.Hop.prototype.getMppRecord = function() {
  return /** @type{?proto.lnrpc.MPPRecord} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.MPPRecord, 10));
};


/** @param {?proto.lnrpc.MPPRecord|undefined} value */
proto.lnrpc.Hop.prototype.setMppRecord = function(value) {
  jspb.Message.setWrapperField(this, 10, value);
};


proto.lnrpc.Hop.prototype.clearMppRecord = function() {
  this.setMppRecord(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.Hop.prototype.hasMppRecord = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * map<uint64, bytes> custom_records = 11;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!(string|Uint8Array)>}
 */
proto.lnrpc.Hop.prototype.getCustomRecordsMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!(string|Uint8Array)>} */ (
      jspb.Message.getMapField(this, 11, opt_noLazyCreate,
      null));
};


proto.lnrpc.Hop.prototype.clearCustomRecordsMap = function() {
  this.getCustomRecordsMap().clear();
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.MPPRecord = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.MPPRecord, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.MPPRecord.displayName = 'proto.lnrpc.MPPRecord';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.MPPRecord.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.MPPRecord.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.MPPRecord} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.MPPRecord.toObject = function(includeInstance, msg) {
  var f, obj = {
    paymentAddr: msg.getPaymentAddr_asB64(),
    totalAmtMAtoms: jspb.Message.getFieldWithDefault(msg, 10, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.MPPRecord}
 */
proto.lnrpc.MPPRecord.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.MPPRecord;
  return proto.lnrpc.MPPRecord.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.MPPRecord} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.MPPRecord}
 */
proto.lnrpc.MPPRecord.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 11:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentAddr(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalAmtMAtoms(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.MPPRecord.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.MPPRecord.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.MPPRecord} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.MPPRecord.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPaymentAddr_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      11,
      f
    );
  }
  f = message.getTotalAmtMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
};


/**
 * optional bytes payment_addr = 11;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.MPPRecord.prototype.getPaymentAddr = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 11, ""));
};


/**
 * optional bytes payment_addr = 11;
 * This is a type-conversion wrapper around `getPaymentAddr()`
 * @return {string}
 */
proto.lnrpc.MPPRecord.prototype.getPaymentAddr_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentAddr()));
};


/**
 * optional bytes payment_addr = 11;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentAddr()`
 * @return {!Uint8Array}
 */
proto.lnrpc.MPPRecord.prototype.getPaymentAddr_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentAddr()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.MPPRecord.prototype.setPaymentAddr = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * optional int64 total_amt_m_atoms = 10;
 * @return {number}
 */
proto.lnrpc.MPPRecord.prototype.getTotalAmtMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.lnrpc.MPPRecord.prototype.setTotalAmtMAtoms = function(value) {
  jspb.Message.setField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Route = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.Route.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.Route, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Route.displayName = 'proto.lnrpc.Route';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.Route.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Route.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Route.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Route} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Route.toObject = function(includeInstance, msg) {
  var f, obj = {
    totalTimeLock: jspb.Message.getFieldWithDefault(msg, 1, 0),
    totalFees: jspb.Message.getFieldWithDefault(msg, 2, 0),
    totalAmt: jspb.Message.getFieldWithDefault(msg, 3, 0),
    hopsList: jspb.Message.toObjectList(msg.getHopsList(),
    proto.lnrpc.Hop.toObject, includeInstance),
    totalFeesMAtoms: jspb.Message.getFieldWithDefault(msg, 5, 0),
    totalAmtMAtoms: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Route}
 */
proto.lnrpc.Route.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Route;
  return proto.lnrpc.Route.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Route} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Route}
 */
proto.lnrpc.Route.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTotalTimeLock(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalFees(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalAmt(value);
      break;
    case 4:
      var value = new proto.lnrpc.Hop;
      reader.readMessage(value,proto.lnrpc.Hop.deserializeBinaryFromReader);
      msg.addHops(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalFeesMAtoms(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalAmtMAtoms(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Route.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Route.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Route} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Route.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTotalTimeLock();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getTotalFees();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getTotalAmt();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getHopsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.lnrpc.Hop.serializeBinaryToWriter
    );
  }
  f = message.getTotalFeesMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getTotalAmtMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
};


/**
 * optional uint32 total_time_lock = 1;
 * @return {number}
 */
proto.lnrpc.Route.prototype.getTotalTimeLock = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.Route.prototype.setTotalTimeLock = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 total_fees = 2;
 * @return {number}
 */
proto.lnrpc.Route.prototype.getTotalFees = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.Route.prototype.setTotalFees = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_amt = 3;
 * @return {number}
 */
proto.lnrpc.Route.prototype.getTotalAmt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.Route.prototype.setTotalAmt = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * repeated Hop hops = 4;
 * @return {!Array.<!proto.lnrpc.Hop>}
 */
proto.lnrpc.Route.prototype.getHopsList = function() {
  return /** @type{!Array.<!proto.lnrpc.Hop>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Hop, 4));
};


/** @param {!Array.<!proto.lnrpc.Hop>} value */
proto.lnrpc.Route.prototype.setHopsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.lnrpc.Hop=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Hop}
 */
proto.lnrpc.Route.prototype.addHops = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.lnrpc.Hop, opt_index);
};


proto.lnrpc.Route.prototype.clearHopsList = function() {
  this.setHopsList([]);
};


/**
 * optional int64 total_fees_m_atoms = 5;
 * @return {number}
 */
proto.lnrpc.Route.prototype.getTotalFeesMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.Route.prototype.setTotalFeesMAtoms = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 total_amt_m_atoms = 6;
 * @return {number}
 */
proto.lnrpc.Route.prototype.getTotalAmtMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.Route.prototype.setTotalAmtMAtoms = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NodeInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.NodeInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NodeInfoRequest.displayName = 'proto.lnrpc.NodeInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NodeInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NodeInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NodeInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodeInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    pubKey: jspb.Message.getFieldWithDefault(msg, 1, ""),
    includeChannels: jspb.Message.getFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NodeInfoRequest}
 */
proto.lnrpc.NodeInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NodeInfoRequest;
  return proto.lnrpc.NodeInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NodeInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NodeInfoRequest}
 */
proto.lnrpc.NodeInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKey(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeChannels(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NodeInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NodeInfoRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NodeInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodeInfoRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPubKey();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getIncludeChannels();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional string pub_key = 1;
 * @return {string}
 */
proto.lnrpc.NodeInfoRequest.prototype.getPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.NodeInfoRequest.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool include_channels = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.NodeInfoRequest.prototype.getIncludeChannels = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.lnrpc.NodeInfoRequest.prototype.setIncludeChannels = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NodeInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.NodeInfo.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.NodeInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NodeInfo.displayName = 'proto.lnrpc.NodeInfo';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.NodeInfo.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NodeInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NodeInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NodeInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodeInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    node: (f = msg.getNode()) && proto.lnrpc.LightningNode.toObject(includeInstance, f),
    numChannels: jspb.Message.getFieldWithDefault(msg, 2, 0),
    totalCapacity: jspb.Message.getFieldWithDefault(msg, 3, 0),
    channelsList: jspb.Message.toObjectList(msg.getChannelsList(),
    proto.lnrpc.ChannelEdge.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NodeInfo}
 */
proto.lnrpc.NodeInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NodeInfo;
  return proto.lnrpc.NodeInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NodeInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NodeInfo}
 */
proto.lnrpc.NodeInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.LightningNode;
      reader.readMessage(value,proto.lnrpc.LightningNode.deserializeBinaryFromReader);
      msg.setNode(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumChannels(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalCapacity(value);
      break;
    case 4:
      var value = new proto.lnrpc.ChannelEdge;
      reader.readMessage(value,proto.lnrpc.ChannelEdge.deserializeBinaryFromReader);
      msg.addChannels(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NodeInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NodeInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NodeInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodeInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNode();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.LightningNode.serializeBinaryToWriter
    );
  }
  f = message.getNumChannels();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getTotalCapacity();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getChannelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.lnrpc.ChannelEdge.serializeBinaryToWriter
    );
  }
};


/**
 * optional LightningNode node = 1;
 * @return {?proto.lnrpc.LightningNode}
 */
proto.lnrpc.NodeInfo.prototype.getNode = function() {
  return /** @type{?proto.lnrpc.LightningNode} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.LightningNode, 1));
};


/** @param {?proto.lnrpc.LightningNode|undefined} value */
proto.lnrpc.NodeInfo.prototype.setNode = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.NodeInfo.prototype.clearNode = function() {
  this.setNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.NodeInfo.prototype.hasNode = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 num_channels = 2;
 * @return {number}
 */
proto.lnrpc.NodeInfo.prototype.getNumChannels = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.NodeInfo.prototype.setNumChannels = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_capacity = 3;
 * @return {number}
 */
proto.lnrpc.NodeInfo.prototype.getTotalCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.NodeInfo.prototype.setTotalCapacity = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * repeated ChannelEdge channels = 4;
 * @return {!Array.<!proto.lnrpc.ChannelEdge>}
 */
proto.lnrpc.NodeInfo.prototype.getChannelsList = function() {
  return /** @type{!Array.<!proto.lnrpc.ChannelEdge>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ChannelEdge, 4));
};


/** @param {!Array.<!proto.lnrpc.ChannelEdge>} value */
proto.lnrpc.NodeInfo.prototype.setChannelsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.lnrpc.ChannelEdge=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ChannelEdge}
 */
proto.lnrpc.NodeInfo.prototype.addChannels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.lnrpc.ChannelEdge, opt_index);
};


proto.lnrpc.NodeInfo.prototype.clearChannelsList = function() {
  this.setChannelsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.LightningNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.LightningNode.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.LightningNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.LightningNode.displayName = 'proto.lnrpc.LightningNode';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.LightningNode.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.LightningNode.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.LightningNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.LightningNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.LightningNode.toObject = function(includeInstance, msg) {
  var f, obj = {
    lastUpdate: jspb.Message.getFieldWithDefault(msg, 1, 0),
    pubKey: jspb.Message.getFieldWithDefault(msg, 2, ""),
    alias: jspb.Message.getFieldWithDefault(msg, 3, ""),
    addressesList: jspb.Message.toObjectList(msg.getAddressesList(),
    proto.lnrpc.NodeAddress.toObject, includeInstance),
    color: jspb.Message.getFieldWithDefault(msg, 5, ""),
    featuresMap: (f = msg.getFeaturesMap()) ? f.toObject(includeInstance, proto.lnrpc.Feature.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.LightningNode}
 */
proto.lnrpc.LightningNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.LightningNode;
  return proto.lnrpc.LightningNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.LightningNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.LightningNode}
 */
proto.lnrpc.LightningNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLastUpdate(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKey(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setAlias(value);
      break;
    case 4:
      var value = new proto.lnrpc.NodeAddress;
      reader.readMessage(value,proto.lnrpc.NodeAddress.deserializeBinaryFromReader);
      msg.addAddresses(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setColor(value);
      break;
    case 6:
      var value = msg.getFeaturesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint32, jspb.BinaryReader.prototype.readMessage, proto.lnrpc.Feature.deserializeBinaryFromReader);
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.LightningNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.LightningNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.LightningNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.LightningNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLastUpdate();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getPubKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAlias();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.lnrpc.NodeAddress.serializeBinaryToWriter
    );
  }
  f = message.getColor();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getFeaturesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(6, writer, jspb.BinaryWriter.prototype.writeUint32, jspb.BinaryWriter.prototype.writeMessage, proto.lnrpc.Feature.serializeBinaryToWriter);
  }
};


/**
 * optional uint32 last_update = 1;
 * @return {number}
 */
proto.lnrpc.LightningNode.prototype.getLastUpdate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.LightningNode.prototype.setLastUpdate = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string pub_key = 2;
 * @return {string}
 */
proto.lnrpc.LightningNode.prototype.getPubKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.LightningNode.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string alias = 3;
 * @return {string}
 */
proto.lnrpc.LightningNode.prototype.getAlias = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.lnrpc.LightningNode.prototype.setAlias = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * repeated NodeAddress addresses = 4;
 * @return {!Array.<!proto.lnrpc.NodeAddress>}
 */
proto.lnrpc.LightningNode.prototype.getAddressesList = function() {
  return /** @type{!Array.<!proto.lnrpc.NodeAddress>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.NodeAddress, 4));
};


/** @param {!Array.<!proto.lnrpc.NodeAddress>} value */
proto.lnrpc.LightningNode.prototype.setAddressesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.lnrpc.NodeAddress=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.NodeAddress}
 */
proto.lnrpc.LightningNode.prototype.addAddresses = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.lnrpc.NodeAddress, opt_index);
};


proto.lnrpc.LightningNode.prototype.clearAddressesList = function() {
  this.setAddressesList([]);
};


/**
 * optional string color = 5;
 * @return {string}
 */
proto.lnrpc.LightningNode.prototype.getColor = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.lnrpc.LightningNode.prototype.setColor = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * map<uint32, Feature> features = 6;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!proto.lnrpc.Feature>}
 */
proto.lnrpc.LightningNode.prototype.getFeaturesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!proto.lnrpc.Feature>} */ (
      jspb.Message.getMapField(this, 6, opt_noLazyCreate,
      proto.lnrpc.Feature));
};


proto.lnrpc.LightningNode.prototype.clearFeaturesMap = function() {
  this.getFeaturesMap().clear();
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NodeAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.NodeAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NodeAddress.displayName = 'proto.lnrpc.NodeAddress';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NodeAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NodeAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NodeAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodeAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    network: jspb.Message.getFieldWithDefault(msg, 1, ""),
    addr: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NodeAddress}
 */
proto.lnrpc.NodeAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NodeAddress;
  return proto.lnrpc.NodeAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NodeAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NodeAddress}
 */
proto.lnrpc.NodeAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setNetwork(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddr(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NodeAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NodeAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NodeAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodeAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNetwork();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAddr();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string network = 1;
 * @return {string}
 */
proto.lnrpc.NodeAddress.prototype.getNetwork = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.NodeAddress.prototype.setNetwork = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string addr = 2;
 * @return {string}
 */
proto.lnrpc.NodeAddress.prototype.getAddr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.NodeAddress.prototype.setAddr = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.RoutingPolicy = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.RoutingPolicy, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.RoutingPolicy.displayName = 'proto.lnrpc.RoutingPolicy';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.RoutingPolicy.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.RoutingPolicy.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.RoutingPolicy} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.RoutingPolicy.toObject = function(includeInstance, msg) {
  var f, obj = {
    timeLockDelta: jspb.Message.getFieldWithDefault(msg, 1, 0),
    minHtlc: jspb.Message.getFieldWithDefault(msg, 2, 0),
    feeBaseMAtoms: jspb.Message.getFieldWithDefault(msg, 3, 0),
    feeRateMilliMAtoms: jspb.Message.getFieldWithDefault(msg, 4, 0),
    disabled: jspb.Message.getFieldWithDefault(msg, 5, false),
    maxHtlcMAtoms: jspb.Message.getFieldWithDefault(msg, 6, 0),
    lastUpdate: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.RoutingPolicy}
 */
proto.lnrpc.RoutingPolicy.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.RoutingPolicy;
  return proto.lnrpc.RoutingPolicy.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.RoutingPolicy} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.RoutingPolicy}
 */
proto.lnrpc.RoutingPolicy.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTimeLockDelta(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMinHtlc(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeeBaseMAtoms(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeeRateMilliMAtoms(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisabled(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMaxHtlcMAtoms(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLastUpdate(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.RoutingPolicy.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.RoutingPolicy.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.RoutingPolicy} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.RoutingPolicy.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTimeLockDelta();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getMinHtlc();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getFeeBaseMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getFeeRateMilliMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getDisabled();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getMaxHtlcMAtoms();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
  f = message.getLastUpdate();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
};


/**
 * optional uint32 time_lock_delta = 1;
 * @return {number}
 */
proto.lnrpc.RoutingPolicy.prototype.getTimeLockDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.RoutingPolicy.prototype.setTimeLockDelta = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 min_htlc = 2;
 * @return {number}
 */
proto.lnrpc.RoutingPolicy.prototype.getMinHtlc = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.RoutingPolicy.prototype.setMinHtlc = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 fee_base_m_atoms = 3;
 * @return {number}
 */
proto.lnrpc.RoutingPolicy.prototype.getFeeBaseMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.RoutingPolicy.prototype.setFeeBaseMAtoms = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 fee_rate_milli_m_atoms = 4;
 * @return {number}
 */
proto.lnrpc.RoutingPolicy.prototype.getFeeRateMilliMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.RoutingPolicy.prototype.setFeeRateMilliMAtoms = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool disabled = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.RoutingPolicy.prototype.getDisabled = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.lnrpc.RoutingPolicy.prototype.setDisabled = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint64 max_htlc_m_atoms = 6;
 * @return {number}
 */
proto.lnrpc.RoutingPolicy.prototype.getMaxHtlcMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.RoutingPolicy.prototype.setMaxHtlcMAtoms = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint32 last_update = 7;
 * @return {number}
 */
proto.lnrpc.RoutingPolicy.prototype.getLastUpdate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.RoutingPolicy.prototype.setLastUpdate = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelEdge = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelEdge, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelEdge.displayName = 'proto.lnrpc.ChannelEdge';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelEdge.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelEdge.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelEdge} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelEdge.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelId: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    chanPoint: jspb.Message.getFieldWithDefault(msg, 2, ""),
    lastUpdate: jspb.Message.getFieldWithDefault(msg, 3, 0),
    node1Pub: jspb.Message.getFieldWithDefault(msg, 4, ""),
    node2Pub: jspb.Message.getFieldWithDefault(msg, 5, ""),
    capacity: jspb.Message.getFieldWithDefault(msg, 6, 0),
    node1Policy: (f = msg.getNode1Policy()) && proto.lnrpc.RoutingPolicy.toObject(includeInstance, f),
    node2Policy: (f = msg.getNode2Policy()) && proto.lnrpc.RoutingPolicy.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelEdge}
 */
proto.lnrpc.ChannelEdge.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelEdge;
  return proto.lnrpc.ChannelEdge.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelEdge} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelEdge}
 */
proto.lnrpc.ChannelEdge.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChannelId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setChanPoint(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLastUpdate(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setNode1Pub(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setNode2Pub(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCapacity(value);
      break;
    case 7:
      var value = new proto.lnrpc.RoutingPolicy;
      reader.readMessage(value,proto.lnrpc.RoutingPolicy.deserializeBinaryFromReader);
      msg.setNode1Policy(value);
      break;
    case 8:
      var value = new proto.lnrpc.RoutingPolicy;
      reader.readMessage(value,proto.lnrpc.RoutingPolicy.deserializeBinaryFromReader);
      msg.setNode2Policy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelEdge.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelEdge.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelEdge} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelEdge.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getChanPoint();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getLastUpdate();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getNode1Pub();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getNode2Pub();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getCapacity();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getNode1Policy();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.lnrpc.RoutingPolicy.serializeBinaryToWriter
    );
  }
  f = message.getNode2Policy();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.lnrpc.RoutingPolicy.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 channel_id = 1;
 * @return {string}
 */
proto.lnrpc.ChannelEdge.prototype.getChannelId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/** @param {string} value */
proto.lnrpc.ChannelEdge.prototype.setChannelId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string chan_point = 2;
 * @return {string}
 */
proto.lnrpc.ChannelEdge.prototype.getChanPoint = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelEdge.prototype.setChanPoint = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 last_update = 3;
 * @return {number}
 */
proto.lnrpc.ChannelEdge.prototype.getLastUpdate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelEdge.prototype.setLastUpdate = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string node1_pub = 4;
 * @return {string}
 */
proto.lnrpc.ChannelEdge.prototype.getNode1Pub = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelEdge.prototype.setNode1Pub = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string node2_pub = 5;
 * @return {string}
 */
proto.lnrpc.ChannelEdge.prototype.getNode2Pub = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelEdge.prototype.setNode2Pub = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 capacity = 6;
 * @return {number}
 */
proto.lnrpc.ChannelEdge.prototype.getCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelEdge.prototype.setCapacity = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional RoutingPolicy node1_policy = 7;
 * @return {?proto.lnrpc.RoutingPolicy}
 */
proto.lnrpc.ChannelEdge.prototype.getNode1Policy = function() {
  return /** @type{?proto.lnrpc.RoutingPolicy} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.RoutingPolicy, 7));
};


/** @param {?proto.lnrpc.RoutingPolicy|undefined} value */
proto.lnrpc.ChannelEdge.prototype.setNode1Policy = function(value) {
  jspb.Message.setWrapperField(this, 7, value);
};


proto.lnrpc.ChannelEdge.prototype.clearNode1Policy = function() {
  this.setNode1Policy(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelEdge.prototype.hasNode1Policy = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional RoutingPolicy node2_policy = 8;
 * @return {?proto.lnrpc.RoutingPolicy}
 */
proto.lnrpc.ChannelEdge.prototype.getNode2Policy = function() {
  return /** @type{?proto.lnrpc.RoutingPolicy} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.RoutingPolicy, 8));
};


/** @param {?proto.lnrpc.RoutingPolicy|undefined} value */
proto.lnrpc.ChannelEdge.prototype.setNode2Policy = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.lnrpc.ChannelEdge.prototype.clearNode2Policy = function() {
  this.setNode2Policy(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelEdge.prototype.hasNode2Policy = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelGraphRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelGraphRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelGraphRequest.displayName = 'proto.lnrpc.ChannelGraphRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelGraphRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelGraphRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelGraphRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelGraphRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    includeUnannounced: jspb.Message.getFieldWithDefault(msg, 1, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelGraphRequest}
 */
proto.lnrpc.ChannelGraphRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelGraphRequest;
  return proto.lnrpc.ChannelGraphRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelGraphRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelGraphRequest}
 */
proto.lnrpc.ChannelGraphRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeUnannounced(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelGraphRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelGraphRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelGraphRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelGraphRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIncludeUnannounced();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool include_unannounced = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ChannelGraphRequest.prototype.getIncludeUnannounced = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.ChannelGraphRequest.prototype.setIncludeUnannounced = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelGraph = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ChannelGraph.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ChannelGraph, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelGraph.displayName = 'proto.lnrpc.ChannelGraph';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ChannelGraph.repeatedFields_ = [1,2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelGraph.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelGraph.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelGraph} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelGraph.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodesList: jspb.Message.toObjectList(msg.getNodesList(),
    proto.lnrpc.LightningNode.toObject, includeInstance),
    edgesList: jspb.Message.toObjectList(msg.getEdgesList(),
    proto.lnrpc.ChannelEdge.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelGraph}
 */
proto.lnrpc.ChannelGraph.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelGraph;
  return proto.lnrpc.ChannelGraph.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelGraph} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelGraph}
 */
proto.lnrpc.ChannelGraph.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.LightningNode;
      reader.readMessage(value,proto.lnrpc.LightningNode.deserializeBinaryFromReader);
      msg.addNodes(value);
      break;
    case 2:
      var value = new proto.lnrpc.ChannelEdge;
      reader.readMessage(value,proto.lnrpc.ChannelEdge.deserializeBinaryFromReader);
      msg.addEdges(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelGraph.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelGraph.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelGraph} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelGraph.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.LightningNode.serializeBinaryToWriter
    );
  }
  f = message.getEdgesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.lnrpc.ChannelEdge.serializeBinaryToWriter
    );
  }
};


/**
 * repeated LightningNode nodes = 1;
 * @return {!Array.<!proto.lnrpc.LightningNode>}
 */
proto.lnrpc.ChannelGraph.prototype.getNodesList = function() {
  return /** @type{!Array.<!proto.lnrpc.LightningNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.LightningNode, 1));
};


/** @param {!Array.<!proto.lnrpc.LightningNode>} value */
proto.lnrpc.ChannelGraph.prototype.setNodesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.LightningNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.LightningNode}
 */
proto.lnrpc.ChannelGraph.prototype.addNodes = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.LightningNode, opt_index);
};


proto.lnrpc.ChannelGraph.prototype.clearNodesList = function() {
  this.setNodesList([]);
};


/**
 * repeated ChannelEdge edges = 2;
 * @return {!Array.<!proto.lnrpc.ChannelEdge>}
 */
proto.lnrpc.ChannelGraph.prototype.getEdgesList = function() {
  return /** @type{!Array.<!proto.lnrpc.ChannelEdge>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ChannelEdge, 2));
};


/** @param {!Array.<!proto.lnrpc.ChannelEdge>} value */
proto.lnrpc.ChannelGraph.prototype.setEdgesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.lnrpc.ChannelEdge=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ChannelEdge}
 */
proto.lnrpc.ChannelGraph.prototype.addEdges = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.lnrpc.ChannelEdge, opt_index);
};


proto.lnrpc.ChannelGraph.prototype.clearEdgesList = function() {
  this.setEdgesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChanInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChanInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChanInfoRequest.displayName = 'proto.lnrpc.ChanInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChanInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChanInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChanInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChanInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanId: jspb.Message.getFieldWithDefault(msg, 1, "0")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChanInfoRequest}
 */
proto.lnrpc.ChanInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChanInfoRequest;
  return proto.lnrpc.ChanInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChanInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChanInfoRequest}
 */
proto.lnrpc.ChanInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChanInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChanInfoRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChanInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChanInfoRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
};


/**
 * optional uint64 chan_id = 1;
 * @return {string}
 */
proto.lnrpc.ChanInfoRequest.prototype.getChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/** @param {string} value */
proto.lnrpc.ChanInfoRequest.prototype.setChanId = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NetworkInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.NetworkInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NetworkInfoRequest.displayName = 'proto.lnrpc.NetworkInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NetworkInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NetworkInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NetworkInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NetworkInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NetworkInfoRequest}
 */
proto.lnrpc.NetworkInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NetworkInfoRequest;
  return proto.lnrpc.NetworkInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NetworkInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NetworkInfoRequest}
 */
proto.lnrpc.NetworkInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NetworkInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NetworkInfoRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NetworkInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NetworkInfoRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NetworkInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.NetworkInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NetworkInfo.displayName = 'proto.lnrpc.NetworkInfo';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NetworkInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NetworkInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NetworkInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NetworkInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    graphDiameter: jspb.Message.getFieldWithDefault(msg, 1, 0),
    avgOutDegree: +jspb.Message.getFieldWithDefault(msg, 2, 0.0),
    maxOutDegree: jspb.Message.getFieldWithDefault(msg, 3, 0),
    numNodes: jspb.Message.getFieldWithDefault(msg, 4, 0),
    numChannels: jspb.Message.getFieldWithDefault(msg, 5, 0),
    totalNetworkCapacity: jspb.Message.getFieldWithDefault(msg, 6, 0),
    avgChannelSize: +jspb.Message.getFieldWithDefault(msg, 7, 0.0),
    minChannelSize: jspb.Message.getFieldWithDefault(msg, 8, 0),
    maxChannelSize: jspb.Message.getFieldWithDefault(msg, 9, 0),
    medianChannelSizeSat: jspb.Message.getFieldWithDefault(msg, 10, 0),
    numZombieChans: jspb.Message.getFieldWithDefault(msg, 11, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NetworkInfo}
 */
proto.lnrpc.NetworkInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NetworkInfo;
  return proto.lnrpc.NetworkInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NetworkInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NetworkInfo}
 */
proto.lnrpc.NetworkInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setGraphDiameter(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setAvgOutDegree(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMaxOutDegree(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumNodes(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumChannels(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalNetworkCapacity(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setAvgChannelSize(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMinChannelSize(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxChannelSize(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMedianChannelSizeSat(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNumZombieChans(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NetworkInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NetworkInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NetworkInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NetworkInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getGraphDiameter();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getAvgOutDegree();
  if (f !== 0.0) {
    writer.writeDouble(
      2,
      f
    );
  }
  f = message.getMaxOutDegree();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getNumNodes();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getNumChannels();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getTotalNetworkCapacity();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getAvgChannelSize();
  if (f !== 0.0) {
    writer.writeDouble(
      7,
      f
    );
  }
  f = message.getMinChannelSize();
  if (f !== 0) {
    writer.writeInt64(
      8,
      f
    );
  }
  f = message.getMaxChannelSize();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
  f = message.getMedianChannelSizeSat();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = message.getNumZombieChans();
  if (f !== 0) {
    writer.writeUint64(
      11,
      f
    );
  }
};


/**
 * optional uint32 graph_diameter = 1;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getGraphDiameter = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setGraphDiameter = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional double avg_out_degree = 2;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getAvgOutDegree = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 2, 0.0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setAvgOutDegree = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 max_out_degree = 3;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getMaxOutDegree = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setMaxOutDegree = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 num_nodes = 4;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getNumNodes = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setNumNodes = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 num_channels = 5;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getNumChannels = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setNumChannels = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 total_network_capacity = 6;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getTotalNetworkCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setTotalNetworkCapacity = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional double avg_channel_size = 7;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getAvgChannelSize = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 7, 0.0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setAvgChannelSize = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional int64 min_channel_size = 8;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getMinChannelSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setMinChannelSize = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional int64 max_channel_size = 9;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getMaxChannelSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setMaxChannelSize = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 median_channel_size_sat = 10;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getMedianChannelSizeSat = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setMedianChannelSizeSat = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional uint64 num_zombie_chans = 11;
 * @return {number}
 */
proto.lnrpc.NetworkInfo.prototype.getNumZombieChans = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.lnrpc.NetworkInfo.prototype.setNumZombieChans = function(value) {
  jspb.Message.setField(this, 11, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.StopRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.StopRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.StopRequest.displayName = 'proto.lnrpc.StopRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.StopRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.StopRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.StopRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.StopRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.StopRequest}
 */
proto.lnrpc.StopRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.StopRequest;
  return proto.lnrpc.StopRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.StopRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.StopRequest}
 */
proto.lnrpc.StopRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.StopRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.StopRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.StopRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.StopRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.StopResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.StopResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.StopResponse.displayName = 'proto.lnrpc.StopResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.StopResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.StopResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.StopResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.StopResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.StopResponse}
 */
proto.lnrpc.StopResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.StopResponse;
  return proto.lnrpc.StopResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.StopResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.StopResponse}
 */
proto.lnrpc.StopResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.StopResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.StopResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.StopResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.StopResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.GraphTopologySubscription = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.GraphTopologySubscription, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.GraphTopologySubscription.displayName = 'proto.lnrpc.GraphTopologySubscription';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.GraphTopologySubscription.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.GraphTopologySubscription.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.GraphTopologySubscription} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GraphTopologySubscription.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.GraphTopologySubscription}
 */
proto.lnrpc.GraphTopologySubscription.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.GraphTopologySubscription;
  return proto.lnrpc.GraphTopologySubscription.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.GraphTopologySubscription} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.GraphTopologySubscription}
 */
proto.lnrpc.GraphTopologySubscription.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.GraphTopologySubscription.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.GraphTopologySubscription.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.GraphTopologySubscription} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GraphTopologySubscription.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.GraphTopologyUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.GraphTopologyUpdate.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.GraphTopologyUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.GraphTopologyUpdate.displayName = 'proto.lnrpc.GraphTopologyUpdate';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.GraphTopologyUpdate.repeatedFields_ = [1,2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.GraphTopologyUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.GraphTopologyUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.GraphTopologyUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GraphTopologyUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodeUpdatesList: jspb.Message.toObjectList(msg.getNodeUpdatesList(),
    proto.lnrpc.NodeUpdate.toObject, includeInstance),
    channelUpdatesList: jspb.Message.toObjectList(msg.getChannelUpdatesList(),
    proto.lnrpc.ChannelEdgeUpdate.toObject, includeInstance),
    closedChansList: jspb.Message.toObjectList(msg.getClosedChansList(),
    proto.lnrpc.ClosedChannelUpdate.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.GraphTopologyUpdate}
 */
proto.lnrpc.GraphTopologyUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.GraphTopologyUpdate;
  return proto.lnrpc.GraphTopologyUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.GraphTopologyUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.GraphTopologyUpdate}
 */
proto.lnrpc.GraphTopologyUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.NodeUpdate;
      reader.readMessage(value,proto.lnrpc.NodeUpdate.deserializeBinaryFromReader);
      msg.addNodeUpdates(value);
      break;
    case 2:
      var value = new proto.lnrpc.ChannelEdgeUpdate;
      reader.readMessage(value,proto.lnrpc.ChannelEdgeUpdate.deserializeBinaryFromReader);
      msg.addChannelUpdates(value);
      break;
    case 3:
      var value = new proto.lnrpc.ClosedChannelUpdate;
      reader.readMessage(value,proto.lnrpc.ClosedChannelUpdate.deserializeBinaryFromReader);
      msg.addClosedChans(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.GraphTopologyUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.GraphTopologyUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.GraphTopologyUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.GraphTopologyUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodeUpdatesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.NodeUpdate.serializeBinaryToWriter
    );
  }
  f = message.getChannelUpdatesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.lnrpc.ChannelEdgeUpdate.serializeBinaryToWriter
    );
  }
  f = message.getClosedChansList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.lnrpc.ClosedChannelUpdate.serializeBinaryToWriter
    );
  }
};


/**
 * repeated NodeUpdate node_updates = 1;
 * @return {!Array.<!proto.lnrpc.NodeUpdate>}
 */
proto.lnrpc.GraphTopologyUpdate.prototype.getNodeUpdatesList = function() {
  return /** @type{!Array.<!proto.lnrpc.NodeUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.NodeUpdate, 1));
};


/** @param {!Array.<!proto.lnrpc.NodeUpdate>} value */
proto.lnrpc.GraphTopologyUpdate.prototype.setNodeUpdatesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.NodeUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.NodeUpdate}
 */
proto.lnrpc.GraphTopologyUpdate.prototype.addNodeUpdates = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.NodeUpdate, opt_index);
};


proto.lnrpc.GraphTopologyUpdate.prototype.clearNodeUpdatesList = function() {
  this.setNodeUpdatesList([]);
};


/**
 * repeated ChannelEdgeUpdate channel_updates = 2;
 * @return {!Array.<!proto.lnrpc.ChannelEdgeUpdate>}
 */
proto.lnrpc.GraphTopologyUpdate.prototype.getChannelUpdatesList = function() {
  return /** @type{!Array.<!proto.lnrpc.ChannelEdgeUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ChannelEdgeUpdate, 2));
};


/** @param {!Array.<!proto.lnrpc.ChannelEdgeUpdate>} value */
proto.lnrpc.GraphTopologyUpdate.prototype.setChannelUpdatesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.lnrpc.ChannelEdgeUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ChannelEdgeUpdate}
 */
proto.lnrpc.GraphTopologyUpdate.prototype.addChannelUpdates = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.lnrpc.ChannelEdgeUpdate, opt_index);
};


proto.lnrpc.GraphTopologyUpdate.prototype.clearChannelUpdatesList = function() {
  this.setChannelUpdatesList([]);
};


/**
 * repeated ClosedChannelUpdate closed_chans = 3;
 * @return {!Array.<!proto.lnrpc.ClosedChannelUpdate>}
 */
proto.lnrpc.GraphTopologyUpdate.prototype.getClosedChansList = function() {
  return /** @type{!Array.<!proto.lnrpc.ClosedChannelUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ClosedChannelUpdate, 3));
};


/** @param {!Array.<!proto.lnrpc.ClosedChannelUpdate>} value */
proto.lnrpc.GraphTopologyUpdate.prototype.setClosedChansList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.lnrpc.ClosedChannelUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ClosedChannelUpdate}
 */
proto.lnrpc.GraphTopologyUpdate.prototype.addClosedChans = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.lnrpc.ClosedChannelUpdate, opt_index);
};


proto.lnrpc.GraphTopologyUpdate.prototype.clearClosedChansList = function() {
  this.setClosedChansList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.NodeUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.NodeUpdate.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.NodeUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.NodeUpdate.displayName = 'proto.lnrpc.NodeUpdate';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.NodeUpdate.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.NodeUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.NodeUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.NodeUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodeUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressesList: jspb.Message.getRepeatedField(msg, 1),
    identityKey: jspb.Message.getFieldWithDefault(msg, 2, ""),
    globalFeatures: msg.getGlobalFeatures_asB64(),
    alias: jspb.Message.getFieldWithDefault(msg, 4, ""),
    color: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.NodeUpdate}
 */
proto.lnrpc.NodeUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.NodeUpdate;
  return proto.lnrpc.NodeUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.NodeUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.NodeUpdate}
 */
proto.lnrpc.NodeUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.addAddresses(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setIdentityKey(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setGlobalFeatures(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setAlias(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setColor(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.NodeUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.NodeUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.NodeUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.NodeUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      1,
      f
    );
  }
  f = message.getIdentityKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getGlobalFeatures_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getAlias();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getColor();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * repeated string addresses = 1;
 * @return {!Array.<string>}
 */
proto.lnrpc.NodeUpdate.prototype.getAddressesList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array.<string>} value */
proto.lnrpc.NodeUpdate.prototype.setAddressesList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.lnrpc.NodeUpdate.prototype.addAddresses = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.lnrpc.NodeUpdate.prototype.clearAddressesList = function() {
  this.setAddressesList([]);
};


/**
 * optional string identity_key = 2;
 * @return {string}
 */
proto.lnrpc.NodeUpdate.prototype.getIdentityKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.NodeUpdate.prototype.setIdentityKey = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes global_features = 3;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.NodeUpdate.prototype.getGlobalFeatures = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes global_features = 3;
 * This is a type-conversion wrapper around `getGlobalFeatures()`
 * @return {string}
 */
proto.lnrpc.NodeUpdate.prototype.getGlobalFeatures_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getGlobalFeatures()));
};


/**
 * optional bytes global_features = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getGlobalFeatures()`
 * @return {!Uint8Array}
 */
proto.lnrpc.NodeUpdate.prototype.getGlobalFeatures_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getGlobalFeatures()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.NodeUpdate.prototype.setGlobalFeatures = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string alias = 4;
 * @return {string}
 */
proto.lnrpc.NodeUpdate.prototype.getAlias = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.lnrpc.NodeUpdate.prototype.setAlias = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string color = 5;
 * @return {string}
 */
proto.lnrpc.NodeUpdate.prototype.getColor = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.lnrpc.NodeUpdate.prototype.setColor = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelEdgeUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelEdgeUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelEdgeUpdate.displayName = 'proto.lnrpc.ChannelEdgeUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelEdgeUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelEdgeUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelEdgeUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanId: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    chanPoint: (f = msg.getChanPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f),
    capacity: jspb.Message.getFieldWithDefault(msg, 3, 0),
    routingPolicy: (f = msg.getRoutingPolicy()) && proto.lnrpc.RoutingPolicy.toObject(includeInstance, f),
    advertisingNode: jspb.Message.getFieldWithDefault(msg, 5, ""),
    connectingNode: jspb.Message.getFieldWithDefault(msg, 6, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelEdgeUpdate}
 */
proto.lnrpc.ChannelEdgeUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelEdgeUpdate;
  return proto.lnrpc.ChannelEdgeUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelEdgeUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelEdgeUpdate}
 */
proto.lnrpc.ChannelEdgeUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanId(value);
      break;
    case 2:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChanPoint(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCapacity(value);
      break;
    case 4:
      var value = new proto.lnrpc.RoutingPolicy;
      reader.readMessage(value,proto.lnrpc.RoutingPolicy.deserializeBinaryFromReader);
      msg.setRoutingPolicy(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setAdvertisingNode(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setConnectingNode(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelEdgeUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelEdgeUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelEdgeUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getChanPoint();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
  f = message.getCapacity();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getRoutingPolicy();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.lnrpc.RoutingPolicy.serializeBinaryToWriter
    );
  }
  f = message.getAdvertisingNode();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getConnectingNode();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional uint64 chan_id = 1;
 * @return {string}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.getChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/** @param {string} value */
proto.lnrpc.ChannelEdgeUpdate.prototype.setChanId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional ChannelPoint chan_point = 2;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.getChanPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 2));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.ChannelEdgeUpdate.prototype.setChanPoint = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.lnrpc.ChannelEdgeUpdate.prototype.clearChanPoint = function() {
  this.setChanPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.hasChanPoint = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int64 capacity = 3;
 * @return {number}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.getCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelEdgeUpdate.prototype.setCapacity = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional RoutingPolicy routing_policy = 4;
 * @return {?proto.lnrpc.RoutingPolicy}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.getRoutingPolicy = function() {
  return /** @type{?proto.lnrpc.RoutingPolicy} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.RoutingPolicy, 4));
};


/** @param {?proto.lnrpc.RoutingPolicy|undefined} value */
proto.lnrpc.ChannelEdgeUpdate.prototype.setRoutingPolicy = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.lnrpc.ChannelEdgeUpdate.prototype.clearRoutingPolicy = function() {
  this.setRoutingPolicy(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.hasRoutingPolicy = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional string advertising_node = 5;
 * @return {string}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.getAdvertisingNode = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelEdgeUpdate.prototype.setAdvertisingNode = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional string connecting_node = 6;
 * @return {string}
 */
proto.lnrpc.ChannelEdgeUpdate.prototype.getConnectingNode = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelEdgeUpdate.prototype.setConnectingNode = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ClosedChannelUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ClosedChannelUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ClosedChannelUpdate.displayName = 'proto.lnrpc.ClosedChannelUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ClosedChannelUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ClosedChannelUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ClosedChannelUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ClosedChannelUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanId: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    capacity: jspb.Message.getFieldWithDefault(msg, 2, 0),
    closedHeight: jspb.Message.getFieldWithDefault(msg, 3, 0),
    chanPoint: (f = msg.getChanPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ClosedChannelUpdate}
 */
proto.lnrpc.ClosedChannelUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ClosedChannelUpdate;
  return proto.lnrpc.ClosedChannelUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ClosedChannelUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ClosedChannelUpdate}
 */
proto.lnrpc.ClosedChannelUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCapacity(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setClosedHeight(value);
      break;
    case 4:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChanPoint(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ClosedChannelUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ClosedChannelUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ClosedChannelUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ClosedChannelUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getCapacity();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getClosedHeight();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getChanPoint();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 chan_id = 1;
 * @return {string}
 */
proto.lnrpc.ClosedChannelUpdate.prototype.getChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/** @param {string} value */
proto.lnrpc.ClosedChannelUpdate.prototype.setChanId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 capacity = 2;
 * @return {number}
 */
proto.lnrpc.ClosedChannelUpdate.prototype.getCapacity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.ClosedChannelUpdate.prototype.setCapacity = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 closed_height = 3;
 * @return {number}
 */
proto.lnrpc.ClosedChannelUpdate.prototype.getClosedHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ClosedChannelUpdate.prototype.setClosedHeight = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional ChannelPoint chan_point = 4;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ClosedChannelUpdate.prototype.getChanPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 4));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.ClosedChannelUpdate.prototype.setChanPoint = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.lnrpc.ClosedChannelUpdate.prototype.clearChanPoint = function() {
  this.setChanPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ClosedChannelUpdate.prototype.hasChanPoint = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.HopHint = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.HopHint, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.HopHint.displayName = 'proto.lnrpc.HopHint';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.HopHint.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.HopHint.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.HopHint} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.HopHint.toObject = function(includeInstance, msg) {
  var f, obj = {
    nodeId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    chanId: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    feeBaseMAtoms: jspb.Message.getFieldWithDefault(msg, 3, 0),
    feeProportionalMillionths: jspb.Message.getFieldWithDefault(msg, 4, 0),
    cltvExpiryDelta: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.HopHint}
 */
proto.lnrpc.HopHint.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.HopHint;
  return proto.lnrpc.HopHint.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.HopHint} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.HopHint}
 */
proto.lnrpc.HopHint.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setNodeId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanId(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFeeBaseMAtoms(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFeeProportionalMillionths(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCltvExpiryDelta(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.HopHint.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.HopHint.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.HopHint} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.HopHint.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNodeId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      2,
      f
    );
  }
  f = message.getFeeBaseMAtoms();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getFeeProportionalMillionths();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getCltvExpiryDelta();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
};


/**
 * optional string node_id = 1;
 * @return {string}
 */
proto.lnrpc.HopHint.prototype.getNodeId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.HopHint.prototype.setNodeId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint64 chan_id = 2;
 * @return {string}
 */
proto.lnrpc.HopHint.prototype.getChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/** @param {string} value */
proto.lnrpc.HopHint.prototype.setChanId = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 fee_base_m_atoms = 3;
 * @return {number}
 */
proto.lnrpc.HopHint.prototype.getFeeBaseMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.HopHint.prototype.setFeeBaseMAtoms = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 fee_proportional_millionths = 4;
 * @return {number}
 */
proto.lnrpc.HopHint.prototype.getFeeProportionalMillionths = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.HopHint.prototype.setFeeProportionalMillionths = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 cltv_expiry_delta = 5;
 * @return {number}
 */
proto.lnrpc.HopHint.prototype.getCltvExpiryDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.HopHint.prototype.setCltvExpiryDelta = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.RouteHint = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.RouteHint.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.RouteHint, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.RouteHint.displayName = 'proto.lnrpc.RouteHint';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.RouteHint.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.RouteHint.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.RouteHint.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.RouteHint} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.RouteHint.toObject = function(includeInstance, msg) {
  var f, obj = {
    hopHintsList: jspb.Message.toObjectList(msg.getHopHintsList(),
    proto.lnrpc.HopHint.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.RouteHint}
 */
proto.lnrpc.RouteHint.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.RouteHint;
  return proto.lnrpc.RouteHint.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.RouteHint} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.RouteHint}
 */
proto.lnrpc.RouteHint.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.HopHint;
      reader.readMessage(value,proto.lnrpc.HopHint.deserializeBinaryFromReader);
      msg.addHopHints(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.RouteHint.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.RouteHint.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.RouteHint} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.RouteHint.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHopHintsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.HopHint.serializeBinaryToWriter
    );
  }
};


/**
 * repeated HopHint hop_hints = 1;
 * @return {!Array.<!proto.lnrpc.HopHint>}
 */
proto.lnrpc.RouteHint.prototype.getHopHintsList = function() {
  return /** @type{!Array.<!proto.lnrpc.HopHint>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.HopHint, 1));
};


/** @param {!Array.<!proto.lnrpc.HopHint>} value */
proto.lnrpc.RouteHint.prototype.setHopHintsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.HopHint=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.HopHint}
 */
proto.lnrpc.RouteHint.prototype.addHopHints = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.HopHint, opt_index);
};


proto.lnrpc.RouteHint.prototype.clearHopHintsList = function() {
  this.setHopHintsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Invoice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, 500, proto.lnrpc.Invoice.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.Invoice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Invoice.displayName = 'proto.lnrpc.Invoice';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.Invoice.repeatedFields_ = [14,22];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Invoice.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Invoice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Invoice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Invoice.toObject = function(includeInstance, msg) {
  var f, obj = {
    memo: jspb.Message.getFieldWithDefault(msg, 1, ""),
    rPreimage: msg.getRPreimage_asB64(),
    rHash: msg.getRHash_asB64(),
    value: jspb.Message.getFieldWithDefault(msg, 5, 0),
    valueMAtoms: jspb.Message.getFieldWithDefault(msg, 23, 0),
    settled: jspb.Message.getFieldWithDefault(msg, 6, false),
    creationDate: jspb.Message.getFieldWithDefault(msg, 7, 0),
    settleDate: jspb.Message.getFieldWithDefault(msg, 8, 0),
    paymentRequest: jspb.Message.getFieldWithDefault(msg, 9, ""),
    descriptionHash: msg.getDescriptionHash_asB64(),
    expiry: jspb.Message.getFieldWithDefault(msg, 11, 0),
    fallbackAddr: jspb.Message.getFieldWithDefault(msg, 12, ""),
    cltvExpiry: jspb.Message.getFieldWithDefault(msg, 13, 0),
    routeHintsList: jspb.Message.toObjectList(msg.getRouteHintsList(),
    proto.lnrpc.RouteHint.toObject, includeInstance),
    pb_private: jspb.Message.getFieldWithDefault(msg, 15, false),
    addIndex: jspb.Message.getFieldWithDefault(msg, 16, 0),
    settleIndex: jspb.Message.getFieldWithDefault(msg, 17, 0),
    amtPaid: jspb.Message.getFieldWithDefault(msg, 18, 0),
    amtPaidAtoms: jspb.Message.getFieldWithDefault(msg, 19, 0),
    amtPaidMAtoms: jspb.Message.getFieldWithDefault(msg, 20, 0),
    state: jspb.Message.getFieldWithDefault(msg, 21, 0),
    htlcsList: jspb.Message.toObjectList(msg.getHtlcsList(),
    proto.lnrpc.InvoiceHTLC.toObject, includeInstance),
    ignoreMaxInboundAmt: jspb.Message.getFieldWithDefault(msg, 1001, false),
    featuresMap: (f = msg.getFeaturesMap()) ? f.toObject(includeInstance, proto.lnrpc.Feature.toObject) : [],
    isKeysend: jspb.Message.getFieldWithDefault(msg, 25, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Invoice}
 */
proto.lnrpc.Invoice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Invoice;
  return proto.lnrpc.Invoice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Invoice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Invoice}
 */
proto.lnrpc.Invoice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMemo(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRPreimage(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRHash(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setValue(value);
      break;
    case 23:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setValueMAtoms(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSettled(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCreationDate(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSettleDate(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentRequest(value);
      break;
    case 10:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDescriptionHash(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setExpiry(value);
      break;
    case 12:
      var value = /** @type {string} */ (reader.readString());
      msg.setFallbackAddr(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setCltvExpiry(value);
      break;
    case 14:
      var value = new proto.lnrpc.RouteHint;
      reader.readMessage(value,proto.lnrpc.RouteHint.deserializeBinaryFromReader);
      msg.addRouteHints(value);
      break;
    case 15:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPrivate(value);
      break;
    case 16:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAddIndex(value);
      break;
    case 17:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSettleIndex(value);
      break;
    case 18:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmtPaid(value);
      break;
    case 19:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmtPaidAtoms(value);
      break;
    case 20:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmtPaidMAtoms(value);
      break;
    case 21:
      var value = /** @type {!proto.lnrpc.Invoice.InvoiceState} */ (reader.readEnum());
      msg.setState(value);
      break;
    case 22:
      var value = new proto.lnrpc.InvoiceHTLC;
      reader.readMessage(value,proto.lnrpc.InvoiceHTLC.deserializeBinaryFromReader);
      msg.addHtlcs(value);
      break;
    case 1001:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIgnoreMaxInboundAmt(value);
      break;
    case 24:
      var value = msg.getFeaturesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint32, jspb.BinaryReader.prototype.readMessage, proto.lnrpc.Feature.deserializeBinaryFromReader);
         });
      break;
    case 25:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsKeysend(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Invoice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Invoice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Invoice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Invoice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMemo();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getRPreimage_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getRHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getValue();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getValueMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      23,
      f
    );
  }
  f = message.getSettled();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getCreationDate();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getSettleDate();
  if (f !== 0) {
    writer.writeInt64(
      8,
      f
    );
  }
  f = message.getPaymentRequest();
  if (f.length > 0) {
    writer.writeString(
      9,
      f
    );
  }
  f = message.getDescriptionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      10,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeInt64(
      11,
      f
    );
  }
  f = message.getFallbackAddr();
  if (f.length > 0) {
    writer.writeString(
      12,
      f
    );
  }
  f = message.getCltvExpiry();
  if (f !== 0) {
    writer.writeUint64(
      13,
      f
    );
  }
  f = message.getRouteHintsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      14,
      f,
      proto.lnrpc.RouteHint.serializeBinaryToWriter
    );
  }
  f = message.getPrivate();
  if (f) {
    writer.writeBool(
      15,
      f
    );
  }
  f = message.getAddIndex();
  if (f !== 0) {
    writer.writeUint64(
      16,
      f
    );
  }
  f = message.getSettleIndex();
  if (f !== 0) {
    writer.writeUint64(
      17,
      f
    );
  }
  f = message.getAmtPaid();
  if (f !== 0) {
    writer.writeInt64(
      18,
      f
    );
  }
  f = message.getAmtPaidAtoms();
  if (f !== 0) {
    writer.writeInt64(
      19,
      f
    );
  }
  f = message.getAmtPaidMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      20,
      f
    );
  }
  f = message.getState();
  if (f !== 0.0) {
    writer.writeEnum(
      21,
      f
    );
  }
  f = message.getHtlcsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      22,
      f,
      proto.lnrpc.InvoiceHTLC.serializeBinaryToWriter
    );
  }
  f = message.getIgnoreMaxInboundAmt();
  if (f) {
    writer.writeBool(
      1001,
      f
    );
  }
  f = message.getFeaturesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(24, writer, jspb.BinaryWriter.prototype.writeUint32, jspb.BinaryWriter.prototype.writeMessage, proto.lnrpc.Feature.serializeBinaryToWriter);
  }
  f = message.getIsKeysend();
  if (f) {
    writer.writeBool(
      25,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.lnrpc.Invoice.InvoiceState = {
  OPEN: 0,
  SETTLED: 1,
  CANCELED: 2,
  ACCEPTED: 3
};

/**
 * optional string memo = 1;
 * @return {string}
 */
proto.lnrpc.Invoice.prototype.getMemo = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.Invoice.prototype.setMemo = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes r_preimage = 3;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.Invoice.prototype.getRPreimage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes r_preimage = 3;
 * This is a type-conversion wrapper around `getRPreimage()`
 * @return {string}
 */
proto.lnrpc.Invoice.prototype.getRPreimage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRPreimage()));
};


/**
 * optional bytes r_preimage = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRPreimage()`
 * @return {!Uint8Array}
 */
proto.lnrpc.Invoice.prototype.getRPreimage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRPreimage()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.Invoice.prototype.setRPreimage = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes r_hash = 4;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.Invoice.prototype.getRHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes r_hash = 4;
 * This is a type-conversion wrapper around `getRHash()`
 * @return {string}
 */
proto.lnrpc.Invoice.prototype.getRHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRHash()));
};


/**
 * optional bytes r_hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRHash()`
 * @return {!Uint8Array}
 */
proto.lnrpc.Invoice.prototype.getRHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.Invoice.prototype.setRHash = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 value = 5;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setValue = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 value_m_atoms = 23;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getValueMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 23, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setValueMAtoms = function(value) {
  jspb.Message.setField(this, 23, value);
};


/**
 * optional bool settled = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Invoice.prototype.getSettled = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.lnrpc.Invoice.prototype.setSettled = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 creation_date = 7;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getCreationDate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setCreationDate = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional int64 settle_date = 8;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getSettleDate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setSettleDate = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional string payment_request = 9;
 * @return {string}
 */
proto.lnrpc.Invoice.prototype.getPaymentRequest = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/** @param {string} value */
proto.lnrpc.Invoice.prototype.setPaymentRequest = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional bytes description_hash = 10;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.Invoice.prototype.getDescriptionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 10, ""));
};


/**
 * optional bytes description_hash = 10;
 * This is a type-conversion wrapper around `getDescriptionHash()`
 * @return {string}
 */
proto.lnrpc.Invoice.prototype.getDescriptionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDescriptionHash()));
};


/**
 * optional bytes description_hash = 10;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDescriptionHash()`
 * @return {!Uint8Array}
 */
proto.lnrpc.Invoice.prototype.getDescriptionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDescriptionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.Invoice.prototype.setDescriptionHash = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int64 expiry = 11;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * optional string fallback_addr = 12;
 * @return {string}
 */
proto.lnrpc.Invoice.prototype.getFallbackAddr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 12, ""));
};


/** @param {string} value */
proto.lnrpc.Invoice.prototype.setFallbackAddr = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * optional uint64 cltv_expiry = 13;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getCltvExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setCltvExpiry = function(value) {
  jspb.Message.setField(this, 13, value);
};


/**
 * repeated RouteHint route_hints = 14;
 * @return {!Array.<!proto.lnrpc.RouteHint>}
 */
proto.lnrpc.Invoice.prototype.getRouteHintsList = function() {
  return /** @type{!Array.<!proto.lnrpc.RouteHint>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.RouteHint, 14));
};


/** @param {!Array.<!proto.lnrpc.RouteHint>} value */
proto.lnrpc.Invoice.prototype.setRouteHintsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 14, value);
};


/**
 * @param {!proto.lnrpc.RouteHint=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.RouteHint}
 */
proto.lnrpc.Invoice.prototype.addRouteHints = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 14, opt_value, proto.lnrpc.RouteHint, opt_index);
};


proto.lnrpc.Invoice.prototype.clearRouteHintsList = function() {
  this.setRouteHintsList([]);
};


/**
 * optional bool private = 15;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Invoice.prototype.getPrivate = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 15, false));
};


/** @param {boolean} value */
proto.lnrpc.Invoice.prototype.setPrivate = function(value) {
  jspb.Message.setField(this, 15, value);
};


/**
 * optional uint64 add_index = 16;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getAddIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 16, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setAddIndex = function(value) {
  jspb.Message.setField(this, 16, value);
};


/**
 * optional uint64 settle_index = 17;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getSettleIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 17, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setSettleIndex = function(value) {
  jspb.Message.setField(this, 17, value);
};


/**
 * optional int64 amt_paid = 18;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getAmtPaid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 18, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setAmtPaid = function(value) {
  jspb.Message.setField(this, 18, value);
};


/**
 * optional int64 amt_paid_atoms = 19;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getAmtPaidAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 19, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setAmtPaidAtoms = function(value) {
  jspb.Message.setField(this, 19, value);
};


/**
 * optional int64 amt_paid_m_atoms = 20;
 * @return {number}
 */
proto.lnrpc.Invoice.prototype.getAmtPaidMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 20, 0));
};


/** @param {number} value */
proto.lnrpc.Invoice.prototype.setAmtPaidMAtoms = function(value) {
  jspb.Message.setField(this, 20, value);
};


/**
 * optional InvoiceState state = 21;
 * @return {!proto.lnrpc.Invoice.InvoiceState}
 */
proto.lnrpc.Invoice.prototype.getState = function() {
  return /** @type {!proto.lnrpc.Invoice.InvoiceState} */ (jspb.Message.getFieldWithDefault(this, 21, 0));
};


/** @param {!proto.lnrpc.Invoice.InvoiceState} value */
proto.lnrpc.Invoice.prototype.setState = function(value) {
  jspb.Message.setField(this, 21, value);
};


/**
 * repeated InvoiceHTLC htlcs = 22;
 * @return {!Array.<!proto.lnrpc.InvoiceHTLC>}
 */
proto.lnrpc.Invoice.prototype.getHtlcsList = function() {
  return /** @type{!Array.<!proto.lnrpc.InvoiceHTLC>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.InvoiceHTLC, 22));
};


/** @param {!Array.<!proto.lnrpc.InvoiceHTLC>} value */
proto.lnrpc.Invoice.prototype.setHtlcsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 22, value);
};


/**
 * @param {!proto.lnrpc.InvoiceHTLC=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.InvoiceHTLC}
 */
proto.lnrpc.Invoice.prototype.addHtlcs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 22, opt_value, proto.lnrpc.InvoiceHTLC, opt_index);
};


proto.lnrpc.Invoice.prototype.clearHtlcsList = function() {
  this.setHtlcsList([]);
};


/**
 * optional bool ignore_max_inbound_amt = 1001;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Invoice.prototype.getIgnoreMaxInboundAmt = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1001, false));
};


/** @param {boolean} value */
proto.lnrpc.Invoice.prototype.setIgnoreMaxInboundAmt = function(value) {
  jspb.Message.setField(this, 1001, value);
};


/**
 * map<uint32, Feature> features = 24;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!proto.lnrpc.Feature>}
 */
proto.lnrpc.Invoice.prototype.getFeaturesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!proto.lnrpc.Feature>} */ (
      jspb.Message.getMapField(this, 24, opt_noLazyCreate,
      proto.lnrpc.Feature));
};


proto.lnrpc.Invoice.prototype.clearFeaturesMap = function() {
  this.getFeaturesMap().clear();
};


/**
 * optional bool is_keysend = 25;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Invoice.prototype.getIsKeysend = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 25, false));
};


/** @param {boolean} value */
proto.lnrpc.Invoice.prototype.setIsKeysend = function(value) {
  jspb.Message.setField(this, 25, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.InvoiceHTLC = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.InvoiceHTLC, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.InvoiceHTLC.displayName = 'proto.lnrpc.InvoiceHTLC';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.InvoiceHTLC.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.InvoiceHTLC.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.InvoiceHTLC} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.InvoiceHTLC.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanId: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    htlcIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    amtMAtoms: jspb.Message.getFieldWithDefault(msg, 3, 0),
    acceptHeight: jspb.Message.getFieldWithDefault(msg, 4, 0),
    acceptTime: jspb.Message.getFieldWithDefault(msg, 5, 0),
    resolveTime: jspb.Message.getFieldWithDefault(msg, 6, 0),
    expiryHeight: jspb.Message.getFieldWithDefault(msg, 7, 0),
    state: jspb.Message.getFieldWithDefault(msg, 8, 0),
    customRecordsMap: (f = msg.getCustomRecordsMap()) ? f.toObject(includeInstance, undefined) : [],
    mppTotalAmtMAtoms: jspb.Message.getFieldWithDefault(msg, 10, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.InvoiceHTLC}
 */
proto.lnrpc.InvoiceHTLC.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.InvoiceHTLC;
  return proto.lnrpc.InvoiceHTLC.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.InvoiceHTLC} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.InvoiceHTLC}
 */
proto.lnrpc.InvoiceHTLC.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setHtlcIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmtMAtoms(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAcceptHeight(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAcceptTime(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setResolveTime(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setExpiryHeight(value);
      break;
    case 8:
      var value = /** @type {!proto.lnrpc.InvoiceHTLCState} */ (reader.readEnum());
      msg.setState(value);
      break;
    case 9:
      var value = msg.getCustomRecordsMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint64, jspb.BinaryReader.prototype.readBytes);
         });
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMppTotalAmtMAtoms(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.InvoiceHTLC.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.InvoiceHTLC.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.InvoiceHTLC} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.InvoiceHTLC.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanId();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getHtlcIndex();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getAmtMAtoms();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getAcceptHeight();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getAcceptTime();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getResolveTime();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getExpiryHeight();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
  f = message.getState();
  if (f !== 0.0) {
    writer.writeEnum(
      8,
      f
    );
  }
  f = message.getCustomRecordsMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(9, writer, jspb.BinaryWriter.prototype.writeUint64, jspb.BinaryWriter.prototype.writeBytes);
  }
  f = message.getMppTotalAmtMAtoms();
  if (f !== 0) {
    writer.writeUint64(
      10,
      f
    );
  }
};


/**
 * optional uint64 chan_id = 1;
 * @return {string}
 */
proto.lnrpc.InvoiceHTLC.prototype.getChanId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/** @param {string} value */
proto.lnrpc.InvoiceHTLC.prototype.setChanId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint64 htlc_index = 2;
 * @return {number}
 */
proto.lnrpc.InvoiceHTLC.prototype.getHtlcIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceHTLC.prototype.setHtlcIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint64 amt_m_atoms = 3;
 * @return {number}
 */
proto.lnrpc.InvoiceHTLC.prototype.getAmtMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceHTLC.prototype.setAmtMAtoms = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 accept_height = 4;
 * @return {number}
 */
proto.lnrpc.InvoiceHTLC.prototype.getAcceptHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceHTLC.prototype.setAcceptHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 accept_time = 5;
 * @return {number}
 */
proto.lnrpc.InvoiceHTLC.prototype.getAcceptTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceHTLC.prototype.setAcceptTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 resolve_time = 6;
 * @return {number}
 */
proto.lnrpc.InvoiceHTLC.prototype.getResolveTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceHTLC.prototype.setResolveTime = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int32 expiry_height = 7;
 * @return {number}
 */
proto.lnrpc.InvoiceHTLC.prototype.getExpiryHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceHTLC.prototype.setExpiryHeight = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional InvoiceHTLCState state = 8;
 * @return {!proto.lnrpc.InvoiceHTLCState}
 */
proto.lnrpc.InvoiceHTLC.prototype.getState = function() {
  return /** @type {!proto.lnrpc.InvoiceHTLCState} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {!proto.lnrpc.InvoiceHTLCState} value */
proto.lnrpc.InvoiceHTLC.prototype.setState = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * map<uint64, bytes> custom_records = 9;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!(string|Uint8Array)>}
 */
proto.lnrpc.InvoiceHTLC.prototype.getCustomRecordsMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!(string|Uint8Array)>} */ (
      jspb.Message.getMapField(this, 9, opt_noLazyCreate,
      null));
};


proto.lnrpc.InvoiceHTLC.prototype.clearCustomRecordsMap = function() {
  this.getCustomRecordsMap().clear();
};


/**
 * optional uint64 mpp_total_amt_m_atoms = 10;
 * @return {number}
 */
proto.lnrpc.InvoiceHTLC.prototype.getMppTotalAmtMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceHTLC.prototype.setMppTotalAmtMAtoms = function(value) {
  jspb.Message.setField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.AddInvoiceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.AddInvoiceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.AddInvoiceResponse.displayName = 'proto.lnrpc.AddInvoiceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.AddInvoiceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.AddInvoiceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.AddInvoiceResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.AddInvoiceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    rHash: msg.getRHash_asB64(),
    paymentRequest: jspb.Message.getFieldWithDefault(msg, 2, ""),
    addIndex: jspb.Message.getFieldWithDefault(msg, 16, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.AddInvoiceResponse}
 */
proto.lnrpc.AddInvoiceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.AddInvoiceResponse;
  return proto.lnrpc.AddInvoiceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.AddInvoiceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.AddInvoiceResponse}
 */
proto.lnrpc.AddInvoiceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRHash(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentRequest(value);
      break;
    case 16:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAddIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.AddInvoiceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.AddInvoiceResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.AddInvoiceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.AddInvoiceResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPaymentRequest();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAddIndex();
  if (f !== 0) {
    writer.writeUint64(
      16,
      f
    );
  }
};


/**
 * optional bytes r_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.AddInvoiceResponse.prototype.getRHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes r_hash = 1;
 * This is a type-conversion wrapper around `getRHash()`
 * @return {string}
 */
proto.lnrpc.AddInvoiceResponse.prototype.getRHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRHash()));
};


/**
 * optional bytes r_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRHash()`
 * @return {!Uint8Array}
 */
proto.lnrpc.AddInvoiceResponse.prototype.getRHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.AddInvoiceResponse.prototype.setRHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string payment_request = 2;
 * @return {string}
 */
proto.lnrpc.AddInvoiceResponse.prototype.getPaymentRequest = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.AddInvoiceResponse.prototype.setPaymentRequest = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint64 add_index = 16;
 * @return {number}
 */
proto.lnrpc.AddInvoiceResponse.prototype.getAddIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 16, 0));
};


/** @param {number} value */
proto.lnrpc.AddInvoiceResponse.prototype.setAddIndex = function(value) {
  jspb.Message.setField(this, 16, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PaymentHash = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PaymentHash, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PaymentHash.displayName = 'proto.lnrpc.PaymentHash';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PaymentHash.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PaymentHash.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PaymentHash} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PaymentHash.toObject = function(includeInstance, msg) {
  var f, obj = {
    rHashStr: jspb.Message.getFieldWithDefault(msg, 1, ""),
    rHash: msg.getRHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PaymentHash}
 */
proto.lnrpc.PaymentHash.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PaymentHash;
  return proto.lnrpc.PaymentHash.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PaymentHash} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PaymentHash}
 */
proto.lnrpc.PaymentHash.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setRHashStr(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PaymentHash.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PaymentHash.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PaymentHash} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PaymentHash.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRHashStr();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getRHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional string r_hash_str = 1;
 * @return {string}
 */
proto.lnrpc.PaymentHash.prototype.getRHashStr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.PaymentHash.prototype.setRHashStr = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes r_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.PaymentHash.prototype.getRHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes r_hash = 2;
 * This is a type-conversion wrapper around `getRHash()`
 * @return {string}
 */
proto.lnrpc.PaymentHash.prototype.getRHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRHash()));
};


/**
 * optional bytes r_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRHash()`
 * @return {!Uint8Array}
 */
proto.lnrpc.PaymentHash.prototype.getRHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.PaymentHash.prototype.setRHash = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListInvoiceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ListInvoiceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListInvoiceRequest.displayName = 'proto.lnrpc.ListInvoiceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListInvoiceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListInvoiceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListInvoiceRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListInvoiceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    pendingOnly: jspb.Message.getFieldWithDefault(msg, 1, false),
    indexOffset: jspb.Message.getFieldWithDefault(msg, 4, 0),
    numMaxInvoices: jspb.Message.getFieldWithDefault(msg, 5, 0),
    reversed: jspb.Message.getFieldWithDefault(msg, 6, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListInvoiceRequest}
 */
proto.lnrpc.ListInvoiceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListInvoiceRequest;
  return proto.lnrpc.ListInvoiceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListInvoiceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListInvoiceRequest}
 */
proto.lnrpc.ListInvoiceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPendingOnly(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setIndexOffset(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setNumMaxInvoices(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setReversed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListInvoiceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListInvoiceRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListInvoiceRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListInvoiceRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPendingOnly();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getIndexOffset();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = message.getNumMaxInvoices();
  if (f !== 0) {
    writer.writeUint64(
      5,
      f
    );
  }
  f = message.getReversed();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
};


/**
 * optional bool pending_only = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ListInvoiceRequest.prototype.getPendingOnly = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.ListInvoiceRequest.prototype.setPendingOnly = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint64 index_offset = 4;
 * @return {number}
 */
proto.lnrpc.ListInvoiceRequest.prototype.getIndexOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.ListInvoiceRequest.prototype.setIndexOffset = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint64 num_max_invoices = 5;
 * @return {number}
 */
proto.lnrpc.ListInvoiceRequest.prototype.getNumMaxInvoices = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.ListInvoiceRequest.prototype.setNumMaxInvoices = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool reversed = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ListInvoiceRequest.prototype.getReversed = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.lnrpc.ListInvoiceRequest.prototype.setReversed = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListInvoiceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ListInvoiceResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ListInvoiceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListInvoiceResponse.displayName = 'proto.lnrpc.ListInvoiceResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ListInvoiceResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListInvoiceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListInvoiceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListInvoiceResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListInvoiceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    invoicesList: jspb.Message.toObjectList(msg.getInvoicesList(),
    proto.lnrpc.Invoice.toObject, includeInstance),
    lastIndexOffset: jspb.Message.getFieldWithDefault(msg, 2, 0),
    firstIndexOffset: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListInvoiceResponse}
 */
proto.lnrpc.ListInvoiceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListInvoiceResponse;
  return proto.lnrpc.ListInvoiceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListInvoiceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListInvoiceResponse}
 */
proto.lnrpc.ListInvoiceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.Invoice;
      reader.readMessage(value,proto.lnrpc.Invoice.deserializeBinaryFromReader);
      msg.addInvoices(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setLastIndexOffset(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFirstIndexOffset(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListInvoiceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListInvoiceResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListInvoiceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListInvoiceResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getInvoicesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.Invoice.serializeBinaryToWriter
    );
  }
  f = message.getLastIndexOffset();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getFirstIndexOffset();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
};


/**
 * repeated Invoice invoices = 1;
 * @return {!Array.<!proto.lnrpc.Invoice>}
 */
proto.lnrpc.ListInvoiceResponse.prototype.getInvoicesList = function() {
  return /** @type{!Array.<!proto.lnrpc.Invoice>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Invoice, 1));
};


/** @param {!Array.<!proto.lnrpc.Invoice>} value */
proto.lnrpc.ListInvoiceResponse.prototype.setInvoicesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.Invoice=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Invoice}
 */
proto.lnrpc.ListInvoiceResponse.prototype.addInvoices = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.Invoice, opt_index);
};


proto.lnrpc.ListInvoiceResponse.prototype.clearInvoicesList = function() {
  this.setInvoicesList([]);
};


/**
 * optional uint64 last_index_offset = 2;
 * @return {number}
 */
proto.lnrpc.ListInvoiceResponse.prototype.getLastIndexOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.ListInvoiceResponse.prototype.setLastIndexOffset = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint64 first_index_offset = 3;
 * @return {number}
 */
proto.lnrpc.ListInvoiceResponse.prototype.getFirstIndexOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ListInvoiceResponse.prototype.setFirstIndexOffset = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.InvoiceSubscription = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.InvoiceSubscription, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.InvoiceSubscription.displayName = 'proto.lnrpc.InvoiceSubscription';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.InvoiceSubscription.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.InvoiceSubscription.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.InvoiceSubscription} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.InvoiceSubscription.toObject = function(includeInstance, msg) {
  var f, obj = {
    addIndex: jspb.Message.getFieldWithDefault(msg, 1, 0),
    settleIndex: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.InvoiceSubscription}
 */
proto.lnrpc.InvoiceSubscription.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.InvoiceSubscription;
  return proto.lnrpc.InvoiceSubscription.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.InvoiceSubscription} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.InvoiceSubscription}
 */
proto.lnrpc.InvoiceSubscription.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAddIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSettleIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.InvoiceSubscription.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.InvoiceSubscription.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.InvoiceSubscription} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.InvoiceSubscription.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddIndex();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getSettleIndex();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
};


/**
 * optional uint64 add_index = 1;
 * @return {number}
 */
proto.lnrpc.InvoiceSubscription.prototype.getAddIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceSubscription.prototype.setAddIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint64 settle_index = 2;
 * @return {number}
 */
proto.lnrpc.InvoiceSubscription.prototype.getSettleIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.InvoiceSubscription.prototype.setSettleIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Payment = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.Payment.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.Payment, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Payment.displayName = 'proto.lnrpc.Payment';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.Payment.repeatedFields_ = [4,14];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Payment.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Payment.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Payment} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Payment.toObject = function(includeInstance, msg) {
  var f, obj = {
    paymentHash: jspb.Message.getFieldWithDefault(msg, 1, ""),
    value: jspb.Message.getFieldWithDefault(msg, 2, 0),
    creationDate: jspb.Message.getFieldWithDefault(msg, 3, 0),
    pathList: jspb.Message.getRepeatedField(msg, 4),
    fee: jspb.Message.getFieldWithDefault(msg, 5, 0),
    paymentPreimage: jspb.Message.getFieldWithDefault(msg, 6, ""),
    valueAtoms: jspb.Message.getFieldWithDefault(msg, 7, 0),
    valueMAtoms: jspb.Message.getFieldWithDefault(msg, 8, 0),
    paymentRequest: jspb.Message.getFieldWithDefault(msg, 9, ""),
    status: jspb.Message.getFieldWithDefault(msg, 10, 0),
    feeAtoms: jspb.Message.getFieldWithDefault(msg, 11, 0),
    feeMAtoms: jspb.Message.getFieldWithDefault(msg, 12, 0),
    creationTimeNs: jspb.Message.getFieldWithDefault(msg, 13, 0),
    htlcsList: jspb.Message.toObjectList(msg.getHtlcsList(),
    proto.lnrpc.HTLCAttempt.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Payment}
 */
proto.lnrpc.Payment.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Payment;
  return proto.lnrpc.Payment.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Payment} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Payment}
 */
proto.lnrpc.Payment.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setValue(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCreationDate(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.addPath(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFee(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentPreimage(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setValueAtoms(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setValueMAtoms(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentRequest(value);
      break;
    case 10:
      var value = /** @type {!proto.lnrpc.Payment.PaymentStatus} */ (reader.readEnum());
      msg.setStatus(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeeAtoms(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeeMAtoms(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCreationTimeNs(value);
      break;
    case 14:
      var value = new proto.lnrpc.HTLCAttempt;
      reader.readMessage(value,proto.lnrpc.HTLCAttempt.deserializeBinaryFromReader);
      msg.addHtlcs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Payment.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Payment.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Payment} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Payment.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPaymentHash();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getValue();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getCreationDate();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getPathList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      4,
      f
    );
  }
  f = message.getFee();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getPaymentPreimage();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = message.getValueAtoms();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getValueMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      8,
      f
    );
  }
  f = message.getPaymentRequest();
  if (f.length > 0) {
    writer.writeString(
      9,
      f
    );
  }
  f = message.getStatus();
  if (f !== 0.0) {
    writer.writeEnum(
      10,
      f
    );
  }
  f = message.getFeeAtoms();
  if (f !== 0) {
    writer.writeInt64(
      11,
      f
    );
  }
  f = message.getFeeMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      12,
      f
    );
  }
  f = message.getCreationTimeNs();
  if (f !== 0) {
    writer.writeInt64(
      13,
      f
    );
  }
  f = message.getHtlcsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      14,
      f,
      proto.lnrpc.HTLCAttempt.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.lnrpc.Payment.PaymentStatus = {
  UNKNOWN: 0,
  IN_FLIGHT: 1,
  SUCCEEDED: 2,
  FAILED: 3
};

/**
 * optional string payment_hash = 1;
 * @return {string}
 */
proto.lnrpc.Payment.prototype.getPaymentHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.Payment.prototype.setPaymentHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 value = 2;
 * @return {number}
 */
proto.lnrpc.Payment.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.Payment.prototype.setValue = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 creation_date = 3;
 * @return {number}
 */
proto.lnrpc.Payment.prototype.getCreationDate = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.Payment.prototype.setCreationDate = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * repeated string path = 4;
 * @return {!Array.<string>}
 */
proto.lnrpc.Payment.prototype.getPathList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 4));
};


/** @param {!Array.<string>} value */
proto.lnrpc.Payment.prototype.setPathList = function(value) {
  jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.lnrpc.Payment.prototype.addPath = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


proto.lnrpc.Payment.prototype.clearPathList = function() {
  this.setPathList([]);
};


/**
 * optional int64 fee = 5;
 * @return {number}
 */
proto.lnrpc.Payment.prototype.getFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.Payment.prototype.setFee = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional string payment_preimage = 6;
 * @return {string}
 */
proto.lnrpc.Payment.prototype.getPaymentPreimage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.lnrpc.Payment.prototype.setPaymentPreimage = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 value_atoms = 7;
 * @return {number}
 */
proto.lnrpc.Payment.prototype.getValueAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.Payment.prototype.setValueAtoms = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional int64 value_m_atoms = 8;
 * @return {number}
 */
proto.lnrpc.Payment.prototype.getValueMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.lnrpc.Payment.prototype.setValueMAtoms = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional string payment_request = 9;
 * @return {string}
 */
proto.lnrpc.Payment.prototype.getPaymentRequest = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/** @param {string} value */
proto.lnrpc.Payment.prototype.setPaymentRequest = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional PaymentStatus status = 10;
 * @return {!proto.lnrpc.Payment.PaymentStatus}
 */
proto.lnrpc.Payment.prototype.getStatus = function() {
  return /** @type {!proto.lnrpc.Payment.PaymentStatus} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {!proto.lnrpc.Payment.PaymentStatus} value */
proto.lnrpc.Payment.prototype.setStatus = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int64 fee_atoms = 11;
 * @return {number}
 */
proto.lnrpc.Payment.prototype.getFeeAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.lnrpc.Payment.prototype.setFeeAtoms = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * optional int64 fee_m_atoms = 12;
 * @return {number}
 */
proto.lnrpc.Payment.prototype.getFeeMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.lnrpc.Payment.prototype.setFeeMAtoms = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * optional int64 creation_time_ns = 13;
 * @return {number}
 */
proto.lnrpc.Payment.prototype.getCreationTimeNs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.lnrpc.Payment.prototype.setCreationTimeNs = function(value) {
  jspb.Message.setField(this, 13, value);
};


/**
 * repeated HTLCAttempt htlcs = 14;
 * @return {!Array.<!proto.lnrpc.HTLCAttempt>}
 */
proto.lnrpc.Payment.prototype.getHtlcsList = function() {
  return /** @type{!Array.<!proto.lnrpc.HTLCAttempt>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.HTLCAttempt, 14));
};


/** @param {!Array.<!proto.lnrpc.HTLCAttempt>} value */
proto.lnrpc.Payment.prototype.setHtlcsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 14, value);
};


/**
 * @param {!proto.lnrpc.HTLCAttempt=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.HTLCAttempt}
 */
proto.lnrpc.Payment.prototype.addHtlcs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 14, opt_value, proto.lnrpc.HTLCAttempt, opt_index);
};


proto.lnrpc.Payment.prototype.clearHtlcsList = function() {
  this.setHtlcsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.HTLCAttempt = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.HTLCAttempt, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.HTLCAttempt.displayName = 'proto.lnrpc.HTLCAttempt';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.HTLCAttempt.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.HTLCAttempt.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.HTLCAttempt} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.HTLCAttempt.toObject = function(includeInstance, msg) {
  var f, obj = {
    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
    route: (f = msg.getRoute()) && proto.lnrpc.Route.toObject(includeInstance, f),
    attemptTimeNs: jspb.Message.getFieldWithDefault(msg, 3, 0),
    resolveTimeNs: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.HTLCAttempt}
 */
proto.lnrpc.HTLCAttempt.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.HTLCAttempt;
  return proto.lnrpc.HTLCAttempt.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.HTLCAttempt} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.HTLCAttempt}
 */
proto.lnrpc.HTLCAttempt.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.lnrpc.HTLCAttempt.HTLCStatus} */ (reader.readEnum());
      msg.setStatus(value);
      break;
    case 2:
      var value = new proto.lnrpc.Route;
      reader.readMessage(value,proto.lnrpc.Route.deserializeBinaryFromReader);
      msg.setRoute(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAttemptTimeNs(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setResolveTimeNs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.HTLCAttempt.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.HTLCAttempt.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.HTLCAttempt} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.HTLCAttempt.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStatus();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getRoute();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.lnrpc.Route.serializeBinaryToWriter
    );
  }
  f = message.getAttemptTimeNs();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getResolveTimeNs();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.lnrpc.HTLCAttempt.HTLCStatus = {
  IN_FLIGHT: 0,
  SUCCEEDED: 1,
  FAILED: 2
};

/**
 * optional HTLCStatus status = 1;
 * @return {!proto.lnrpc.HTLCAttempt.HTLCStatus}
 */
proto.lnrpc.HTLCAttempt.prototype.getStatus = function() {
  return /** @type {!proto.lnrpc.HTLCAttempt.HTLCStatus} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.lnrpc.HTLCAttempt.HTLCStatus} value */
proto.lnrpc.HTLCAttempt.prototype.setStatus = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional Route route = 2;
 * @return {?proto.lnrpc.Route}
 */
proto.lnrpc.HTLCAttempt.prototype.getRoute = function() {
  return /** @type{?proto.lnrpc.Route} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.Route, 2));
};


/** @param {?proto.lnrpc.Route|undefined} value */
proto.lnrpc.HTLCAttempt.prototype.setRoute = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.lnrpc.HTLCAttempt.prototype.clearRoute = function() {
  this.setRoute(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.HTLCAttempt.prototype.hasRoute = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int64 attempt_time_ns = 3;
 * @return {number}
 */
proto.lnrpc.HTLCAttempt.prototype.getAttemptTimeNs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.HTLCAttempt.prototype.setAttemptTimeNs = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 resolve_time_ns = 4;
 * @return {number}
 */
proto.lnrpc.HTLCAttempt.prototype.getResolveTimeNs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.HTLCAttempt.prototype.setResolveTimeNs = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListPaymentsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ListPaymentsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListPaymentsRequest.displayName = 'proto.lnrpc.ListPaymentsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListPaymentsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListPaymentsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListPaymentsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListPaymentsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    includeIncomplete: jspb.Message.getFieldWithDefault(msg, 1, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListPaymentsRequest}
 */
proto.lnrpc.ListPaymentsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListPaymentsRequest;
  return proto.lnrpc.ListPaymentsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListPaymentsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListPaymentsRequest}
 */
proto.lnrpc.ListPaymentsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeIncomplete(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListPaymentsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListPaymentsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListPaymentsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListPaymentsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIncludeIncomplete();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool include_incomplete = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.ListPaymentsRequest.prototype.getIncludeIncomplete = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.ListPaymentsRequest.prototype.setIncludeIncomplete = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ListPaymentsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ListPaymentsResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ListPaymentsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ListPaymentsResponse.displayName = 'proto.lnrpc.ListPaymentsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ListPaymentsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ListPaymentsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ListPaymentsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ListPaymentsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListPaymentsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    paymentsList: jspb.Message.toObjectList(msg.getPaymentsList(),
    proto.lnrpc.Payment.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ListPaymentsResponse}
 */
proto.lnrpc.ListPaymentsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ListPaymentsResponse;
  return proto.lnrpc.ListPaymentsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ListPaymentsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ListPaymentsResponse}
 */
proto.lnrpc.ListPaymentsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.Payment;
      reader.readMessage(value,proto.lnrpc.Payment.deserializeBinaryFromReader);
      msg.addPayments(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ListPaymentsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ListPaymentsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ListPaymentsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ListPaymentsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPaymentsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.Payment.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Payment payments = 1;
 * @return {!Array.<!proto.lnrpc.Payment>}
 */
proto.lnrpc.ListPaymentsResponse.prototype.getPaymentsList = function() {
  return /** @type{!Array.<!proto.lnrpc.Payment>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.Payment, 1));
};


/** @param {!Array.<!proto.lnrpc.Payment>} value */
proto.lnrpc.ListPaymentsResponse.prototype.setPaymentsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.Payment=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.Payment}
 */
proto.lnrpc.ListPaymentsResponse.prototype.addPayments = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.Payment, opt_index);
};


proto.lnrpc.ListPaymentsResponse.prototype.clearPaymentsList = function() {
  this.setPaymentsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.DeleteAllPaymentsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.DeleteAllPaymentsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.DeleteAllPaymentsRequest.displayName = 'proto.lnrpc.DeleteAllPaymentsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.DeleteAllPaymentsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.DeleteAllPaymentsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.DeleteAllPaymentsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DeleteAllPaymentsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.DeleteAllPaymentsRequest}
 */
proto.lnrpc.DeleteAllPaymentsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.DeleteAllPaymentsRequest;
  return proto.lnrpc.DeleteAllPaymentsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.DeleteAllPaymentsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.DeleteAllPaymentsRequest}
 */
proto.lnrpc.DeleteAllPaymentsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.DeleteAllPaymentsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.DeleteAllPaymentsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.DeleteAllPaymentsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DeleteAllPaymentsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.DeleteAllPaymentsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.DeleteAllPaymentsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.DeleteAllPaymentsResponse.displayName = 'proto.lnrpc.DeleteAllPaymentsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.DeleteAllPaymentsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.DeleteAllPaymentsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.DeleteAllPaymentsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DeleteAllPaymentsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.DeleteAllPaymentsResponse}
 */
proto.lnrpc.DeleteAllPaymentsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.DeleteAllPaymentsResponse;
  return proto.lnrpc.DeleteAllPaymentsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.DeleteAllPaymentsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.DeleteAllPaymentsResponse}
 */
proto.lnrpc.DeleteAllPaymentsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.DeleteAllPaymentsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.DeleteAllPaymentsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.DeleteAllPaymentsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DeleteAllPaymentsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.AbandonChannelRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.AbandonChannelRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.AbandonChannelRequest.displayName = 'proto.lnrpc.AbandonChannelRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.AbandonChannelRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.AbandonChannelRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.AbandonChannelRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.AbandonChannelRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelPoint: (f = msg.getChannelPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.AbandonChannelRequest}
 */
proto.lnrpc.AbandonChannelRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.AbandonChannelRequest;
  return proto.lnrpc.AbandonChannelRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.AbandonChannelRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.AbandonChannelRequest}
 */
proto.lnrpc.AbandonChannelRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChannelPoint(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.AbandonChannelRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.AbandonChannelRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.AbandonChannelRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.AbandonChannelRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelPoint();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChannelPoint channel_point = 1;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.AbandonChannelRequest.prototype.getChannelPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 1));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.AbandonChannelRequest.prototype.setChannelPoint = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.AbandonChannelRequest.prototype.clearChannelPoint = function() {
  this.setChannelPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.AbandonChannelRequest.prototype.hasChannelPoint = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.AbandonChannelResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.AbandonChannelResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.AbandonChannelResponse.displayName = 'proto.lnrpc.AbandonChannelResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.AbandonChannelResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.AbandonChannelResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.AbandonChannelResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.AbandonChannelResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.AbandonChannelResponse}
 */
proto.lnrpc.AbandonChannelResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.AbandonChannelResponse;
  return proto.lnrpc.AbandonChannelResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.AbandonChannelResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.AbandonChannelResponse}
 */
proto.lnrpc.AbandonChannelResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.AbandonChannelResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.AbandonChannelResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.AbandonChannelResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.AbandonChannelResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.DebugLevelRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.DebugLevelRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.DebugLevelRequest.displayName = 'proto.lnrpc.DebugLevelRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.DebugLevelRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.DebugLevelRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.DebugLevelRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DebugLevelRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    show: jspb.Message.getFieldWithDefault(msg, 1, false),
    levelSpec: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.DebugLevelRequest}
 */
proto.lnrpc.DebugLevelRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.DebugLevelRequest;
  return proto.lnrpc.DebugLevelRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.DebugLevelRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.DebugLevelRequest}
 */
proto.lnrpc.DebugLevelRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setShow(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setLevelSpec(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.DebugLevelRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.DebugLevelRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.DebugLevelRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DebugLevelRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getShow();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getLevelSpec();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional bool show = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.DebugLevelRequest.prototype.getShow = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.DebugLevelRequest.prototype.setShow = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string level_spec = 2;
 * @return {string}
 */
proto.lnrpc.DebugLevelRequest.prototype.getLevelSpec = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.DebugLevelRequest.prototype.setLevelSpec = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.DebugLevelResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.DebugLevelResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.DebugLevelResponse.displayName = 'proto.lnrpc.DebugLevelResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.DebugLevelResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.DebugLevelResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.DebugLevelResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DebugLevelResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    subSystems: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.DebugLevelResponse}
 */
proto.lnrpc.DebugLevelResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.DebugLevelResponse;
  return proto.lnrpc.DebugLevelResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.DebugLevelResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.DebugLevelResponse}
 */
proto.lnrpc.DebugLevelResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSubSystems(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.DebugLevelResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.DebugLevelResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.DebugLevelResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.DebugLevelResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubSystems();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string sub_systems = 1;
 * @return {string}
 */
proto.lnrpc.DebugLevelResponse.prototype.getSubSystems = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.DebugLevelResponse.prototype.setSubSystems = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PayReqString = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PayReqString, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PayReqString.displayName = 'proto.lnrpc.PayReqString';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PayReqString.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PayReqString.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PayReqString} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PayReqString.toObject = function(includeInstance, msg) {
  var f, obj = {
    payReq: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PayReqString}
 */
proto.lnrpc.PayReqString.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PayReqString;
  return proto.lnrpc.PayReqString.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PayReqString} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PayReqString}
 */
proto.lnrpc.PayReqString.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPayReq(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PayReqString.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PayReqString.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PayReqString} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PayReqString.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPayReq();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string pay_req = 1;
 * @return {string}
 */
proto.lnrpc.PayReqString.prototype.getPayReq = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.PayReqString.prototype.setPayReq = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PayReq = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.PayReq.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.PayReq, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PayReq.displayName = 'proto.lnrpc.PayReq';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.PayReq.repeatedFields_ = [10];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PayReq.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PayReq.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PayReq} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PayReq.toObject = function(includeInstance, msg) {
  var f, obj = {
    destination: jspb.Message.getFieldWithDefault(msg, 1, ""),
    paymentHash: jspb.Message.getFieldWithDefault(msg, 2, ""),
    numAtoms: jspb.Message.getFieldWithDefault(msg, 3, 0),
    timestamp: jspb.Message.getFieldWithDefault(msg, 4, 0),
    expiry: jspb.Message.getFieldWithDefault(msg, 5, 0),
    description: jspb.Message.getFieldWithDefault(msg, 6, ""),
    descriptionHash: jspb.Message.getFieldWithDefault(msg, 7, ""),
    fallbackAddr: jspb.Message.getFieldWithDefault(msg, 8, ""),
    cltvExpiry: jspb.Message.getFieldWithDefault(msg, 9, 0),
    routeHintsList: jspb.Message.toObjectList(msg.getRouteHintsList(),
    proto.lnrpc.RouteHint.toObject, includeInstance),
    paymentAddr: msg.getPaymentAddr_asB64(),
    numMAtoms: jspb.Message.getFieldWithDefault(msg, 12, 0),
    featuresMap: (f = msg.getFeaturesMap()) ? f.toObject(includeInstance, proto.lnrpc.Feature.toObject) : []
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PayReq}
 */
proto.lnrpc.PayReq.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PayReq;
  return proto.lnrpc.PayReq.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PayReq} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PayReq}
 */
proto.lnrpc.PayReq.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setDestination(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPaymentHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setNumAtoms(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setExpiry(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setDescription(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setDescriptionHash(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setFallbackAddr(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCltvExpiry(value);
      break;
    case 10:
      var value = new proto.lnrpc.RouteHint;
      reader.readMessage(value,proto.lnrpc.RouteHint.deserializeBinaryFromReader);
      msg.addRouteHints(value);
      break;
    case 11:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentAddr(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setNumMAtoms(value);
      break;
    case 13:
      var value = msg.getFeaturesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readUint32, jspb.BinaryReader.prototype.readMessage, proto.lnrpc.Feature.deserializeBinaryFromReader);
         });
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PayReq.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PayReq.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PayReq} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PayReq.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDestination();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPaymentHash();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getNumAtoms();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getDescription();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = message.getDescriptionHash();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getFallbackAddr();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getCltvExpiry();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
  f = message.getRouteHintsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      10,
      f,
      proto.lnrpc.RouteHint.serializeBinaryToWriter
    );
  }
  f = message.getPaymentAddr_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      11,
      f
    );
  }
  f = message.getNumMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      12,
      f
    );
  }
  f = message.getFeaturesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(13, writer, jspb.BinaryWriter.prototype.writeUint32, jspb.BinaryWriter.prototype.writeMessage, proto.lnrpc.Feature.serializeBinaryToWriter);
  }
};


/**
 * optional string destination = 1;
 * @return {string}
 */
proto.lnrpc.PayReq.prototype.getDestination = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.PayReq.prototype.setDestination = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string payment_hash = 2;
 * @return {string}
 */
proto.lnrpc.PayReq.prototype.getPaymentHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.PayReq.prototype.setPaymentHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 num_atoms = 3;
 * @return {number}
 */
proto.lnrpc.PayReq.prototype.getNumAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.PayReq.prototype.setNumAtoms = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 timestamp = 4;
 * @return {number}
 */
proto.lnrpc.PayReq.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.PayReq.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 expiry = 5;
 * @return {number}
 */
proto.lnrpc.PayReq.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.PayReq.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional string description = 6;
 * @return {string}
 */
proto.lnrpc.PayReq.prototype.getDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.lnrpc.PayReq.prototype.setDescription = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional string description_hash = 7;
 * @return {string}
 */
proto.lnrpc.PayReq.prototype.getDescriptionHash = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/** @param {string} value */
proto.lnrpc.PayReq.prototype.setDescriptionHash = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional string fallback_addr = 8;
 * @return {string}
 */
proto.lnrpc.PayReq.prototype.getFallbackAddr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.lnrpc.PayReq.prototype.setFallbackAddr = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional int64 cltv_expiry = 9;
 * @return {number}
 */
proto.lnrpc.PayReq.prototype.getCltvExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.lnrpc.PayReq.prototype.setCltvExpiry = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * repeated RouteHint route_hints = 10;
 * @return {!Array.<!proto.lnrpc.RouteHint>}
 */
proto.lnrpc.PayReq.prototype.getRouteHintsList = function() {
  return /** @type{!Array.<!proto.lnrpc.RouteHint>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.RouteHint, 10));
};


/** @param {!Array.<!proto.lnrpc.RouteHint>} value */
proto.lnrpc.PayReq.prototype.setRouteHintsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 10, value);
};


/**
 * @param {!proto.lnrpc.RouteHint=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.RouteHint}
 */
proto.lnrpc.PayReq.prototype.addRouteHints = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 10, opt_value, proto.lnrpc.RouteHint, opt_index);
};


proto.lnrpc.PayReq.prototype.clearRouteHintsList = function() {
  this.setRouteHintsList([]);
};


/**
 * optional bytes payment_addr = 11;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.PayReq.prototype.getPaymentAddr = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 11, ""));
};


/**
 * optional bytes payment_addr = 11;
 * This is a type-conversion wrapper around `getPaymentAddr()`
 * @return {string}
 */
proto.lnrpc.PayReq.prototype.getPaymentAddr_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentAddr()));
};


/**
 * optional bytes payment_addr = 11;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentAddr()`
 * @return {!Uint8Array}
 */
proto.lnrpc.PayReq.prototype.getPaymentAddr_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentAddr()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.PayReq.prototype.setPaymentAddr = function(value) {
  jspb.Message.setField(this, 11, value);
};


/**
 * optional int64 num_m_atoms = 12;
 * @return {number}
 */
proto.lnrpc.PayReq.prototype.getNumMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.lnrpc.PayReq.prototype.setNumMAtoms = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * map<uint32, Feature> features = 13;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<number,!proto.lnrpc.Feature>}
 */
proto.lnrpc.PayReq.prototype.getFeaturesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<number,!proto.lnrpc.Feature>} */ (
      jspb.Message.getMapField(this, 13, opt_noLazyCreate,
      proto.lnrpc.Feature));
};


proto.lnrpc.PayReq.prototype.clearFeaturesMap = function() {
  this.getFeaturesMap().clear();
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.Feature = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.Feature, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.Feature.displayName = 'proto.lnrpc.Feature';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.Feature.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.Feature.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.Feature} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Feature.toObject = function(includeInstance, msg) {
  var f, obj = {
    name: jspb.Message.getFieldWithDefault(msg, 2, ""),
    isRequired: jspb.Message.getFieldWithDefault(msg, 3, false),
    isKnown: jspb.Message.getFieldWithDefault(msg, 4, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.Feature}
 */
proto.lnrpc.Feature.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.Feature;
  return proto.lnrpc.Feature.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.Feature} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.Feature}
 */
proto.lnrpc.Feature.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsRequired(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsKnown(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.Feature.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.Feature.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.Feature} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.Feature.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getIsRequired();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getIsKnown();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * optional string name = 2;
 * @return {string}
 */
proto.lnrpc.Feature.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.Feature.prototype.setName = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool is_required = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Feature.prototype.getIsRequired = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.lnrpc.Feature.prototype.setIsRequired = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool is_known = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.Feature.prototype.getIsKnown = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.lnrpc.Feature.prototype.setIsKnown = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.FeeReportRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.FeeReportRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.FeeReportRequest.displayName = 'proto.lnrpc.FeeReportRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.FeeReportRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.FeeReportRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.FeeReportRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FeeReportRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.FeeReportRequest}
 */
proto.lnrpc.FeeReportRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.FeeReportRequest;
  return proto.lnrpc.FeeReportRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.FeeReportRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.FeeReportRequest}
 */
proto.lnrpc.FeeReportRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.FeeReportRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.FeeReportRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.FeeReportRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FeeReportRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelFeeReport = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelFeeReport, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelFeeReport.displayName = 'proto.lnrpc.ChannelFeeReport';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelFeeReport.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelFeeReport.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelFeeReport} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelFeeReport.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanPoint: jspb.Message.getFieldWithDefault(msg, 1, ""),
    baseFeeMAtoms: jspb.Message.getFieldWithDefault(msg, 2, 0),
    feePerMil: jspb.Message.getFieldWithDefault(msg, 3, 0),
    feeRate: +jspb.Message.getFieldWithDefault(msg, 4, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelFeeReport}
 */
proto.lnrpc.ChannelFeeReport.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelFeeReport;
  return proto.lnrpc.ChannelFeeReport.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelFeeReport} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelFeeReport}
 */
proto.lnrpc.ChannelFeeReport.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setChanPoint(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBaseFeeMAtoms(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFeePerMil(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setFeeRate(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelFeeReport.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelFeeReport.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelFeeReport} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelFeeReport.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanPoint();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getBaseFeeMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getFeePerMil();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0.0) {
    writer.writeDouble(
      4,
      f
    );
  }
};


/**
 * optional string chan_point = 1;
 * @return {string}
 */
proto.lnrpc.ChannelFeeReport.prototype.getChanPoint = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.ChannelFeeReport.prototype.setChanPoint = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 base_fee_m_atoms = 2;
 * @return {number}
 */
proto.lnrpc.ChannelFeeReport.prototype.getBaseFeeMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelFeeReport.prototype.setBaseFeeMAtoms = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 fee_per_mil = 3;
 * @return {number}
 */
proto.lnrpc.ChannelFeeReport.prototype.getFeePerMil = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ChannelFeeReport.prototype.setFeePerMil = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional double fee_rate = 4;
 * @return {number}
 */
proto.lnrpc.ChannelFeeReport.prototype.getFeeRate = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.lnrpc.ChannelFeeReport.prototype.setFeeRate = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.FeeReportResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.FeeReportResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.FeeReportResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.FeeReportResponse.displayName = 'proto.lnrpc.FeeReportResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.FeeReportResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.FeeReportResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.FeeReportResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.FeeReportResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FeeReportResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    channelFeesList: jspb.Message.toObjectList(msg.getChannelFeesList(),
    proto.lnrpc.ChannelFeeReport.toObject, includeInstance),
    dayFeeSum: jspb.Message.getFieldWithDefault(msg, 2, 0),
    weekFeeSum: jspb.Message.getFieldWithDefault(msg, 3, 0),
    monthFeeSum: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.FeeReportResponse}
 */
proto.lnrpc.FeeReportResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.FeeReportResponse;
  return proto.lnrpc.FeeReportResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.FeeReportResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.FeeReportResponse}
 */
proto.lnrpc.FeeReportResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelFeeReport;
      reader.readMessage(value,proto.lnrpc.ChannelFeeReport.deserializeBinaryFromReader);
      msg.addChannelFees(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setDayFeeSum(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setWeekFeeSum(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMonthFeeSum(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.FeeReportResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.FeeReportResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.FeeReportResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.FeeReportResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChannelFeesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.ChannelFeeReport.serializeBinaryToWriter
    );
  }
  f = message.getDayFeeSum();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getWeekFeeSum();
  if (f !== 0) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = message.getMonthFeeSum();
  if (f !== 0) {
    writer.writeUint64(
      4,
      f
    );
  }
};


/**
 * repeated ChannelFeeReport channel_fees = 1;
 * @return {!Array.<!proto.lnrpc.ChannelFeeReport>}
 */
proto.lnrpc.FeeReportResponse.prototype.getChannelFeesList = function() {
  return /** @type{!Array.<!proto.lnrpc.ChannelFeeReport>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ChannelFeeReport, 1));
};


/** @param {!Array.<!proto.lnrpc.ChannelFeeReport>} value */
proto.lnrpc.FeeReportResponse.prototype.setChannelFeesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.ChannelFeeReport=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ChannelFeeReport}
 */
proto.lnrpc.FeeReportResponse.prototype.addChannelFees = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.ChannelFeeReport, opt_index);
};


proto.lnrpc.FeeReportResponse.prototype.clearChannelFeesList = function() {
  this.setChannelFeesList([]);
};


/**
 * optional uint64 day_fee_sum = 2;
 * @return {number}
 */
proto.lnrpc.FeeReportResponse.prototype.getDayFeeSum = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.FeeReportResponse.prototype.setDayFeeSum = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint64 week_fee_sum = 3;
 * @return {number}
 */
proto.lnrpc.FeeReportResponse.prototype.getWeekFeeSum = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.FeeReportResponse.prototype.setWeekFeeSum = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint64 month_fee_sum = 4;
 * @return {number}
 */
proto.lnrpc.FeeReportResponse.prototype.getMonthFeeSum = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.FeeReportResponse.prototype.setMonthFeeSum = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PolicyUpdateRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.PolicyUpdateRequest.oneofGroups_);
};
goog.inherits(proto.lnrpc.PolicyUpdateRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PolicyUpdateRequest.displayName = 'proto.lnrpc.PolicyUpdateRequest';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.PolicyUpdateRequest.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.lnrpc.PolicyUpdateRequest.ScopeCase = {
  SCOPE_NOT_SET: 0,
  GLOBAL: 1,
  CHAN_POINT: 2
};

/**
 * @return {proto.lnrpc.PolicyUpdateRequest.ScopeCase}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getScopeCase = function() {
  return /** @type {proto.lnrpc.PolicyUpdateRequest.ScopeCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.PolicyUpdateRequest.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PolicyUpdateRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PolicyUpdateRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PolicyUpdateRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    global: jspb.Message.getFieldWithDefault(msg, 1, false),
    chanPoint: (f = msg.getChanPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f),
    baseFeeMAtoms: jspb.Message.getFieldWithDefault(msg, 3, 0),
    feeRate: +jspb.Message.getFieldWithDefault(msg, 4, 0.0),
    timeLockDelta: jspb.Message.getFieldWithDefault(msg, 5, 0),
    maxHtlcMAtoms: jspb.Message.getFieldWithDefault(msg, 6, 0),
    minHtlcMAtoms: jspb.Message.getFieldWithDefault(msg, 7, 0),
    minHtlcMAtomsSpecified: jspb.Message.getFieldWithDefault(msg, 8, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PolicyUpdateRequest}
 */
proto.lnrpc.PolicyUpdateRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PolicyUpdateRequest;
  return proto.lnrpc.PolicyUpdateRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PolicyUpdateRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PolicyUpdateRequest}
 */
proto.lnrpc.PolicyUpdateRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setGlobal(value);
      break;
    case 2:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChanPoint(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBaseFeeMAtoms(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setFeeRate(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTimeLockDelta(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMaxHtlcMAtoms(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMinHtlcMAtoms(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setMinHtlcMAtomsSpecified(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PolicyUpdateRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PolicyUpdateRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PolicyUpdateRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getChanPoint();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
  f = message.getBaseFeeMAtoms();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getFeeRate();
  if (f !== 0.0) {
    writer.writeDouble(
      4,
      f
    );
  }
  f = message.getTimeLockDelta();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getMaxHtlcMAtoms();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
  f = message.getMinHtlcMAtoms();
  if (f !== 0) {
    writer.writeUint64(
      7,
      f
    );
  }
  f = message.getMinHtlcMAtomsSpecified();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
};


/**
 * optional bool global = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getGlobal = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.lnrpc.PolicyUpdateRequest.prototype.setGlobal = function(value) {
  jspb.Message.setOneofField(this, 1, proto.lnrpc.PolicyUpdateRequest.oneofGroups_[0], value);
};


proto.lnrpc.PolicyUpdateRequest.prototype.clearGlobal = function() {
  jspb.Message.setOneofField(this, 1, proto.lnrpc.PolicyUpdateRequest.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.hasGlobal = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ChannelPoint chan_point = 2;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getChanPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 2));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.PolicyUpdateRequest.prototype.setChanPoint = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.lnrpc.PolicyUpdateRequest.oneofGroups_[0], value);
};


proto.lnrpc.PolicyUpdateRequest.prototype.clearChanPoint = function() {
  this.setChanPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.hasChanPoint = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int64 base_fee_m_atoms = 3;
 * @return {number}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getBaseFeeMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.PolicyUpdateRequest.prototype.setBaseFeeMAtoms = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional double fee_rate = 4;
 * @return {number}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getFeeRate = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 4, 0.0));
};


/** @param {number} value */
proto.lnrpc.PolicyUpdateRequest.prototype.setFeeRate = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 time_lock_delta = 5;
 * @return {number}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getTimeLockDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.PolicyUpdateRequest.prototype.setTimeLockDelta = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint64 max_htlc_m_atoms = 6;
 * @return {number}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getMaxHtlcMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.PolicyUpdateRequest.prototype.setMaxHtlcMAtoms = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint64 min_htlc_m_atoms = 7;
 * @return {number}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getMinHtlcMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.PolicyUpdateRequest.prototype.setMinHtlcMAtoms = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional bool min_htlc_m_atoms_specified = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.lnrpc.PolicyUpdateRequest.prototype.getMinHtlcMAtomsSpecified = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.lnrpc.PolicyUpdateRequest.prototype.setMinHtlcMAtomsSpecified = function(value) {
  jspb.Message.setField(this, 8, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.PolicyUpdateResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.PolicyUpdateResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.PolicyUpdateResponse.displayName = 'proto.lnrpc.PolicyUpdateResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.PolicyUpdateResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.PolicyUpdateResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.PolicyUpdateResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PolicyUpdateResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.PolicyUpdateResponse}
 */
proto.lnrpc.PolicyUpdateResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.PolicyUpdateResponse;
  return proto.lnrpc.PolicyUpdateResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.PolicyUpdateResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.PolicyUpdateResponse}
 */
proto.lnrpc.PolicyUpdateResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.PolicyUpdateResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.PolicyUpdateResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.PolicyUpdateResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.PolicyUpdateResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ForwardingHistoryRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ForwardingHistoryRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ForwardingHistoryRequest.displayName = 'proto.lnrpc.ForwardingHistoryRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ForwardingHistoryRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ForwardingHistoryRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ForwardingHistoryRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ForwardingHistoryRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    startTime: jspb.Message.getFieldWithDefault(msg, 1, 0),
    endTime: jspb.Message.getFieldWithDefault(msg, 2, 0),
    indexOffset: jspb.Message.getFieldWithDefault(msg, 3, 0),
    numMaxEvents: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ForwardingHistoryRequest}
 */
proto.lnrpc.ForwardingHistoryRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ForwardingHistoryRequest;
  return proto.lnrpc.ForwardingHistoryRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ForwardingHistoryRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ForwardingHistoryRequest}
 */
proto.lnrpc.ForwardingHistoryRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setStartTime(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setEndTime(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndexOffset(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumMaxEvents(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ForwardingHistoryRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ForwardingHistoryRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ForwardingHistoryRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ForwardingHistoryRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStartTime();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getEndTime();
  if (f !== 0) {
    writer.writeUint64(
      2,
      f
    );
  }
  f = message.getIndexOffset();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getNumMaxEvents();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional uint64 start_time = 1;
 * @return {number}
 */
proto.lnrpc.ForwardingHistoryRequest.prototype.getStartTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingHistoryRequest.prototype.setStartTime = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint64 end_time = 2;
 * @return {number}
 */
proto.lnrpc.ForwardingHistoryRequest.prototype.getEndTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingHistoryRequest.prototype.setEndTime = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 index_offset = 3;
 * @return {number}
 */
proto.lnrpc.ForwardingHistoryRequest.prototype.getIndexOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingHistoryRequest.prototype.setIndexOffset = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 num_max_events = 4;
 * @return {number}
 */
proto.lnrpc.ForwardingHistoryRequest.prototype.getNumMaxEvents = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingHistoryRequest.prototype.setNumMaxEvents = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ForwardingEvent = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ForwardingEvent, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ForwardingEvent.displayName = 'proto.lnrpc.ForwardingEvent';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ForwardingEvent.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ForwardingEvent.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ForwardingEvent} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ForwardingEvent.toObject = function(includeInstance, msg) {
  var f, obj = {
    timestamp: jspb.Message.getFieldWithDefault(msg, 1, 0),
    chanIdIn: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    chanIdOut: jspb.Message.getFieldWithDefault(msg, 4, "0"),
    amtIn: jspb.Message.getFieldWithDefault(msg, 5, 0),
    amtOut: jspb.Message.getFieldWithDefault(msg, 6, 0),
    fee: jspb.Message.getFieldWithDefault(msg, 7, 0),
    feeMAtoms: jspb.Message.getFieldWithDefault(msg, 8, 0),
    amtInMAtoms: jspb.Message.getFieldWithDefault(msg, 9, 0),
    amtOutMAtoms: jspb.Message.getFieldWithDefault(msg, 10, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ForwardingEvent}
 */
proto.lnrpc.ForwardingEvent.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ForwardingEvent;
  return proto.lnrpc.ForwardingEvent.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ForwardingEvent} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ForwardingEvent}
 */
proto.lnrpc.ForwardingEvent.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setTimestamp(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanIdIn(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setChanIdOut(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmtIn(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmtOut(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFee(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setFeeMAtoms(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmtInMAtoms(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmtOutMAtoms(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ForwardingEvent.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ForwardingEvent.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ForwardingEvent} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ForwardingEvent.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getChanIdIn();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      2,
      f
    );
  }
  f = message.getChanIdOut();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      4,
      f
    );
  }
  f = message.getAmtIn();
  if (f !== 0) {
    writer.writeUint64(
      5,
      f
    );
  }
  f = message.getAmtOut();
  if (f !== 0) {
    writer.writeUint64(
      6,
      f
    );
  }
  f = message.getFee();
  if (f !== 0) {
    writer.writeUint64(
      7,
      f
    );
  }
  f = message.getFeeMAtoms();
  if (f !== 0) {
    writer.writeUint64(
      8,
      f
    );
  }
  f = message.getAmtInMAtoms();
  if (f !== 0) {
    writer.writeUint64(
      9,
      f
    );
  }
  f = message.getAmtOutMAtoms();
  if (f !== 0) {
    writer.writeUint64(
      10,
      f
    );
  }
};


/**
 * optional uint64 timestamp = 1;
 * @return {number}
 */
proto.lnrpc.ForwardingEvent.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingEvent.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint64 chan_id_in = 2;
 * @return {string}
 */
proto.lnrpc.ForwardingEvent.prototype.getChanIdIn = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/** @param {string} value */
proto.lnrpc.ForwardingEvent.prototype.setChanIdIn = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint64 chan_id_out = 4;
 * @return {string}
 */
proto.lnrpc.ForwardingEvent.prototype.getChanIdOut = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, "0"));
};


/** @param {string} value */
proto.lnrpc.ForwardingEvent.prototype.setChanIdOut = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint64 amt_in = 5;
 * @return {number}
 */
proto.lnrpc.ForwardingEvent.prototype.getAmtIn = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingEvent.prototype.setAmtIn = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint64 amt_out = 6;
 * @return {number}
 */
proto.lnrpc.ForwardingEvent.prototype.getAmtOut = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingEvent.prototype.setAmtOut = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint64 fee = 7;
 * @return {number}
 */
proto.lnrpc.ForwardingEvent.prototype.getFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingEvent.prototype.setFee = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional uint64 fee_m_atoms = 8;
 * @return {number}
 */
proto.lnrpc.ForwardingEvent.prototype.getFeeMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingEvent.prototype.setFeeMAtoms = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional uint64 amt_in_m_atoms = 9;
 * @return {number}
 */
proto.lnrpc.ForwardingEvent.prototype.getAmtInMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingEvent.prototype.setAmtInMAtoms = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional uint64 amt_out_m_atoms = 10;
 * @return {number}
 */
proto.lnrpc.ForwardingEvent.prototype.getAmtOutMAtoms = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingEvent.prototype.setAmtOutMAtoms = function(value) {
  jspb.Message.setField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ForwardingHistoryResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ForwardingHistoryResponse.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ForwardingHistoryResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ForwardingHistoryResponse.displayName = 'proto.lnrpc.ForwardingHistoryResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ForwardingHistoryResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ForwardingHistoryResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ForwardingHistoryResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ForwardingHistoryResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ForwardingHistoryResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    forwardingEventsList: jspb.Message.toObjectList(msg.getForwardingEventsList(),
    proto.lnrpc.ForwardingEvent.toObject, includeInstance),
    lastOffsetIndex: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ForwardingHistoryResponse}
 */
proto.lnrpc.ForwardingHistoryResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ForwardingHistoryResponse;
  return proto.lnrpc.ForwardingHistoryResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ForwardingHistoryResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ForwardingHistoryResponse}
 */
proto.lnrpc.ForwardingHistoryResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ForwardingEvent;
      reader.readMessage(value,proto.lnrpc.ForwardingEvent.deserializeBinaryFromReader);
      msg.addForwardingEvents(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLastOffsetIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ForwardingHistoryResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ForwardingHistoryResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ForwardingHistoryResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ForwardingHistoryResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getForwardingEventsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.ForwardingEvent.serializeBinaryToWriter
    );
  }
  f = message.getLastOffsetIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * repeated ForwardingEvent forwarding_events = 1;
 * @return {!Array.<!proto.lnrpc.ForwardingEvent>}
 */
proto.lnrpc.ForwardingHistoryResponse.prototype.getForwardingEventsList = function() {
  return /** @type{!Array.<!proto.lnrpc.ForwardingEvent>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ForwardingEvent, 1));
};


/** @param {!Array.<!proto.lnrpc.ForwardingEvent>} value */
proto.lnrpc.ForwardingHistoryResponse.prototype.setForwardingEventsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.ForwardingEvent=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ForwardingEvent}
 */
proto.lnrpc.ForwardingHistoryResponse.prototype.addForwardingEvents = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.ForwardingEvent, opt_index);
};


proto.lnrpc.ForwardingHistoryResponse.prototype.clearForwardingEventsList = function() {
  this.setForwardingEventsList([]);
};


/**
 * optional uint32 last_offset_index = 2;
 * @return {number}
 */
proto.lnrpc.ForwardingHistoryResponse.prototype.getLastOffsetIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.lnrpc.ForwardingHistoryResponse.prototype.setLastOffsetIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ExportChannelBackupRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ExportChannelBackupRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ExportChannelBackupRequest.displayName = 'proto.lnrpc.ExportChannelBackupRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ExportChannelBackupRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ExportChannelBackupRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ExportChannelBackupRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ExportChannelBackupRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanPoint: (f = msg.getChanPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ExportChannelBackupRequest}
 */
proto.lnrpc.ExportChannelBackupRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ExportChannelBackupRequest;
  return proto.lnrpc.ExportChannelBackupRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ExportChannelBackupRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ExportChannelBackupRequest}
 */
proto.lnrpc.ExportChannelBackupRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChanPoint(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ExportChannelBackupRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ExportChannelBackupRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ExportChannelBackupRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ExportChannelBackupRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanPoint();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChannelPoint chan_point = 1;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ExportChannelBackupRequest.prototype.getChanPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 1));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.ExportChannelBackupRequest.prototype.setChanPoint = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.ExportChannelBackupRequest.prototype.clearChanPoint = function() {
  this.setChanPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ExportChannelBackupRequest.prototype.hasChanPoint = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelBackup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelBackup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelBackup.displayName = 'proto.lnrpc.ChannelBackup';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelBackup.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelBackup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelBackup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBackup.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanPoint: (f = msg.getChanPoint()) && proto.lnrpc.ChannelPoint.toObject(includeInstance, f),
    chanBackup: msg.getChanBackup_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelBackup}
 */
proto.lnrpc.ChannelBackup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelBackup;
  return proto.lnrpc.ChannelBackup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelBackup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelBackup}
 */
proto.lnrpc.ChannelBackup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.setChanPoint(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChanBackup(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelBackup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelBackup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelBackup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBackup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanPoint();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
  f = message.getChanBackup_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional ChannelPoint chan_point = 1;
 * @return {?proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.ChannelBackup.prototype.getChanPoint = function() {
  return /** @type{?proto.lnrpc.ChannelPoint} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelPoint, 1));
};


/** @param {?proto.lnrpc.ChannelPoint|undefined} value */
proto.lnrpc.ChannelBackup.prototype.setChanPoint = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.ChannelBackup.prototype.clearChanPoint = function() {
  this.setChanPoint(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChannelBackup.prototype.hasChanPoint = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes chan_backup = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.ChannelBackup.prototype.getChanBackup = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes chan_backup = 2;
 * This is a type-conversion wrapper around `getChanBackup()`
 * @return {string}
 */
proto.lnrpc.ChannelBackup.prototype.getChanBackup_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChanBackup()));
};


/**
 * optional bytes chan_backup = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChanBackup()`
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelBackup.prototype.getChanBackup_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChanBackup()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.ChannelBackup.prototype.setChanBackup = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.MultiChanBackup = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.MultiChanBackup.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.MultiChanBackup, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.MultiChanBackup.displayName = 'proto.lnrpc.MultiChanBackup';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.MultiChanBackup.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.MultiChanBackup.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.MultiChanBackup.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.MultiChanBackup} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.MultiChanBackup.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanPointsList: jspb.Message.toObjectList(msg.getChanPointsList(),
    proto.lnrpc.ChannelPoint.toObject, includeInstance),
    multiChanBackup: msg.getMultiChanBackup_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.MultiChanBackup}
 */
proto.lnrpc.MultiChanBackup.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.MultiChanBackup;
  return proto.lnrpc.MultiChanBackup.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.MultiChanBackup} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.MultiChanBackup}
 */
proto.lnrpc.MultiChanBackup.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelPoint;
      reader.readMessage(value,proto.lnrpc.ChannelPoint.deserializeBinaryFromReader);
      msg.addChanPoints(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMultiChanBackup(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.MultiChanBackup.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.MultiChanBackup.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.MultiChanBackup} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.MultiChanBackup.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanPointsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.ChannelPoint.serializeBinaryToWriter
    );
  }
  f = message.getMultiChanBackup_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * repeated ChannelPoint chan_points = 1;
 * @return {!Array.<!proto.lnrpc.ChannelPoint>}
 */
proto.lnrpc.MultiChanBackup.prototype.getChanPointsList = function() {
  return /** @type{!Array.<!proto.lnrpc.ChannelPoint>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ChannelPoint, 1));
};


/** @param {!Array.<!proto.lnrpc.ChannelPoint>} value */
proto.lnrpc.MultiChanBackup.prototype.setChanPointsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.ChannelPoint=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ChannelPoint}
 */
proto.lnrpc.MultiChanBackup.prototype.addChanPoints = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.ChannelPoint, opt_index);
};


proto.lnrpc.MultiChanBackup.prototype.clearChanPointsList = function() {
  this.setChanPointsList([]);
};


/**
 * optional bytes multi_chan_backup = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.MultiChanBackup.prototype.getMultiChanBackup = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes multi_chan_backup = 2;
 * This is a type-conversion wrapper around `getMultiChanBackup()`
 * @return {string}
 */
proto.lnrpc.MultiChanBackup.prototype.getMultiChanBackup_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMultiChanBackup()));
};


/**
 * optional bytes multi_chan_backup = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMultiChanBackup()`
 * @return {!Uint8Array}
 */
proto.lnrpc.MultiChanBackup.prototype.getMultiChanBackup_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMultiChanBackup()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.MultiChanBackup.prototype.setMultiChanBackup = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChanBackupExportRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChanBackupExportRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChanBackupExportRequest.displayName = 'proto.lnrpc.ChanBackupExportRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChanBackupExportRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChanBackupExportRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChanBackupExportRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChanBackupExportRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChanBackupExportRequest}
 */
proto.lnrpc.ChanBackupExportRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChanBackupExportRequest;
  return proto.lnrpc.ChanBackupExportRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChanBackupExportRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChanBackupExportRequest}
 */
proto.lnrpc.ChanBackupExportRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChanBackupExportRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChanBackupExportRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChanBackupExportRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChanBackupExportRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChanBackupSnapshot = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChanBackupSnapshot, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChanBackupSnapshot.displayName = 'proto.lnrpc.ChanBackupSnapshot';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChanBackupSnapshot.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChanBackupSnapshot.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChanBackupSnapshot} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChanBackupSnapshot.toObject = function(includeInstance, msg) {
  var f, obj = {
    singleChanBackups: (f = msg.getSingleChanBackups()) && proto.lnrpc.ChannelBackups.toObject(includeInstance, f),
    multiChanBackup: (f = msg.getMultiChanBackup()) && proto.lnrpc.MultiChanBackup.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChanBackupSnapshot}
 */
proto.lnrpc.ChanBackupSnapshot.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChanBackupSnapshot;
  return proto.lnrpc.ChanBackupSnapshot.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChanBackupSnapshot} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChanBackupSnapshot}
 */
proto.lnrpc.ChanBackupSnapshot.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelBackups;
      reader.readMessage(value,proto.lnrpc.ChannelBackups.deserializeBinaryFromReader);
      msg.setSingleChanBackups(value);
      break;
    case 2:
      var value = new proto.lnrpc.MultiChanBackup;
      reader.readMessage(value,proto.lnrpc.MultiChanBackup.deserializeBinaryFromReader);
      msg.setMultiChanBackup(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChanBackupSnapshot.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChanBackupSnapshot.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChanBackupSnapshot} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChanBackupSnapshot.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSingleChanBackups();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.ChannelBackups.serializeBinaryToWriter
    );
  }
  f = message.getMultiChanBackup();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.lnrpc.MultiChanBackup.serializeBinaryToWriter
    );
  }
};


/**
 * optional ChannelBackups single_chan_backups = 1;
 * @return {?proto.lnrpc.ChannelBackups}
 */
proto.lnrpc.ChanBackupSnapshot.prototype.getSingleChanBackups = function() {
  return /** @type{?proto.lnrpc.ChannelBackups} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelBackups, 1));
};


/** @param {?proto.lnrpc.ChannelBackups|undefined} value */
proto.lnrpc.ChanBackupSnapshot.prototype.setSingleChanBackups = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.lnrpc.ChanBackupSnapshot.prototype.clearSingleChanBackups = function() {
  this.setSingleChanBackups(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChanBackupSnapshot.prototype.hasSingleChanBackups = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional MultiChanBackup multi_chan_backup = 2;
 * @return {?proto.lnrpc.MultiChanBackup}
 */
proto.lnrpc.ChanBackupSnapshot.prototype.getMultiChanBackup = function() {
  return /** @type{?proto.lnrpc.MultiChanBackup} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.MultiChanBackup, 2));
};


/** @param {?proto.lnrpc.MultiChanBackup|undefined} value */
proto.lnrpc.ChanBackupSnapshot.prototype.setMultiChanBackup = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.lnrpc.ChanBackupSnapshot.prototype.clearMultiChanBackup = function() {
  this.setMultiChanBackup(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.ChanBackupSnapshot.prototype.hasMultiChanBackup = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelBackups = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.ChannelBackups.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.ChannelBackups, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelBackups.displayName = 'proto.lnrpc.ChannelBackups';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.ChannelBackups.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelBackups.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelBackups.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelBackups} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBackups.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanBackupsList: jspb.Message.toObjectList(msg.getChanBackupsList(),
    proto.lnrpc.ChannelBackup.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelBackups}
 */
proto.lnrpc.ChannelBackups.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelBackups;
  return proto.lnrpc.ChannelBackups.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelBackups} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelBackups}
 */
proto.lnrpc.ChannelBackups.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelBackup;
      reader.readMessage(value,proto.lnrpc.ChannelBackup.deserializeBinaryFromReader);
      msg.addChanBackups(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelBackups.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelBackups.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelBackups} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBackups.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanBackupsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.ChannelBackup.serializeBinaryToWriter
    );
  }
};


/**
 * repeated ChannelBackup chan_backups = 1;
 * @return {!Array.<!proto.lnrpc.ChannelBackup>}
 */
proto.lnrpc.ChannelBackups.prototype.getChanBackupsList = function() {
  return /** @type{!Array.<!proto.lnrpc.ChannelBackup>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.ChannelBackup, 1));
};


/** @param {!Array.<!proto.lnrpc.ChannelBackup>} value */
proto.lnrpc.ChannelBackups.prototype.setChanBackupsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.ChannelBackup=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.ChannelBackup}
 */
proto.lnrpc.ChannelBackups.prototype.addChanBackups = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.ChannelBackup, opt_index);
};


proto.lnrpc.ChannelBackups.prototype.clearChanBackupsList = function() {
  this.setChanBackupsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.RestoreChanBackupRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.lnrpc.RestoreChanBackupRequest.oneofGroups_);
};
goog.inherits(proto.lnrpc.RestoreChanBackupRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.RestoreChanBackupRequest.displayName = 'proto.lnrpc.RestoreChanBackupRequest';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.lnrpc.RestoreChanBackupRequest.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.lnrpc.RestoreChanBackupRequest.BackupCase = {
  BACKUP_NOT_SET: 0,
  CHAN_BACKUPS: 1,
  MULTI_CHAN_BACKUP: 2
};

/**
 * @return {proto.lnrpc.RestoreChanBackupRequest.BackupCase}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.getBackupCase = function() {
  return /** @type {proto.lnrpc.RestoreChanBackupRequest.BackupCase} */(jspb.Message.computeOneofCase(this, proto.lnrpc.RestoreChanBackupRequest.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.RestoreChanBackupRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.RestoreChanBackupRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.RestoreChanBackupRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    chanBackups: (f = msg.getChanBackups()) && proto.lnrpc.ChannelBackups.toObject(includeInstance, f),
    multiChanBackup: msg.getMultiChanBackup_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.RestoreChanBackupRequest}
 */
proto.lnrpc.RestoreChanBackupRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.RestoreChanBackupRequest;
  return proto.lnrpc.RestoreChanBackupRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.RestoreChanBackupRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.RestoreChanBackupRequest}
 */
proto.lnrpc.RestoreChanBackupRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.ChannelBackups;
      reader.readMessage(value,proto.lnrpc.ChannelBackups.deserializeBinaryFromReader);
      msg.setChanBackups(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMultiChanBackup(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.RestoreChanBackupRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.RestoreChanBackupRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.RestoreChanBackupRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChanBackups();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.lnrpc.ChannelBackups.serializeBinaryToWriter
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional ChannelBackups chan_backups = 1;
 * @return {?proto.lnrpc.ChannelBackups}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.getChanBackups = function() {
  return /** @type{?proto.lnrpc.ChannelBackups} */ (
    jspb.Message.getWrapperField(this, proto.lnrpc.ChannelBackups, 1));
};


/** @param {?proto.lnrpc.ChannelBackups|undefined} value */
proto.lnrpc.RestoreChanBackupRequest.prototype.setChanBackups = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.lnrpc.RestoreChanBackupRequest.oneofGroups_[0], value);
};


proto.lnrpc.RestoreChanBackupRequest.prototype.clearChanBackups = function() {
  this.setChanBackups(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.hasChanBackups = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes multi_chan_backup = 2;
 * @return {!(string|Uint8Array)}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.getMultiChanBackup = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes multi_chan_backup = 2;
 * This is a type-conversion wrapper around `getMultiChanBackup()`
 * @return {string}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.getMultiChanBackup_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMultiChanBackup()));
};


/**
 * optional bytes multi_chan_backup = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMultiChanBackup()`
 * @return {!Uint8Array}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.getMultiChanBackup_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMultiChanBackup()));
};


/** @param {!(string|Uint8Array)} value */
proto.lnrpc.RestoreChanBackupRequest.prototype.setMultiChanBackup = function(value) {
  jspb.Message.setOneofField(this, 2, proto.lnrpc.RestoreChanBackupRequest.oneofGroups_[0], value);
};


proto.lnrpc.RestoreChanBackupRequest.prototype.clearMultiChanBackup = function() {
  jspb.Message.setOneofField(this, 2, proto.lnrpc.RestoreChanBackupRequest.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.lnrpc.RestoreChanBackupRequest.prototype.hasMultiChanBackup = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.RestoreBackupResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.RestoreBackupResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.RestoreBackupResponse.displayName = 'proto.lnrpc.RestoreBackupResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.RestoreBackupResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.RestoreBackupResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.RestoreBackupResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.RestoreBackupResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.RestoreBackupResponse}
 */
proto.lnrpc.RestoreBackupResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.RestoreBackupResponse;
  return proto.lnrpc.RestoreBackupResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.RestoreBackupResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.RestoreBackupResponse}
 */
proto.lnrpc.RestoreBackupResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.RestoreBackupResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.RestoreBackupResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.RestoreBackupResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.RestoreBackupResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.ChannelBackupSubscription = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.ChannelBackupSubscription, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.ChannelBackupSubscription.displayName = 'proto.lnrpc.ChannelBackupSubscription';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.ChannelBackupSubscription.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.ChannelBackupSubscription.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.ChannelBackupSubscription} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBackupSubscription.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.ChannelBackupSubscription}
 */
proto.lnrpc.ChannelBackupSubscription.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.ChannelBackupSubscription;
  return proto.lnrpc.ChannelBackupSubscription.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.ChannelBackupSubscription} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.ChannelBackupSubscription}
 */
proto.lnrpc.ChannelBackupSubscription.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.ChannelBackupSubscription.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.ChannelBackupSubscription.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.ChannelBackupSubscription} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.ChannelBackupSubscription.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.VerifyChanBackupResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.VerifyChanBackupResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.VerifyChanBackupResponse.displayName = 'proto.lnrpc.VerifyChanBackupResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.VerifyChanBackupResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.VerifyChanBackupResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.VerifyChanBackupResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.VerifyChanBackupResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.VerifyChanBackupResponse}
 */
proto.lnrpc.VerifyChanBackupResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.VerifyChanBackupResponse;
  return proto.lnrpc.VerifyChanBackupResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.VerifyChanBackupResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.VerifyChanBackupResponse}
 */
proto.lnrpc.VerifyChanBackupResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.VerifyChanBackupResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.VerifyChanBackupResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.VerifyChanBackupResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.VerifyChanBackupResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.MacaroonPermission = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.MacaroonPermission, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.MacaroonPermission.displayName = 'proto.lnrpc.MacaroonPermission';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.MacaroonPermission.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.MacaroonPermission.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.MacaroonPermission} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.MacaroonPermission.toObject = function(includeInstance, msg) {
  var f, obj = {
    entity: jspb.Message.getFieldWithDefault(msg, 1, ""),
    action: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.MacaroonPermission}
 */
proto.lnrpc.MacaroonPermission.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.MacaroonPermission;
  return proto.lnrpc.MacaroonPermission.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.MacaroonPermission} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.MacaroonPermission}
 */
proto.lnrpc.MacaroonPermission.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setEntity(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.MacaroonPermission.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.MacaroonPermission.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.MacaroonPermission} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.MacaroonPermission.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEntity();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAction();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string entity = 1;
 * @return {string}
 */
proto.lnrpc.MacaroonPermission.prototype.getEntity = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.MacaroonPermission.prototype.setEntity = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string action = 2;
 * @return {string}
 */
proto.lnrpc.MacaroonPermission.prototype.getAction = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.lnrpc.MacaroonPermission.prototype.setAction = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.BakeMacaroonRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.lnrpc.BakeMacaroonRequest.repeatedFields_, null);
};
goog.inherits(proto.lnrpc.BakeMacaroonRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.BakeMacaroonRequest.displayName = 'proto.lnrpc.BakeMacaroonRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.lnrpc.BakeMacaroonRequest.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.BakeMacaroonRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.BakeMacaroonRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.BakeMacaroonRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.BakeMacaroonRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    permissionsList: jspb.Message.toObjectList(msg.getPermissionsList(),
    proto.lnrpc.MacaroonPermission.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.BakeMacaroonRequest}
 */
proto.lnrpc.BakeMacaroonRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.BakeMacaroonRequest;
  return proto.lnrpc.BakeMacaroonRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.BakeMacaroonRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.BakeMacaroonRequest}
 */
proto.lnrpc.BakeMacaroonRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.lnrpc.MacaroonPermission;
      reader.readMessage(value,proto.lnrpc.MacaroonPermission.deserializeBinaryFromReader);
      msg.addPermissions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.BakeMacaroonRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.BakeMacaroonRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.BakeMacaroonRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.BakeMacaroonRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPermissionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.lnrpc.MacaroonPermission.serializeBinaryToWriter
    );
  }
};


/**
 * repeated MacaroonPermission permissions = 1;
 * @return {!Array.<!proto.lnrpc.MacaroonPermission>}
 */
proto.lnrpc.BakeMacaroonRequest.prototype.getPermissionsList = function() {
  return /** @type{!Array.<!proto.lnrpc.MacaroonPermission>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.lnrpc.MacaroonPermission, 1));
};


/** @param {!Array.<!proto.lnrpc.MacaroonPermission>} value */
proto.lnrpc.BakeMacaroonRequest.prototype.setPermissionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.lnrpc.MacaroonPermission=} opt_value
 * @param {number=} opt_index
 * @return {!proto.lnrpc.MacaroonPermission}
 */
proto.lnrpc.BakeMacaroonRequest.prototype.addPermissions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.lnrpc.MacaroonPermission, opt_index);
};


proto.lnrpc.BakeMacaroonRequest.prototype.clearPermissionsList = function() {
  this.setPermissionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.lnrpc.BakeMacaroonResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.lnrpc.BakeMacaroonResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.lnrpc.BakeMacaroonResponse.displayName = 'proto.lnrpc.BakeMacaroonResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.lnrpc.BakeMacaroonResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.lnrpc.BakeMacaroonResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.lnrpc.BakeMacaroonResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.BakeMacaroonResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    macaroon: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.lnrpc.BakeMacaroonResponse}
 */
proto.lnrpc.BakeMacaroonResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.lnrpc.BakeMacaroonResponse;
  return proto.lnrpc.BakeMacaroonResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.lnrpc.BakeMacaroonResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.lnrpc.BakeMacaroonResponse}
 */
proto.lnrpc.BakeMacaroonResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMacaroon(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.lnrpc.BakeMacaroonResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.lnrpc.BakeMacaroonResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.lnrpc.BakeMacaroonResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.lnrpc.BakeMacaroonResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMacaroon();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string macaroon = 1;
 * @return {string}
 */
proto.lnrpc.BakeMacaroonResponse.prototype.getMacaroon = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.lnrpc.BakeMacaroonResponse.prototype.setMacaroon = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * @enum {number}
 */
proto.lnrpc.AddressType = {
  WITNESS_PUBKEY_HASH: 0,
  NESTED_PUBKEY_HASH: 1,
  PUBKEY_HASH: 2,
  SCRIPT_HASH: 3,
  UNUSED_PUBKEY_HASH: 4
};

/**
 * @enum {number}
 */
proto.lnrpc.InvoiceHTLCState = {
  ACCEPTED: 0,
  SETTLED: 1,
  CANCELED: 2
};

/**
 * @enum {number}
 */
proto.lnrpc.FeatureBit = {
  DATALOSS_PROTECT_REQ: 0,
  DATALOSS_PROTECT_OPT: 1,
  INITIAL_ROUING_SYNC: 3,
  UPFRONT_SHUTDOWN_SCRIPT_REQ: 4,
  UPFRONT_SHUTDOWN_SCRIPT_OPT: 5,
  GOSSIP_QUERIES_REQ: 6,
  GOSSIP_QUERIES_OPT: 7,
  TLV_ONION_REQ: 8,
  TLV_ONION_OPT: 9,
  EXT_GOSSIP_QUERIES_REQ: 10,
  EXT_GOSSIP_QUERIES_OPT: 11,
  STATIC_REMOTE_KEY_REQ: 12,
  STATIC_REMOTE_KEY_OPT: 13,
  PAYMENT_ADDR_REQ: 14,
  PAYMENT_ADDR_OPT: 15,
  MPP_REQ: 16,
  MPP_OPT: 17
};

goog.object.extend(exports, proto.lnrpc);
