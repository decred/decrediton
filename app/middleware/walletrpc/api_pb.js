/**
 * @fileoverview
 * @enhanceable
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.walletrpc.AccountBalance', null, global);
goog.exportSymbol('proto.walletrpc.AccountNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountNumberRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountNumberResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountsRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountsResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountsResponse.Account', null, global);
goog.exportSymbol('proto.walletrpc.BalanceRequest', null, global);
goog.exportSymbol('proto.walletrpc.BalanceResponse', null, global);
goog.exportSymbol('proto.walletrpc.BlockDetails', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseRequest', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseRequest.Key', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseResponse', null, global);
goog.exportSymbol('proto.walletrpc.CloseWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.CloseWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.Output', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.OutputDestination', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.CreateWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.CreateWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.DecodeSeedRequest', null, global);
goog.exportSymbol('proto.walletrpc.DecodeSeedResponse', null, global);
goog.exportSymbol('proto.walletrpc.DiscoverAddressesRequest', null, global);
goog.exportSymbol('proto.walletrpc.DiscoverAddressesResponse', null, global);
goog.exportSymbol('proto.walletrpc.FetchHeadersRequest', null, global);
goog.exportSymbol('proto.walletrpc.FetchHeadersResponse', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionResponse.PreviousOutput', null, global);
goog.exportSymbol('proto.walletrpc.GenerateRandomSeedRequest', null, global);
goog.exportSymbol('proto.walletrpc.GenerateRandomSeedResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionsRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionsResponse', null, global);
goog.exportSymbol('proto.walletrpc.ImportPrivateKeyRequest', null, global);
goog.exportSymbol('proto.walletrpc.ImportPrivateKeyResponse', null, global);
goog.exportSymbol('proto.walletrpc.ImportScriptRequest', null, global);
goog.exportSymbol('proto.walletrpc.ImportScriptResponse', null, global);
goog.exportSymbol('proto.walletrpc.LoadActiveDataFiltersRequest', null, global);
goog.exportSymbol('proto.walletrpc.LoadActiveDataFiltersResponse', null, global);
goog.exportSymbol('proto.walletrpc.NetworkRequest', null, global);
goog.exportSymbol('proto.walletrpc.NetworkResponse', null, global);
goog.exportSymbol('proto.walletrpc.NextAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.NextAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressRequest.Kind', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.OpenWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.OpenWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.PingRequest', null, global);
goog.exportSymbol('proto.walletrpc.PingResponse', null, global);
goog.exportSymbol('proto.walletrpc.PublishTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.PublishTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.PurchaseTicketsRequest', null, global);
goog.exportSymbol('proto.walletrpc.PurchaseTicketsResponse', null, global);
goog.exportSymbol('proto.walletrpc.RenameAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.RenameAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.RescanRequest', null, global);
goog.exportSymbol('proto.walletrpc.RescanResponse', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.SpentnessNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.SpentnessNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.SpentnessNotificationsResponse.Spender', null, global);
goog.exportSymbol('proto.walletrpc.StakeInfoRequest', null, global);
goog.exportSymbol('proto.walletrpc.StakeInfoResponse', null, global);
goog.exportSymbol('proto.walletrpc.StartConsensusRpcRequest', null, global);
goog.exportSymbol('proto.walletrpc.StartConsensusRpcResponse', null, global);
goog.exportSymbol('proto.walletrpc.SubscribeToBlockNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.SubscribeToBlockNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.TicketPriceRequest', null, global);
goog.exportSymbol('proto.walletrpc.TicketPriceResponse', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails.Input', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails.Output', null, global);
goog.exportSymbol('proto.walletrpc.TransactionNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.TransactionNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.VersionRequest', null, global);
goog.exportSymbol('proto.walletrpc.VersionResponse', null, global);
goog.exportSymbol('proto.walletrpc.WalletExistsRequest', null, global);
goog.exportSymbol('proto.walletrpc.WalletExistsResponse', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VersionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VersionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VersionRequest.displayName = 'proto.walletrpc.VersionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VersionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VersionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VersionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VersionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VersionRequest}
 */
proto.walletrpc.VersionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VersionRequest;
  return proto.walletrpc.VersionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VersionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VersionRequest}
 */
proto.walletrpc.VersionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VersionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VersionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VersionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VersionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VersionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VersionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VersionResponse.displayName = 'proto.walletrpc.VersionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VersionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VersionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VersionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.VersionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    versionString: jspb.Message.getFieldWithDefault(msg, 1, ""),
    major: jspb.Message.getFieldWithDefault(msg, 2, 0),
    minor: jspb.Message.getFieldWithDefault(msg, 3, 0),
    patch: jspb.Message.getFieldWithDefault(msg, 4, 0),
    prerelease: jspb.Message.getFieldWithDefault(msg, 5, ""),
    buildMetadata: jspb.Message.getFieldWithDefault(msg, 6, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VersionResponse}
 */
proto.walletrpc.VersionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VersionResponse;
  return proto.walletrpc.VersionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VersionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VersionResponse}
 */
proto.walletrpc.VersionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVersionString(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMajor(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMinor(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPatch(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setPrerelease(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setBuildMetadata(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VersionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VersionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VersionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.VersionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getVersionString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getMajor();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getMinor();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getPatch();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getPrerelease();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = this.getBuildMetadata();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional string version_string = 1;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getVersionString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.VersionResponse.prototype.setVersionString = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 major = 2;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getMajor = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.VersionResponse.prototype.setMajor = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 minor = 3;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getMinor = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.VersionResponse.prototype.setMinor = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 patch = 4;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getPatch = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.VersionResponse.prototype.setPatch = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string prerelease = 5;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getPrerelease = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.walletrpc.VersionResponse.prototype.setPrerelease = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional string build_metadata = 6;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getBuildMetadata = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.walletrpc.VersionResponse.prototype.setBuildMetadata = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.TransactionDetails.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.TransactionDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.displayName = 'proto.walletrpc.TransactionDetails';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.TransactionDetails.repeatedFields_ = [3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: msg.getHash_asB64(),
    transaction: msg.getTransaction_asB64(),
    debitsList: jspb.Message.toObjectList(msg.getDebitsList(),
    proto.walletrpc.TransactionDetails.Input.toObject, includeInstance),
    creditsList: jspb.Message.toObjectList(msg.getCreditsList(),
    proto.walletrpc.TransactionDetails.Output.toObject, includeInstance),
    fee: jspb.Message.getFieldWithDefault(msg, 5, 0),
    timestamp: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.TransactionDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails;
  return proto.walletrpc.TransactionDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.TransactionDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransaction(value);
      break;
    case 3:
      var value = new proto.walletrpc.TransactionDetails.Input;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader);
      msg.addDebits(value);
      break;
    case 4:
      var value = new proto.walletrpc.TransactionDetails.Output;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader);
      msg.addCredits(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFee(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getDebitsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.walletrpc.TransactionDetails.Input.serializeBinaryToWriter
    );
  }
  f = this.getCreditsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.TransactionDetails.Output.serializeBinaryToWriter
    );
  }
  f = this.getFee();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
};


/**
 * optional bytes hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.TransactionDetails.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes hash = 1;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.walletrpc.TransactionDetails.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.TransactionDetails.prototype.setHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes transaction = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes transaction = 2;
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {string}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransaction()));
};


/**
 * optional bytes transaction = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.TransactionDetails.prototype.setTransaction = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * repeated Input debits = 3;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails.Input>}
 */
proto.walletrpc.TransactionDetails.prototype.getDebitsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails.Input>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails.Input, 3));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails.Input>} value */
proto.walletrpc.TransactionDetails.prototype.setDebitsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails.Input=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails.Input}
 */
proto.walletrpc.TransactionDetails.prototype.addDebits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.walletrpc.TransactionDetails.Input, opt_index);
};


proto.walletrpc.TransactionDetails.prototype.clearDebitsList = function() {
  this.setDebitsList([]);
};


/**
 * repeated Output credits = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails.Output>}
 */
proto.walletrpc.TransactionDetails.prototype.getCreditsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails.Output>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails.Output, 4));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails.Output>} value */
proto.walletrpc.TransactionDetails.prototype.setCreditsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails.Output=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails.Output}
 */
proto.walletrpc.TransactionDetails.prototype.addCredits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.walletrpc.TransactionDetails.Output, opt_index);
};


proto.walletrpc.TransactionDetails.prototype.clearCreditsList = function() {
  this.setCreditsList([]);
};


/**
 * optional int64 fee = 5;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.prototype.getFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.prototype.setFee = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 timestamp = 6;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails.Input = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionDetails.Input, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.Input.displayName = 'proto.walletrpc.TransactionDetails.Input';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Input.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.Input.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails.Input} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Input.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0),
    previousAccount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    previousAmount: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails.Input}
 */
proto.walletrpc.TransactionDetails.Input.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails.Input;
  return proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails.Input} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails.Input}
 */
proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPreviousAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setPreviousAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails.Input} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.Input.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.Input.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.Input.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getPreviousAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getPreviousAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * optional uint32 index = 1;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Input.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 previous_account = 2;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getPreviousAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Input.prototype.setPreviousAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 previous_amount = 3;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getPreviousAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Input.prototype.setPreviousAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails.Output = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionDetails.Output, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.Output.displayName = 'proto.walletrpc.TransactionDetails.Output';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Output.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.Output.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails.Output} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Output.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0),
    account: jspb.Message.getFieldWithDefault(msg, 2, 0),
    internal: jspb.Message.getFieldWithDefault(msg, 3, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails.Output}
 */
proto.walletrpc.TransactionDetails.Output.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails.Output;
  return proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails.Output} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails.Output}
 */
proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setInternal(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails.Output} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.Output.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.Output.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionDetails.Output.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getInternal();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * optional uint32 index = 1;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Output.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Output.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool internal = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getInternal = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.walletrpc.TransactionDetails.Output.prototype.setInternal = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BlockDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.BlockDetails.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.BlockDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BlockDetails.displayName = 'proto.walletrpc.BlockDetails';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.BlockDetails.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BlockDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BlockDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BlockDetails} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BlockDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: msg.getHash_asB64(),
    height: jspb.Message.getFieldWithDefault(msg, 2, 0),
    timestamp: jspb.Message.getFieldWithDefault(msg, 3, 0),
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BlockDetails}
 */
proto.walletrpc.BlockDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BlockDetails;
  return proto.walletrpc.BlockDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BlockDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BlockDetails}
 */
proto.walletrpc.BlockDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHeight(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    case 4:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.addTransactions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BlockDetails} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BlockDetails.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BlockDetails.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockDetails.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes hash = 1;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.walletrpc.BlockDetails.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockDetails.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.BlockDetails.prototype.setHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 height = 2;
 * @return {number}
 */
proto.walletrpc.BlockDetails.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.BlockDetails.prototype.setHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 timestamp = 3;
 * @return {number}
 */
proto.walletrpc.BlockDetails.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.BlockDetails.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * repeated TransactionDetails transactions = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.BlockDetails.prototype.getTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 4));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails>} value */
proto.walletrpc.BlockDetails.prototype.setTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.BlockDetails.prototype.addTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.walletrpc.TransactionDetails, opt_index);
};


proto.walletrpc.BlockDetails.prototype.clearTransactionsList = function() {
  this.setTransactionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountBalance = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountBalance, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountBalance.displayName = 'proto.walletrpc.AccountBalance';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountBalance.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountBalance.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountBalance} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountBalance.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0),
    totalBalance: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountBalance}
 */
proto.walletrpc.AccountBalance.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountBalance;
  return proto.walletrpc.AccountBalance.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountBalance} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountBalance}
 */
proto.walletrpc.AccountBalance.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalBalance(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountBalance} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountBalance.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountBalance.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountBalance.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getTotalBalance();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.AccountBalance.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AccountBalance.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 total_balance = 2;
 * @return {number}
 */
proto.walletrpc.AccountBalance.prototype.getTotalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.AccountBalance.prototype.setTotalBalance = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PingRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PingRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PingRequest.displayName = 'proto.walletrpc.PingRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PingRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PingRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PingRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PingRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PingRequest}
 */
proto.walletrpc.PingRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PingRequest;
  return proto.walletrpc.PingRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PingRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PingRequest}
 */
proto.walletrpc.PingRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PingRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PingRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PingRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PingRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PingResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PingResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PingResponse.displayName = 'proto.walletrpc.PingResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PingResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PingResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PingResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PingResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PingResponse}
 */
proto.walletrpc.PingResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PingResponse;
  return proto.walletrpc.PingResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PingResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PingResponse}
 */
proto.walletrpc.PingResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PingResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PingResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PingResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PingResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NetworkRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NetworkRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NetworkRequest.displayName = 'proto.walletrpc.NetworkRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NetworkRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NetworkRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NetworkRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NetworkRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NetworkRequest}
 */
proto.walletrpc.NetworkRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NetworkRequest;
  return proto.walletrpc.NetworkRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NetworkRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NetworkRequest}
 */
proto.walletrpc.NetworkRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NetworkRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NetworkRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NetworkRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NetworkRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NetworkResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NetworkResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NetworkResponse.displayName = 'proto.walletrpc.NetworkResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NetworkResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NetworkResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NetworkResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NetworkResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    activeNetwork: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NetworkResponse}
 */
proto.walletrpc.NetworkResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NetworkResponse;
  return proto.walletrpc.NetworkResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NetworkResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NetworkResponse}
 */
proto.walletrpc.NetworkResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setActiveNetwork(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NetworkResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NetworkResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NetworkResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NetworkResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getActiveNetwork();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 active_network = 1;
 * @return {number}
 */
proto.walletrpc.NetworkResponse.prototype.getActiveNetwork = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.NetworkResponse.prototype.setActiveNetwork = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNumberRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNumberRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNumberRequest.displayName = 'proto.walletrpc.AccountNumberRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNumberRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNumberRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNumberRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountNumberRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountName: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNumberRequest}
 */
proto.walletrpc.AccountNumberRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNumberRequest;
  return proto.walletrpc.AccountNumberRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNumberRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNumberRequest}
 */
proto.walletrpc.AccountNumberRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNumberRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNumberRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNumberRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNumberRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string account_name = 1;
 * @return {string}
 */
proto.walletrpc.AccountNumberRequest.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.AccountNumberRequest.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNumberResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNumberResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNumberResponse.displayName = 'proto.walletrpc.AccountNumberResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNumberResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNumberResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNumberResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountNumberResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNumberResponse}
 */
proto.walletrpc.AccountNumberResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNumberResponse;
  return proto.walletrpc.AccountNumberResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNumberResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNumberResponse}
 */
proto.walletrpc.AccountNumberResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNumberResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNumberResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNumberResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNumberResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountNumberResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNumberResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsRequest.displayName = 'proto.walletrpc.AccountsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsRequest}
 */
proto.walletrpc.AccountsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsRequest;
  return proto.walletrpc.AccountsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsRequest}
 */
proto.walletrpc.AccountsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.AccountsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.AccountsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsResponse.displayName = 'proto.walletrpc.AccountsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.AccountsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountsList: jspb.Message.toObjectList(msg.getAccountsList(),
    proto.walletrpc.AccountsResponse.Account.toObject, includeInstance),
    currentBlockHash: msg.getCurrentBlockHash_asB64(),
    currentBlockHeight: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsResponse}
 */
proto.walletrpc.AccountsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsResponse;
  return proto.walletrpc.AccountsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsResponse}
 */
proto.walletrpc.AccountsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.AccountsResponse.Account;
      reader.readMessage(value,proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader);
      msg.addAccounts(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCurrentBlockHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCurrentBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.AccountsResponse.Account.serializeBinaryToWriter
    );
  }
  f = this.getCurrentBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getCurrentBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
};


/**
 * repeated Account accounts = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.AccountsResponse.Account>}
 */
proto.walletrpc.AccountsResponse.prototype.getAccountsList = function() {
  return /** @type{!Array.<!proto.walletrpc.AccountsResponse.Account>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.AccountsResponse.Account, 1));
};


/** @param {!Array.<!proto.walletrpc.AccountsResponse.Account>} value */
proto.walletrpc.AccountsResponse.prototype.setAccountsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.walletrpc.AccountsResponse.Account=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.AccountsResponse.Account}
 */
proto.walletrpc.AccountsResponse.prototype.addAccounts = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.walletrpc.AccountsResponse.Account, opt_index);
};


proto.walletrpc.AccountsResponse.prototype.clearAccountsList = function() {
  this.setAccountsList([]);
};


/**
 * optional bytes current_block_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes current_block_hash = 2;
 * This is a type-conversion wrapper around `getCurrentBlockHash()`
 * @return {string}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCurrentBlockHash()));
};


/**
 * optional bytes current_block_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCurrentBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCurrentBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.AccountsResponse.prototype.setCurrentBlockHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 current_block_height = 3;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.prototype.setCurrentBlockHeight = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsResponse.Account = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountsResponse.Account, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsResponse.Account.displayName = 'proto.walletrpc.AccountsResponse.Account';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.Account.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsResponse.Account.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsResponse.Account} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.Account.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0),
    accountName: jspb.Message.getFieldWithDefault(msg, 2, ""),
    totalBalance: jspb.Message.getFieldWithDefault(msg, 3, 0),
    externalKeyCount: jspb.Message.getFieldWithDefault(msg, 4, 0),
    internalKeyCount: jspb.Message.getFieldWithDefault(msg, 5, 0),
    importedKeyCount: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsResponse.Account}
 */
proto.walletrpc.AccountsResponse.Account.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsResponse.Account;
  return proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsResponse.Account} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsResponse.Account}
 */
proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalBalance(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExternalKeyCount(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInternalKeyCount(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImportedKeyCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsResponse.Account} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsResponse.Account.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.Account.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountsResponse.Account.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getTotalBalance();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getExternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getInternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = this.getImportedKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.AccountsResponse.Account.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_balance = 3;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getTotalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setTotalBalance = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 external_key_count = 4;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getExternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setExternalKeyCount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 internal_key_count = 5;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getInternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setInternalKeyCount = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 imported_key_count = 6;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getImportedKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setImportedKeyCount = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RenameAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RenameAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RenameAccountRequest.displayName = 'proto.walletrpc.RenameAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RenameAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RenameAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RenameAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RenameAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0),
    newName: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RenameAccountRequest}
 */
proto.walletrpc.RenameAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RenameAccountRequest;
  return proto.walletrpc.RenameAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RenameAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RenameAccountRequest}
 */
proto.walletrpc.RenameAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RenameAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RenameAccountRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RenameAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RenameAccountRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getNewName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.RenameAccountRequest.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.RenameAccountRequest.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string new_name = 2;
 * @return {string}
 */
proto.walletrpc.RenameAccountRequest.prototype.getNewName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.RenameAccountRequest.prototype.setNewName = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RenameAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RenameAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RenameAccountResponse.displayName = 'proto.walletrpc.RenameAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RenameAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RenameAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RenameAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RenameAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RenameAccountResponse}
 */
proto.walletrpc.RenameAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RenameAccountResponse;
  return proto.walletrpc.RenameAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RenameAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RenameAccountResponse}
 */
proto.walletrpc.RenameAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RenameAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RenameAccountResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RenameAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RenameAccountResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanRequest.displayName = 'proto.walletrpc.RescanRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RescanRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    beginHeight: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanRequest}
 */
proto.walletrpc.RescanRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanRequest;
  return proto.walletrpc.RescanRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanRequest}
 */
proto.walletrpc.RescanRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBeginHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getBeginHeight();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 begin_height = 1;
 * @return {number}
 */
proto.walletrpc.RescanRequest.prototype.getBeginHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.RescanRequest.prototype.setBeginHeight = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanResponse.displayName = 'proto.walletrpc.RescanResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.RescanResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    rescannedThrough: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanResponse}
 */
proto.walletrpc.RescanResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanResponse;
  return proto.walletrpc.RescanResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanResponse}
 */
proto.walletrpc.RescanResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRescannedThrough(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.RescanResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getRescannedThrough();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 rescanned_through = 1;
 * @return {number}
 */
proto.walletrpc.RescanResponse.prototype.getRescannedThrough = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.RescanResponse.prototype.setRescannedThrough = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAccountRequest.displayName = 'proto.walletrpc.NextAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NextAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    accountName: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAccountRequest}
 */
proto.walletrpc.NextAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAccountRequest;
  return proto.walletrpc.NextAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAccountRequest}
 */
proto.walletrpc.NextAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAccountRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAccountRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.NextAccountRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.NextAccountRequest.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.NextAccountRequest.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAccountResponse.displayName = 'proto.walletrpc.NextAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NextAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAccountResponse}
 */
proto.walletrpc.NextAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAccountResponse;
  return proto.walletrpc.NextAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAccountResponse}
 */
proto.walletrpc.NextAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAccountResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAccountResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.NextAccountResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.NextAccountResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAddressRequest.displayName = 'proto.walletrpc.NextAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NextAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0),
    kind: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAddressRequest}
 */
proto.walletrpc.NextAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAddressRequest;
  return proto.walletrpc.NextAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAddressRequest}
 */
proto.walletrpc.NextAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {!proto.walletrpc.NextAddressRequest.Kind} */ (reader.readEnum());
      msg.setKind(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAddressRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAddressRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getKind();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.NextAddressRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.NextAddressRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional Kind kind = 2;
 * @return {!proto.walletrpc.NextAddressRequest.Kind}
 */
proto.walletrpc.NextAddressRequest.prototype.getKind = function() {
  return /** @type {!proto.walletrpc.NextAddressRequest.Kind} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.walletrpc.NextAddressRequest.Kind} value */
proto.walletrpc.NextAddressRequest.prototype.setKind = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.NextAddressRequest.Kind = {
  BIP0044_EXTERNAL: 0,
  BIP0044_INTERNAL: 1
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAddressResponse.displayName = 'proto.walletrpc.NextAddressResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.NextAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, ""),
    publicKey: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAddressResponse}
 */
proto.walletrpc.NextAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAddressResponse;
  return proto.walletrpc.NextAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAddressResponse}
 */
proto.walletrpc.NextAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPublicKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAddressResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.NextAddressResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getPublicKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.NextAddressResponse.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.NextAddressResponse.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string public_key = 2;
 * @return {string}
 */
proto.walletrpc.NextAddressResponse.prototype.getPublicKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.NextAddressResponse.prototype.setPublicKey = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportPrivateKeyRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportPrivateKeyRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportPrivateKeyRequest.displayName = 'proto.walletrpc.ImportPrivateKeyRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportPrivateKeyRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: jspb.Message.getFieldWithDefault(msg, 2, 0),
    privateKeyWif: jspb.Message.getFieldWithDefault(msg, 3, ""),
    rescan: jspb.Message.getFieldWithDefault(msg, 4, false),
    scanFrom: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportPrivateKeyRequest}
 */
proto.walletrpc.ImportPrivateKeyRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportPrivateKeyRequest;
  return proto.walletrpc.ImportPrivateKeyRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportPrivateKeyRequest}
 */
proto.walletrpc.ImportPrivateKeyRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPrivateKeyWif(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRescan(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setScanFrom(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportPrivateKeyRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getPrivateKeyWif();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = this.getRescan();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = this.getScanFrom();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string private_key_wif = 3;
 * @return {string}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPrivateKeyWif = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setPrivateKeyWif = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool rescan = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getRescan = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setRescan = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 scan_from = 5;
 * @return {number}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getScanFrom = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setScanFrom = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportPrivateKeyResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportPrivateKeyResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportPrivateKeyResponse.displayName = 'proto.walletrpc.ImportPrivateKeyResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportPrivateKeyResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportPrivateKeyResponse}
 */
proto.walletrpc.ImportPrivateKeyResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportPrivateKeyResponse;
  return proto.walletrpc.ImportPrivateKeyResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportPrivateKeyResponse}
 */
proto.walletrpc.ImportPrivateKeyResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportPrivateKeyResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportScriptRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportScriptRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportScriptRequest.displayName = 'proto.walletrpc.ImportScriptRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportScriptRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportScriptRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportScriptRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ImportScriptRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    script: msg.getScript_asB64(),
    rescan: jspb.Message.getFieldWithDefault(msg, 3, false),
    scanFrom: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportScriptRequest}
 */
proto.walletrpc.ImportScriptRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportScriptRequest;
  return proto.walletrpc.ImportScriptRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportScriptRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportScriptRequest}
 */
proto.walletrpc.ImportScriptRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRescan(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setScanFrom(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportScriptRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportScriptRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportScriptRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getRescan();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = this.getScanFrom();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ImportScriptRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes script = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes script = 2;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ImportScriptRequest.prototype.setScript = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool rescan = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportScriptRequest.prototype.getRescan = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.walletrpc.ImportScriptRequest.prototype.setRescan = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 scan_from = 4;
 * @return {number}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScanFrom = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.ImportScriptRequest.prototype.setScanFrom = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportScriptResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportScriptResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportScriptResponse.displayName = 'proto.walletrpc.ImportScriptResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportScriptResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportScriptResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportScriptResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ImportScriptResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportScriptResponse}
 */
proto.walletrpc.ImportScriptResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportScriptResponse;
  return proto.walletrpc.ImportScriptResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportScriptResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportScriptResponse}
 */
proto.walletrpc.ImportScriptResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportScriptResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportScriptResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ImportScriptResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BalanceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BalanceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BalanceRequest.displayName = 'proto.walletrpc.BalanceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BalanceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BalanceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BalanceRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BalanceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0),
    requiredConfirmations: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BalanceRequest}
 */
proto.walletrpc.BalanceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BalanceRequest;
  return proto.walletrpc.BalanceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BalanceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BalanceRequest}
 */
proto.walletrpc.BalanceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BalanceRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BalanceRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BalanceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BalanceRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.BalanceRequest.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceRequest.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 required_confirmations = 2;
 * @return {number}
 */
proto.walletrpc.BalanceRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BalanceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BalanceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BalanceResponse.displayName = 'proto.walletrpc.BalanceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BalanceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BalanceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BalanceResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.BalanceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    total: jspb.Message.getFieldWithDefault(msg, 1, 0),
    spendable: jspb.Message.getFieldWithDefault(msg, 2, 0),
    immatureReward: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BalanceResponse}
 */
proto.walletrpc.BalanceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BalanceResponse;
  return proto.walletrpc.BalanceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BalanceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BalanceResponse}
 */
proto.walletrpc.BalanceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotal(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSpendable(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setImmatureReward(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BalanceResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BalanceResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BalanceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.BalanceResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTotal();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = this.getSpendable();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getImmatureReward();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * optional int64 total = 1;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getTotal = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setTotal = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 spendable = 2;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getSpendable = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setSpendable = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 immature_reward = 3;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getImmatureReward = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setImmatureReward = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTransactionsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionsRequest.displayName = 'proto.walletrpc.GetTransactionsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    startingBlockHash: msg.getStartingBlockHash_asB64(),
    startingBlockHeight: jspb.Message.getFieldWithDefault(msg, 2, 0),
    endingBlockHash: msg.getEndingBlockHash_asB64(),
    endingBlockHeight: jspb.Message.getFieldWithDefault(msg, 4, 0),
    minimumRecentTransactions: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionsRequest}
 */
proto.walletrpc.GetTransactionsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionsRequest;
  return proto.walletrpc.GetTransactionsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionsRequest}
 */
proto.walletrpc.GetTransactionsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStartingBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readSint32());
      msg.setStartingBlockHeight(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEndingBlockHash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setEndingBlockHeight(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinimumRecentTransactions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getStartingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getStartingBlockHeight();
  if (f !== 0) {
    writer.writeSint32(
      2,
      f
    );
  }
  f = this.getEndingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = this.getEndingBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = this.getMinimumRecentTransactions();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * optional bytes starting_block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes starting_block_hash = 1;
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStartingBlockHash()));
};


/**
 * optional bytes starting_block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStartingBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GetTransactionsRequest.prototype.setStartingBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional sint32 starting_block_height = 2;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.GetTransactionsRequest.prototype.setStartingBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes ending_block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes ending_block_hash = 3;
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEndingBlockHash()));
};


/**
 * optional bytes ending_block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEndingBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GetTransactionsRequest.prototype.setEndingBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 ending_block_height = 4;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.GetTransactionsRequest.prototype.setEndingBlockHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 minimum_recent_transactions = 5;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getMinimumRecentTransactions = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.GetTransactionsRequest.prototype.setMinimumRecentTransactions = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.GetTransactionsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.GetTransactionsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionsResponse.displayName = 'proto.walletrpc.GetTransactionsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.GetTransactionsResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    minedTransactions: (f = msg.getMinedTransactions()) && proto.walletrpc.BlockDetails.toObject(includeInstance, f),
    unminedTransactionsList: jspb.Message.toObjectList(msg.getUnminedTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionsResponse}
 */
proto.walletrpc.GetTransactionsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionsResponse;
  return proto.walletrpc.GetTransactionsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionsResponse}
 */
proto.walletrpc.GetTransactionsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.BlockDetails;
      reader.readMessage(value,proto.walletrpc.BlockDetails.deserializeBinaryFromReader);
      msg.setMinedTransactions(value);
      break;
    case 2:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.addUnminedTransactions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GetTransactionsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getMinedTransactions();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.BlockDetails.serializeBinaryToWriter
    );
  }
  f = this.getUnminedTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
};


/**
 * optional BlockDetails mined_transactions = 1;
 * @return {?proto.walletrpc.BlockDetails}
 */
proto.walletrpc.GetTransactionsResponse.prototype.getMinedTransactions = function() {
  return /** @type{?proto.walletrpc.BlockDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.BlockDetails, 1));
};


/** @param {?proto.walletrpc.BlockDetails|undefined} value */
proto.walletrpc.GetTransactionsResponse.prototype.setMinedTransactions = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTransactionsResponse.prototype.clearMinedTransactions = function() {
  this.setMinedTransactions(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.GetTransactionsResponse.prototype.hasMinedTransactions = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated TransactionDetails unmined_transactions = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.GetTransactionsResponse.prototype.getUnminedTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 2));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails>} value */
proto.walletrpc.GetTransactionsResponse.prototype.setUnminedTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.GetTransactionsResponse.prototype.addUnminedTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.walletrpc.TransactionDetails, opt_index);
};


proto.walletrpc.GetTransactionsResponse.prototype.clearUnminedTransactionsList = function() {
  this.setUnminedTransactionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketPriceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketPriceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketPriceRequest.displayName = 'proto.walletrpc.TicketPriceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketPriceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketPriceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketPriceRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TicketPriceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketPriceRequest}
 */
proto.walletrpc.TicketPriceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketPriceRequest;
  return proto.walletrpc.TicketPriceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketPriceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketPriceRequest}
 */
proto.walletrpc.TicketPriceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketPriceRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketPriceRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketPriceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketPriceRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketPriceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketPriceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketPriceResponse.displayName = 'proto.walletrpc.TicketPriceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketPriceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketPriceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketPriceResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TicketPriceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketPrice: jspb.Message.getFieldWithDefault(msg, 1, 0),
    height: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketPriceResponse}
 */
proto.walletrpc.TicketPriceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketPriceResponse;
  return proto.walletrpc.TicketPriceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketPriceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketPriceResponse}
 */
proto.walletrpc.TicketPriceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTicketPrice(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketPriceResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketPriceResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketPriceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TicketPriceResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicketPrice();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = this.getHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int64 ticket_price = 1;
 * @return {number}
 */
proto.walletrpc.TicketPriceResponse.prototype.getTicketPrice = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.TicketPriceResponse.prototype.setTicketPrice = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 height = 2;
 * @return {number}
 */
proto.walletrpc.TicketPriceResponse.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.TicketPriceResponse.prototype.setHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StakeInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StakeInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StakeInfoRequest.displayName = 'proto.walletrpc.StakeInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StakeInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StakeInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StakeInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StakeInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StakeInfoRequest}
 */
proto.walletrpc.StakeInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StakeInfoRequest;
  return proto.walletrpc.StakeInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StakeInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StakeInfoRequest}
 */
proto.walletrpc.StakeInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StakeInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StakeInfoRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StakeInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StakeInfoRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StakeInfoResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StakeInfoResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StakeInfoResponse.displayName = 'proto.walletrpc.StakeInfoResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StakeInfoResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StakeInfoResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StakeInfoResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StakeInfoResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    poolSize: jspb.Message.getFieldWithDefault(msg, 1, 0),
    allMempoolTix: jspb.Message.getFieldWithDefault(msg, 2, 0),
    ownMempoolTix: jspb.Message.getFieldWithDefault(msg, 3, 0),
    immature: jspb.Message.getFieldWithDefault(msg, 4, 0),
    live: jspb.Message.getFieldWithDefault(msg, 5, 0),
    voted: jspb.Message.getFieldWithDefault(msg, 6, 0),
    missed: jspb.Message.getFieldWithDefault(msg, 7, 0),
    revoked: jspb.Message.getFieldWithDefault(msg, 8, 0),
    expired: jspb.Message.getFieldWithDefault(msg, 9, 0),
    totalSubsidy: jspb.Message.getFieldWithDefault(msg, 10, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StakeInfoResponse}
 */
proto.walletrpc.StakeInfoResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StakeInfoResponse;
  return proto.walletrpc.StakeInfoResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StakeInfoResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StakeInfoResponse}
 */
proto.walletrpc.StakeInfoResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPoolSize(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAllMempoolTix(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOwnMempoolTix(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImmature(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLive(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVoted(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMissed(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRevoked(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpired(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalSubsidy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StakeInfoResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StakeInfoResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StakeInfoResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StakeInfoResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPoolSize();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAllMempoolTix();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getOwnMempoolTix();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getImmature();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getLive();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = this.getVoted();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = this.getMissed();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = this.getRevoked();
  if (f !== 0) {
    writer.writeUint32(
      8,
      f
    );
  }
  f = this.getExpired();
  if (f !== 0) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = this.getTotalSubsidy();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
};


/**
 * optional uint32 pool_size = 1;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getPoolSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setPoolSize = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 all_mempool_tix = 2;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getAllMempoolTix = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setAllMempoolTix = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 own_mempool_tix = 3;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getOwnMempoolTix = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setOwnMempoolTix = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 immature = 4;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getImmature = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setImmature = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 live = 5;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getLive = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setLive = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 voted = 6;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getVoted = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setVoted = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint32 missed = 7;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getMissed = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setMissed = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional uint32 revoked = 8;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getRevoked = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setRevoked = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional uint32 expired = 9;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getExpired = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setExpired = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 total_subsidy = 10;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getTotalSubsidy = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setTotalSubsidy = function(value) {
  jspb.Message.setField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ChangePassphraseRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ChangePassphraseRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ChangePassphraseRequest.displayName = 'proto.walletrpc.ChangePassphraseRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ChangePassphraseRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ChangePassphraseRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: jspb.Message.getFieldWithDefault(msg, 1, 0),
    oldPassphrase: msg.getOldPassphrase_asB64(),
    newPassphrase: msg.getNewPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ChangePassphraseRequest}
 */
proto.walletrpc.ChangePassphraseRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ChangePassphraseRequest;
  return proto.walletrpc.ChangePassphraseRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ChangePassphraseRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ChangePassphraseRequest}
 */
proto.walletrpc.ChangePassphraseRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.walletrpc.ChangePassphraseRequest.Key} */ (reader.readEnum());
      msg.setKey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setOldPassphrase(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNewPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ChangePassphraseRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ChangePassphraseRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ChangePassphraseRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getKey();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = this.getOldPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getNewPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional Key key = 1;
 * @return {!proto.walletrpc.ChangePassphraseRequest.Key}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getKey = function() {
  return /** @type {!proto.walletrpc.ChangePassphraseRequest.Key} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.walletrpc.ChangePassphraseRequest.Key} value */
proto.walletrpc.ChangePassphraseRequest.prototype.setKey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes old_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes old_passphrase = 2;
 * This is a type-conversion wrapper around `getOldPassphrase()`
 * @return {string}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getOldPassphrase()));
};


/**
 * optional bytes old_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getOldPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getOldPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ChangePassphraseRequest.prototype.setOldPassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes new_passphrase = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes new_passphrase = 3;
 * This is a type-conversion wrapper around `getNewPassphrase()`
 * @return {string}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNewPassphrase()));
};


/**
 * optional bytes new_passphrase = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNewPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNewPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ChangePassphraseRequest.prototype.setNewPassphrase = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * @enum {number}
 */
proto.walletrpc.ChangePassphraseRequest.Key = {
  PRIVATE: 0,
  PUBLIC: 1
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ChangePassphraseResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ChangePassphraseResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ChangePassphraseResponse.displayName = 'proto.walletrpc.ChangePassphraseResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ChangePassphraseResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ChangePassphraseResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ChangePassphraseResponse}
 */
proto.walletrpc.ChangePassphraseResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ChangePassphraseResponse;
  return proto.walletrpc.ChangePassphraseResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ChangePassphraseResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ChangePassphraseResponse}
 */
proto.walletrpc.ChangePassphraseResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ChangePassphraseResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ChangePassphraseResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ChangePassphraseResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FundTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionRequest.displayName = 'proto.walletrpc.FundTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FundTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0),
    targetAmount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    requiredConfirmations: jspb.Message.getFieldWithDefault(msg, 3, 0),
    includeImmatureCoinbases: jspb.Message.getFieldWithDefault(msg, 4, false),
    includeChangeScript: jspb.Message.getFieldWithDefault(msg, 5, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionRequest}
 */
proto.walletrpc.FundTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionRequest;
  return proto.walletrpc.FundTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionRequest}
 */
proto.walletrpc.FundTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTargetAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeImmatureCoinbases(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeChangeScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getTargetAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getIncludeImmatureCoinbases();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = this.getIncludeChangeScript();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 target_amount = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getTargetAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionRequest.prototype.setTargetAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 required_confirmations = 3;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool include_immature_coinbases = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionRequest.prototype.getIncludeImmatureCoinbases = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.walletrpc.FundTransactionRequest.prototype.setIncludeImmatureCoinbases = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool include_change_script = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionRequest.prototype.getIncludeChangeScript = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.walletrpc.FundTransactionRequest.prototype.setIncludeChangeScript = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.FundTransactionResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.FundTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionResponse.displayName = 'proto.walletrpc.FundTransactionResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.FundTransactionResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    selectedOutputsList: jspb.Message.toObjectList(msg.getSelectedOutputsList(),
    proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject, includeInstance),
    totalAmount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    changePkScript: msg.getChangePkScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionResponse}
 */
proto.walletrpc.FundTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionResponse;
  return proto.walletrpc.FundTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionResponse}
 */
proto.walletrpc.FundTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.FundTransactionResponse.PreviousOutput;
      reader.readMessage(value,proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader);
      msg.addSelectedOutputs(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalAmount(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChangePkScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSelectedOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.FundTransactionResponse.PreviousOutput.serializeBinaryToWriter
    );
  }
  f = this.getTotalAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getChangePkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * repeated PreviousOutput selected_outputs = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>}
 */
proto.walletrpc.FundTransactionResponse.prototype.getSelectedOutputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.FundTransactionResponse.PreviousOutput, 1));
};


/** @param {!Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>} value */
proto.walletrpc.FundTransactionResponse.prototype.setSelectedOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput}
 */
proto.walletrpc.FundTransactionResponse.prototype.addSelectedOutputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.walletrpc.FundTransactionResponse.PreviousOutput, opt_index);
};


proto.walletrpc.FundTransactionResponse.prototype.clearSelectedOutputsList = function() {
  this.setSelectedOutputsList([]);
};


/**
 * optional int64 total_amount = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.prototype.getTotalAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.prototype.setTotalAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes change_pk_script = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes change_pk_script = 3;
 * This is a type-conversion wrapper around `getChangePkScript()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChangePkScript()));
};


/**
 * optional bytes change_pk_script = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChangePkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChangePkScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FundTransactionResponse.prototype.setChangePkScript = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FundTransactionResponse.PreviousOutput, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionResponse.PreviousOutput.displayName = 'proto.walletrpc.FundTransactionResponse.PreviousOutput';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    outputIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    amount: jspb.Message.getFieldWithDefault(msg, 3, 0),
    pkScript: msg.getPkScript_asB64(),
    receiveTime: jspb.Message.getFieldWithDefault(msg, 5, 0),
    fromCoinbase: jspb.Message.getFieldWithDefault(msg, 6, false),
    tree: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionResponse.PreviousOutput;
  return proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPkScript(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setReceiveTime(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFromCoinbase(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTree(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = this.getReceiveTime();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = this.getFromCoinbase();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = this.getTree();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 amount = 3;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes pk_script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes pk_script = 4;
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPkScript()));
};


/**
 * optional bytes pk_script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPkScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setPkScript = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 receive_time = 5;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getReceiveTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setReceiveTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool from_coinbase = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getFromCoinbase = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setFromCoinbase = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int32 tree = 7;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTree = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setTree = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ConstructTransactionRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.displayName = 'proto.walletrpc.ConstructTransactionRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ConstructTransactionRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    sourceAccount: jspb.Message.getFieldWithDefault(msg, 1, 0),
    requiredConfirmations: jspb.Message.getFieldWithDefault(msg, 2, 0),
    feePerKb: jspb.Message.getFieldWithDefault(msg, 3, 0),
    outputSelectionAlgorithm: jspb.Message.getFieldWithDefault(msg, 4, 0),
    nonChangeOutputsList: jspb.Message.toObjectList(msg.getNonChangeOutputsList(),
    proto.walletrpc.ConstructTransactionRequest.Output.toObject, includeInstance),
    changeDestination: (f = msg.getChangeDestination()) && proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest}
 */
proto.walletrpc.ConstructTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest;
  return proto.walletrpc.ConstructTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest}
 */
proto.walletrpc.ConstructTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSourceAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFeePerKb(value);
      break;
    case 4:
      var value = /** @type {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} */ (reader.readEnum());
      msg.setOutputSelectionAlgorithm(value);
      break;
    case 5:
      var value = new proto.walletrpc.ConstructTransactionRequest.Output;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader);
      msg.addNonChangeOutputs(value);
      break;
    case 6:
      var value = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader);
      msg.setChangeDestination(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSourceAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = this.getFeePerKb();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getOutputSelectionAlgorithm();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = this.getNonChangeOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.walletrpc.ConstructTransactionRequest.Output.serializeBinaryToWriter
    );
  }
  f = this.getChangeDestination();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint32 source_account = 1;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getSourceAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setSourceAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 required_confirmations = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 fee_per_kb = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setFeePerKb = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional OutputSelectionAlgorithm output_selection_algorithm = 4;
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getOutputSelectionAlgorithm = function() {
  return /** @type {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setOutputSelectionAlgorithm = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * repeated Output non_change_outputs = 5;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.ConstructTransactionRequest.Output>}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getNonChangeOutputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.ConstructTransactionRequest.Output>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.ConstructTransactionRequest.Output, 5));
};


/** @param {!Array.<!proto.walletrpc.ConstructTransactionRequest.Output>} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setNonChangeOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.addNonChangeOutputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.walletrpc.ConstructTransactionRequest.Output, opt_index);
};


proto.walletrpc.ConstructTransactionRequest.prototype.clearNonChangeOutputsList = function() {
  this.setNonChangeOutputsList([]);
};


/**
 * optional OutputDestination change_destination = 6;
 * @return {?proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getChangeDestination = function() {
  return /** @type{?proto.walletrpc.ConstructTransactionRequest.OutputDestination} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.ConstructTransactionRequest.OutputDestination, 6));
};


/** @param {?proto.walletrpc.ConstructTransactionRequest.OutputDestination|undefined} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setChangeDestination = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.walletrpc.ConstructTransactionRequest.prototype.clearChangeDestination = function() {
  this.setChangeDestination(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.hasChangeDestination = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * @enum {number}
 */
proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm = {
  UNSPECIFIED: 0,
  ALL: 1
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest.OutputDestination, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.OutputDestination.displayName = 'proto.walletrpc.ConstructTransactionRequest.OutputDestination';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, ""),
    script: msg.getScript_asB64(),
    scriptVersion: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
  return proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setScriptVersion(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getScriptVersion();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes script = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes script = 2;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setScript = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 script_version = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScriptVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setScriptVersion = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest.Output = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest.Output, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.Output.displayName = 'proto.walletrpc.ConstructTransactionRequest.Output';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.Output.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.Output.toObject = function(includeInstance, msg) {
  var f, obj = {
    destination: (f = msg.getDestination()) && proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(includeInstance, f),
    amount: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output}
 */
proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest.Output;
  return proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output}
 */
proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader);
      msg.setDestination(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.Output.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getDestination();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter
    );
  }
  f = this.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional OutputDestination destination = 1;
 * @return {?proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.getDestination = function() {
  return /** @type{?proto.walletrpc.ConstructTransactionRequest.OutputDestination} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.ConstructTransactionRequest.OutputDestination, 1));
};


/** @param {?proto.walletrpc.ConstructTransactionRequest.OutputDestination|undefined} value */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.setDestination = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.ConstructTransactionRequest.Output.prototype.clearDestination = function() {
  this.setDestination(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.hasDestination = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int64 amount = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionResponse.displayName = 'proto.walletrpc.ConstructTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    unsignedTransaction: msg.getUnsignedTransaction_asB64(),
    totalPreviousOutputAmount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    totalOutputAmount: jspb.Message.getFieldWithDefault(msg, 3, 0),
    estimatedSignedSize: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionResponse}
 */
proto.walletrpc.ConstructTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionResponse;
  return proto.walletrpc.ConstructTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionResponse}
 */
proto.walletrpc.ConstructTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setUnsignedTransaction(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalPreviousOutputAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalOutputAmount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setEstimatedSignedSize(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.ConstructTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getUnsignedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getTotalPreviousOutputAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = this.getTotalOutputAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getEstimatedSignedSize();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional bytes unsigned_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes unsigned_transaction = 1;
 * This is a type-conversion wrapper around `getUnsignedTransaction()`
 * @return {string}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getUnsignedTransaction()));
};


/**
 * optional bytes unsigned_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUnsignedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getUnsignedTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ConstructTransactionResponse.prototype.setUnsignedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 total_previous_output_amount = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getTotalPreviousOutputAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionResponse.prototype.setTotalPreviousOutputAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_output_amount = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getTotalOutputAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionResponse.prototype.setTotalOutputAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 estimated_signed_size = 4;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getEstimatedSignedSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionResponse.prototype.setEstimatedSignedSize = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionRequest.displayName = 'proto.walletrpc.SignTransactionRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionRequest.repeatedFields_ = [3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    serializedTransaction: msg.getSerializedTransaction_asB64(),
    inputIndexesList: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionRequest}
 */
proto.walletrpc.SignTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionRequest;
  return proto.walletrpc.SignTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionRequest}
 */
proto.walletrpc.SignTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTransaction(value);
      break;
    case 3:
      var value = /** @type {!Array.<number>} */ (reader.readPackedUint32());
      msg.setInputIndexesList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getSerializedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getInputIndexesList();
  if (f.length > 0) {
    writer.writePackedUint32(
      3,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignTransactionRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes serialized_transaction = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes serialized_transaction = 2;
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTransaction()));
};


/**
 * optional bytes serialized_transaction = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignTransactionRequest.prototype.setSerializedTransaction = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * repeated uint32 input_indexes = 3;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<number>}
 */
proto.walletrpc.SignTransactionRequest.prototype.getInputIndexesList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getField(this, 3));
};


/** @param {!Array.<number>} value */
proto.walletrpc.SignTransactionRequest.prototype.setInputIndexesList = function(value) {
  jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.walletrpc.SignTransactionRequest.prototype.addInputIndexes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


proto.walletrpc.SignTransactionRequest.prototype.clearInputIndexesList = function() {
  this.setInputIndexesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionResponse.displayName = 'proto.walletrpc.SignTransactionResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SignTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transaction: msg.getTransaction_asB64(),
    unsignedInputIndexesList: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionResponse}
 */
proto.walletrpc.SignTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionResponse;
  return proto.walletrpc.SignTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionResponse}
 */
proto.walletrpc.SignTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransaction(value);
      break;
    case 2:
      var value = /** @type {!Array.<number>} */ (reader.readPackedUint32());
      msg.setUnsignedInputIndexesList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SignTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getUnsignedInputIndexesList();
  if (f.length > 0) {
    writer.writePackedUint32(
      2,
      f
    );
  }
};


/**
 * optional bytes transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction = 1;
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {string}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransaction()));
};


/**
 * optional bytes transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignTransactionResponse.prototype.setTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated uint32 unsigned_input_indexes = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<number>}
 */
proto.walletrpc.SignTransactionResponse.prototype.getUnsignedInputIndexesList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getField(this, 2));
};


/** @param {!Array.<number>} value */
proto.walletrpc.SignTransactionResponse.prototype.setUnsignedInputIndexesList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.walletrpc.SignTransactionResponse.prototype.addUnsignedInputIndexes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.walletrpc.SignTransactionResponse.prototype.clearUnsignedInputIndexesList = function() {
  this.setUnsignedInputIndexesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishTransactionRequest.displayName = 'proto.walletrpc.PublishTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    signedTransaction: msg.getSignedTransaction_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishTransactionRequest}
 */
proto.walletrpc.PublishTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishTransactionRequest;
  return proto.walletrpc.PublishTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishTransactionRequest}
 */
proto.walletrpc.PublishTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignedTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishTransactionRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSignedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes signed_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes signed_transaction = 1;
 * This is a type-conversion wrapper around `getSignedTransaction()`
 * @return {string}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignedTransaction()));
};


/**
 * optional bytes signed_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignedTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.PublishTransactionRequest.prototype.setSignedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishTransactionResponse.displayName = 'proto.walletrpc.PublishTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishTransactionResponse}
 */
proto.walletrpc.PublishTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishTransactionResponse;
  return proto.walletrpc.PublishTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishTransactionResponse}
 */
proto.walletrpc.PublishTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PublishTransactionResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.PublishTransactionResponse.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PurchaseTicketsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PurchaseTicketsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PurchaseTicketsRequest.displayName = 'proto.walletrpc.PurchaseTicketsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PurchaseTicketsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PurchaseTicketsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: jspb.Message.getFieldWithDefault(msg, 2, 0),
    spendLimit: jspb.Message.getFieldWithDefault(msg, 3, 0),
    requiredConfirmations: jspb.Message.getFieldWithDefault(msg, 4, 0),
    ticketAddress: jspb.Message.getFieldWithDefault(msg, 5, ""),
    numTickets: jspb.Message.getFieldWithDefault(msg, 6, 0),
    poolAddress: jspb.Message.getFieldWithDefault(msg, 7, ""),
    poolFees: +jspb.Message.getFieldWithDefault(msg, 8, 0.0),
    expiry: jspb.Message.getFieldWithDefault(msg, 9, 0),
    txFee: jspb.Message.getFieldWithDefault(msg, 10, 0),
    ticketFee: jspb.Message.getFieldWithDefault(msg, 11, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PurchaseTicketsRequest}
 */
proto.walletrpc.PurchaseTicketsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PurchaseTicketsRequest;
  return proto.walletrpc.PurchaseTicketsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PurchaseTicketsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PurchaseTicketsRequest}
 */
proto.walletrpc.PurchaseTicketsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSpendLimit(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRequiredConfirmations(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setTicketAddress(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumTickets(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpiry(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTxFee(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTicketFee(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PurchaseTicketsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PurchaseTicketsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getSpendLimit();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = this.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getTicketAddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = this.getNumTickets();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = this.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = this.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      8,
      f
    );
  }
  f = this.getExpiry();
  if (f !== 0) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = this.getTxFee();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = this.getTicketFee();
  if (f !== 0) {
    writer.writeInt64(
      11,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 spend_limit = 3;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getSpendLimit = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setSpendLimit = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 required_confirmations = 4;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string ticket_address = 5;
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTicketAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTicketAddress = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 num_tickets = 6;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getNumTickets = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setNumTickets = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional string pool_address = 7;
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/** @param {string} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional double pool_fees = 8;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPoolFees = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 8, 0.0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional uint32 expiry = 9;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 tx_fee = 10;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTxFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTxFee = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int64 ticket_fee = 11;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTicketFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTicketFee = function(value) {
  jspb.Message.setField(this, 11, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PurchaseTicketsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.PurchaseTicketsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.PurchaseTicketsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PurchaseTicketsResponse.displayName = 'proto.walletrpc.PurchaseTicketsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.PurchaseTicketsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PurchaseTicketsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PurchaseTicketsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketHashesList: msg.getTicketHashesList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PurchaseTicketsResponse}
 */
proto.walletrpc.PurchaseTicketsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PurchaseTicketsResponse;
  return proto.walletrpc.PurchaseTicketsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PurchaseTicketsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PurchaseTicketsResponse}
 */
proto.walletrpc.PurchaseTicketsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addTicketHashes(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PurchaseTicketsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PurchaseTicketsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTicketHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
};


/**
 * repeated bytes ticket_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getField(this, 1));
};


/**
 * repeated bytes ticket_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * This is a type-conversion wrapper around `getTicketHashesList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getTicketHashesList()));
};


/**
 * repeated bytes ticket_hashes = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTicketHashesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getTicketHashesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.walletrpc.PurchaseTicketsResponse.prototype.setTicketHashesList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.addTicketHashes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.walletrpc.PurchaseTicketsResponse.prototype.clearTicketHashesList = function() {
  this.setTicketHashesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.LoadActiveDataFiltersRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.LoadActiveDataFiltersRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.LoadActiveDataFiltersRequest.displayName = 'proto.walletrpc.LoadActiveDataFiltersRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.LoadActiveDataFiltersRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.LoadActiveDataFiltersRequest}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.LoadActiveDataFiltersRequest;
  return proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.LoadActiveDataFiltersRequest}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.LoadActiveDataFiltersRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.LoadActiveDataFiltersResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.LoadActiveDataFiltersResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.LoadActiveDataFiltersResponse.displayName = 'proto.walletrpc.LoadActiveDataFiltersResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.LoadActiveDataFiltersResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.LoadActiveDataFiltersResponse}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.LoadActiveDataFiltersResponse;
  return proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.LoadActiveDataFiltersResponse}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.LoadActiveDataFiltersResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionNotificationsRequest.displayName = 'proto.walletrpc.TransactionNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionNotificationsRequest}
 */
proto.walletrpc.TransactionNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionNotificationsRequest;
  return proto.walletrpc.TransactionNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionNotificationsRequest}
 */
proto.walletrpc.TransactionNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.TransactionNotificationsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.TransactionNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionNotificationsResponse.displayName = 'proto.walletrpc.TransactionNotificationsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.TransactionNotificationsResponse.repeatedFields_ = [1,2,3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    attachedBlocksList: jspb.Message.toObjectList(msg.getAttachedBlocksList(),
    proto.walletrpc.BlockDetails.toObject, includeInstance),
    detachedBlocksList: msg.getDetachedBlocksList_asB64(),
    unminedTransactionsList: jspb.Message.toObjectList(msg.getUnminedTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance),
    unminedTransactionHashesList: msg.getUnminedTransactionHashesList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionNotificationsResponse}
 */
proto.walletrpc.TransactionNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionNotificationsResponse;
  return proto.walletrpc.TransactionNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionNotificationsResponse}
 */
proto.walletrpc.TransactionNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.BlockDetails;
      reader.readMessage(value,proto.walletrpc.BlockDetails.deserializeBinaryFromReader);
      msg.addAttachedBlocks(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addDetachedBlocks(value);
      break;
    case 3:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.addUnminedTransactions(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addUnminedTransactionHashes(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAttachedBlocksList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.BlockDetails.serializeBinaryToWriter
    );
  }
  f = this.getDetachedBlocksList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
  f = this.getUnminedTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
  f = this.getUnminedTransactionHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      4,
      f
    );
  }
};


/**
 * repeated BlockDetails attached_blocks = 1;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.BlockDetails>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getAttachedBlocksList = function() {
  return /** @type{!Array.<!proto.walletrpc.BlockDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.BlockDetails, 1));
};


/** @param {!Array.<!proto.walletrpc.BlockDetails>} value */
proto.walletrpc.TransactionNotificationsResponse.prototype.setAttachedBlocksList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.walletrpc.BlockDetails=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.BlockDetails}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.addAttachedBlocks = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.walletrpc.BlockDetails, opt_index);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearAttachedBlocksList = function() {
  this.setAttachedBlocksList([]);
};


/**
 * repeated bytes detached_blocks = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getField(this, 2));
};


/**
 * repeated bytes detached_blocks = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * This is a type-conversion wrapper around `getDetachedBlocksList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getDetachedBlocksList()));
};


/**
 * repeated bytes detached_blocks = 2;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDetachedBlocksList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getDetachedBlocksList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.walletrpc.TransactionNotificationsResponse.prototype.setDetachedBlocksList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.addDetachedBlocks = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearDetachedBlocksList = function() {
  this.setDetachedBlocksList([]);
};


/**
 * repeated TransactionDetails unmined_transactions = 3;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 3));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails>} value */
proto.walletrpc.TransactionNotificationsResponse.prototype.setUnminedTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.addUnminedTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.walletrpc.TransactionDetails, opt_index);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearUnminedTransactionsList = function() {
  this.setUnminedTransactionsList([]);
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getField(this, 4));
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * This is a type-conversion wrapper around `getUnminedTransactionHashesList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getUnminedTransactionHashesList()));
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * If you change this array by adding, removing or replacing elements, or if you
 * replace the array itself, then you must call the setter to update it.
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUnminedTransactionHashesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getUnminedTransactionHashesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.walletrpc.TransactionNotificationsResponse.prototype.setUnminedTransactionHashesList = function(value) {
  jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.addUnminedTransactionHashes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearUnminedTransactionHashesList = function() {
  this.setUnminedTransactionHashesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SpentnessNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SpentnessNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SpentnessNotificationsRequest.displayName = 'proto.walletrpc.SpentnessNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SpentnessNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SpentnessNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SpentnessNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SpentnessNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0),
    noNotifyUnspent: jspb.Message.getFieldWithDefault(msg, 2, false),
    noNotifySpent: jspb.Message.getFieldWithDefault(msg, 3, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SpentnessNotificationsRequest}
 */
proto.walletrpc.SpentnessNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SpentnessNotificationsRequest;
  return proto.walletrpc.SpentnessNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SpentnessNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SpentnessNotificationsRequest}
 */
proto.walletrpc.SpentnessNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setNoNotifyUnspent(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setNoNotifySpent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SpentnessNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpentnessNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SpentnessNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpentnessNotificationsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getNoNotifyUnspent();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = this.getNoNotifySpent();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.SpentnessNotificationsRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.SpentnessNotificationsRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool no_notify_unspent = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.SpentnessNotificationsRequest.prototype.getNoNotifyUnspent = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.walletrpc.SpentnessNotificationsRequest.prototype.setNoNotifyUnspent = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool no_notify_spent = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.SpentnessNotificationsRequest.prototype.getNoNotifySpent = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.walletrpc.SpentnessNotificationsRequest.prototype.setNoNotifySpent = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SpentnessNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SpentnessNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SpentnessNotificationsResponse.displayName = 'proto.walletrpc.SpentnessNotificationsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SpentnessNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SpentnessNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SpentnessNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    outputIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    spender: (f = msg.getSpender()) && proto.walletrpc.SpentnessNotificationsResponse.Spender.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SpentnessNotificationsResponse}
 */
proto.walletrpc.SpentnessNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SpentnessNotificationsResponse;
  return proto.walletrpc.SpentnessNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SpentnessNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SpentnessNotificationsResponse}
 */
proto.walletrpc.SpentnessNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    case 3:
      var value = new proto.walletrpc.SpentnessNotificationsResponse.Spender;
      reader.readMessage(value,proto.walletrpc.SpentnessNotificationsResponse.Spender.deserializeBinaryFromReader);
      msg.setSpender(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SpentnessNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpentnessNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = this.getSpender();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.walletrpc.SpentnessNotificationsResponse.Spender.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SpentnessNotificationsResponse.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.SpentnessNotificationsResponse.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional Spender spender = 3;
 * @return {?proto.walletrpc.SpentnessNotificationsResponse.Spender}
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.getSpender = function() {
  return /** @type{?proto.walletrpc.SpentnessNotificationsResponse.Spender} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.SpentnessNotificationsResponse.Spender, 3));
};


/** @param {?proto.walletrpc.SpentnessNotificationsResponse.Spender|undefined} value */
proto.walletrpc.SpentnessNotificationsResponse.prototype.setSpender = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.walletrpc.SpentnessNotificationsResponse.prototype.clearSpender = function() {
  this.setSpender(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.SpentnessNotificationsResponse.prototype.hasSpender = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SpentnessNotificationsResponse.Spender, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SpentnessNotificationsResponse.Spender.displayName = 'proto.walletrpc.SpentnessNotificationsResponse.Spender';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SpentnessNotificationsResponse.Spender.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SpentnessNotificationsResponse.Spender} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    inputIndex: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SpentnessNotificationsResponse.Spender}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SpentnessNotificationsResponse.Spender;
  return proto.walletrpc.SpentnessNotificationsResponse.Spender.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SpentnessNotificationsResponse.Spender} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SpentnessNotificationsResponse.Spender}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInputIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SpentnessNotificationsResponse.Spender} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getInputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 input_index = 2;
 * @return {number}
 */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.getInputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.SpentnessNotificationsResponse.Spender.prototype.setInputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNotificationsRequest.displayName = 'proto.walletrpc.AccountNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNotificationsRequest}
 */
proto.walletrpc.AccountNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNotificationsRequest;
  return proto.walletrpc.AccountNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNotificationsRequest}
 */
proto.walletrpc.AccountNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNotificationsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNotificationsResponse.displayName = 'proto.walletrpc.AccountNotificationsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0),
    accountName: jspb.Message.getFieldWithDefault(msg, 2, ""),
    externalKeyCount: jspb.Message.getFieldWithDefault(msg, 3, 0),
    internalKeyCount: jspb.Message.getFieldWithDefault(msg, 4, 0),
    importedKeyCount: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNotificationsResponse}
 */
proto.walletrpc.AccountNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNotificationsResponse;
  return proto.walletrpc.AccountNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNotificationsResponse}
 */
proto.walletrpc.AccountNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExternalKeyCount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInternalKeyCount(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImportedKeyCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.AccountNotificationsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getExternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = this.getInternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = this.getImportedKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 external_key_count = 3;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getExternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setExternalKeyCount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 internal_key_count = 4;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getInternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setInternalKeyCount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 imported_key_count = 5;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getImportedKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setImportedKeyCount = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateWalletRequest.displayName = 'proto.walletrpc.CreateWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CreateWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    publicPassphrase: msg.getPublicPassphrase_asB64(),
    privatePassphrase: msg.getPrivatePassphrase_asB64(),
    seed: msg.getSeed_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateWalletRequest}
 */
proto.walletrpc.CreateWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateWalletRequest;
  return proto.walletrpc.CreateWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateWalletRequest}
 */
proto.walletrpc.CreateWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSeed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWalletRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWalletRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPublicPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getSeed_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional bytes public_passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes public_passphrase = 1;
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicPassphrase()));
};


/**
 * optional bytes public_passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateWalletRequest.prototype.setPublicPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes private_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes private_passphrase = 2;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateWalletRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes seed = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes seed = 3;
 * This is a type-conversion wrapper around `getSeed()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSeed()));
};


/**
 * optional bytes seed = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSeed()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSeed()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateWalletRequest.prototype.setSeed = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateWalletResponse.displayName = 'proto.walletrpc.CreateWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CreateWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateWalletResponse}
 */
proto.walletrpc.CreateWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateWalletResponse;
  return proto.walletrpc.CreateWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateWalletResponse}
 */
proto.walletrpc.CreateWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWalletResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CreateWalletResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.OpenWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.OpenWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.OpenWalletRequest.displayName = 'proto.walletrpc.OpenWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.OpenWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.OpenWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.OpenWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.OpenWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    publicPassphrase: msg.getPublicPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.OpenWalletRequest}
 */
proto.walletrpc.OpenWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.OpenWalletRequest;
  return proto.walletrpc.OpenWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.OpenWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.OpenWalletRequest}
 */
proto.walletrpc.OpenWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.OpenWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.OpenWalletRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.OpenWalletRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getPublicPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes public_passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes public_passphrase = 1;
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {string}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicPassphrase()));
};


/**
 * optional bytes public_passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.OpenWalletRequest.prototype.setPublicPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.OpenWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.OpenWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.OpenWalletResponse.displayName = 'proto.walletrpc.OpenWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.OpenWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.OpenWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.OpenWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.OpenWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.OpenWalletResponse}
 */
proto.walletrpc.OpenWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.OpenWalletResponse;
  return proto.walletrpc.OpenWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.OpenWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.OpenWalletResponse}
 */
proto.walletrpc.OpenWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.OpenWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.OpenWalletResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.OpenWalletResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CloseWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CloseWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CloseWalletRequest.displayName = 'proto.walletrpc.CloseWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CloseWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CloseWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CloseWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CloseWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CloseWalletRequest}
 */
proto.walletrpc.CloseWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CloseWalletRequest;
  return proto.walletrpc.CloseWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CloseWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CloseWalletRequest}
 */
proto.walletrpc.CloseWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CloseWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CloseWalletRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CloseWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CloseWalletRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CloseWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CloseWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CloseWalletResponse.displayName = 'proto.walletrpc.CloseWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CloseWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CloseWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CloseWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.CloseWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CloseWalletResponse}
 */
proto.walletrpc.CloseWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CloseWalletResponse;
  return proto.walletrpc.CloseWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CloseWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CloseWalletResponse}
 */
proto.walletrpc.CloseWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CloseWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CloseWalletResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CloseWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.CloseWalletResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.WalletExistsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.WalletExistsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.WalletExistsRequest.displayName = 'proto.walletrpc.WalletExistsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.WalletExistsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.WalletExistsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.WalletExistsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.WalletExistsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.WalletExistsRequest}
 */
proto.walletrpc.WalletExistsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.WalletExistsRequest;
  return proto.walletrpc.WalletExistsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.WalletExistsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.WalletExistsRequest}
 */
proto.walletrpc.WalletExistsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.WalletExistsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.WalletExistsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.WalletExistsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.WalletExistsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.WalletExistsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.WalletExistsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.WalletExistsResponse.displayName = 'proto.walletrpc.WalletExistsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.WalletExistsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.WalletExistsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.WalletExistsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.WalletExistsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    exists: jspb.Message.getFieldWithDefault(msg, 1, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.WalletExistsResponse}
 */
proto.walletrpc.WalletExistsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.WalletExistsResponse;
  return proto.walletrpc.WalletExistsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.WalletExistsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.WalletExistsResponse}
 */
proto.walletrpc.WalletExistsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setExists(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.WalletExistsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.WalletExistsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.WalletExistsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.WalletExistsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getExists();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool exists = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.WalletExistsResponse.prototype.getExists = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.walletrpc.WalletExistsResponse.prototype.setExists = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartConsensusRpcRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartConsensusRpcRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartConsensusRpcRequest.displayName = 'proto.walletrpc.StartConsensusRpcRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartConsensusRpcRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartConsensusRpcRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    networkAddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    username: jspb.Message.getFieldWithDefault(msg, 2, ""),
    password: msg.getPassword_asB64(),
    certificate: msg.getCertificate_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartConsensusRpcRequest}
 */
proto.walletrpc.StartConsensusRpcRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartConsensusRpcRequest;
  return proto.walletrpc.StartConsensusRpcRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartConsensusRpcRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartConsensusRpcRequest}
 */
proto.walletrpc.StartConsensusRpcRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setNetworkAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUsername(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassword(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCertificate(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartConsensusRpcRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartConsensusRpcRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getNetworkAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = this.getUsername();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getPassword_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = this.getCertificate_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional string network_address = 1;
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getNetworkAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.StartConsensusRpcRequest.prototype.setNetworkAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string username = 2;
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getUsername = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.StartConsensusRpcRequest.prototype.setUsername = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes password = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes password = 3;
 * This is a type-conversion wrapper around `getPassword()`
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassword()));
};


/**
 * optional bytes password = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassword()`
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassword()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.StartConsensusRpcRequest.prototype.setPassword = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes certificate = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes certificate = 4;
 * This is a type-conversion wrapper around `getCertificate()`
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCertificate()));
};


/**
 * optional bytes certificate = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCertificate()`
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCertificate()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.StartConsensusRpcRequest.prototype.setCertificate = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartConsensusRpcResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartConsensusRpcResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartConsensusRpcResponse.displayName = 'proto.walletrpc.StartConsensusRpcResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartConsensusRpcResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartConsensusRpcResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartConsensusRpcResponse}
 */
proto.walletrpc.StartConsensusRpcResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartConsensusRpcResponse;
  return proto.walletrpc.StartConsensusRpcResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartConsensusRpcResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartConsensusRpcResponse}
 */
proto.walletrpc.StartConsensusRpcResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartConsensusRpcResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartConsensusRpcResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DiscoverAddressesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DiscoverAddressesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DiscoverAddressesRequest.displayName = 'proto.walletrpc.DiscoverAddressesRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DiscoverAddressesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DiscoverAddressesRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    discoverAccounts: jspb.Message.getFieldWithDefault(msg, 1, false),
    privatePassphrase: msg.getPrivatePassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DiscoverAddressesRequest}
 */
proto.walletrpc.DiscoverAddressesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DiscoverAddressesRequest;
  return proto.walletrpc.DiscoverAddressesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DiscoverAddressesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DiscoverAddressesRequest}
 */
proto.walletrpc.DiscoverAddressesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDiscoverAccounts(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DiscoverAddressesRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DiscoverAddressesRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getDiscoverAccounts();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = this.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bool discover_accounts = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getDiscoverAccounts = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.walletrpc.DiscoverAddressesRequest.prototype.setDiscoverAccounts = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes private_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes private_passphrase = 2;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DiscoverAddressesRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DiscoverAddressesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DiscoverAddressesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DiscoverAddressesResponse.displayName = 'proto.walletrpc.DiscoverAddressesResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DiscoverAddressesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DiscoverAddressesResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DiscoverAddressesResponse}
 */
proto.walletrpc.DiscoverAddressesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DiscoverAddressesResponse;
  return proto.walletrpc.DiscoverAddressesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DiscoverAddressesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DiscoverAddressesResponse}
 */
proto.walletrpc.DiscoverAddressesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DiscoverAddressesResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DiscoverAddressesResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SubscribeToBlockNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SubscribeToBlockNotificationsRequest.displayName = 'proto.walletrpc.SubscribeToBlockNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SubscribeToBlockNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsRequest}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SubscribeToBlockNotificationsRequest;
  return proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsRequest}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SubscribeToBlockNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SubscribeToBlockNotificationsResponse.displayName = 'proto.walletrpc.SubscribeToBlockNotificationsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SubscribeToBlockNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsResponse}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SubscribeToBlockNotificationsResponse;
  return proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsResponse}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchHeadersRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchHeadersRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchHeadersRequest.displayName = 'proto.walletrpc.FetchHeadersRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchHeadersRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchHeadersRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchHeadersRequest}
 */
proto.walletrpc.FetchHeadersRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchHeadersRequest;
  return proto.walletrpc.FetchHeadersRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchHeadersRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchHeadersRequest}
 */
proto.walletrpc.FetchHeadersRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchHeadersRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchHeadersResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchHeadersResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchHeadersResponse.displayName = 'proto.walletrpc.FetchHeadersResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchHeadersResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchHeadersResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    fetchedHeadersCount: jspb.Message.getFieldWithDefault(msg, 1, 0),
    firstNewBlockHash: msg.getFirstNewBlockHash_asB64(),
    firstNewBlockHeight: jspb.Message.getFieldWithDefault(msg, 3, 0),
    mainChainTipBlockHash: msg.getMainChainTipBlockHash_asB64(),
    mainChainTipBlockHeight: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchHeadersResponse}
 */
proto.walletrpc.FetchHeadersResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchHeadersResponse;
  return proto.walletrpc.FetchHeadersResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchHeadersResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchHeadersResponse}
 */
proto.walletrpc.FetchHeadersResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFetchedHeadersCount(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setFirstNewBlockHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFirstNewBlockHeight(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMainChainTipBlockHash(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMainChainTipBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchHeadersResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.FetchHeadersResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getFetchedHeadersCount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = this.getFirstNewBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = this.getFirstNewBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = this.getMainChainTipBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = this.getMainChainTipBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * optional uint32 fetched_headers_count = 1;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFetchedHeadersCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.FetchHeadersResponse.prototype.setFetchedHeadersCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes first_new_block_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes first_new_block_hash = 2;
 * This is a type-conversion wrapper around `getFirstNewBlockHash()`
 * @return {string}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getFirstNewBlockHash()));
};


/**
 * optional bytes first_new_block_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFirstNewBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getFirstNewBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FetchHeadersResponse.prototype.setFirstNewBlockHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 first_new_block_height = 3;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.FetchHeadersResponse.prototype.setFirstNewBlockHeight = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * This is a type-conversion wrapper around `getMainChainTipBlockHash()`
 * @return {string}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMainChainTipBlockHash()));
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMainChainTipBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMainChainTipBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FetchHeadersResponse.prototype.setMainChainTipBlockHash = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 main_chain_tip_block_height = 5;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.FetchHeadersResponse.prototype.setMainChainTipBlockHeight = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GenerateRandomSeedRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GenerateRandomSeedRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GenerateRandomSeedRequest.displayName = 'proto.walletrpc.GenerateRandomSeedRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GenerateRandomSeedRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    seedLength: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GenerateRandomSeedRequest}
 */
proto.walletrpc.GenerateRandomSeedRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GenerateRandomSeedRequest;
  return proto.walletrpc.GenerateRandomSeedRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GenerateRandomSeedRequest}
 */
proto.walletrpc.GenerateRandomSeedRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSeedLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GenerateRandomSeedRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSeedLength();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 seed_length = 1;
 * @return {number}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.getSeedLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.GenerateRandomSeedRequest.prototype.setSeedLength = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GenerateRandomSeedResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GenerateRandomSeedResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GenerateRandomSeedResponse.displayName = 'proto.walletrpc.GenerateRandomSeedResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GenerateRandomSeedResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    seedBytes: msg.getSeedBytes_asB64(),
    seedHex: jspb.Message.getFieldWithDefault(msg, 2, ""),
    seedMnemonic: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GenerateRandomSeedResponse}
 */
proto.walletrpc.GenerateRandomSeedResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GenerateRandomSeedResponse;
  return proto.walletrpc.GenerateRandomSeedResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GenerateRandomSeedResponse}
 */
proto.walletrpc.GenerateRandomSeedResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSeedBytes(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSeedHex(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setSeedMnemonic(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GenerateRandomSeedResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getSeedBytes_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = this.getSeedHex();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = this.getSeedMnemonic();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional bytes seed_bytes = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes seed_bytes = 1;
 * This is a type-conversion wrapper around `getSeedBytes()`
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSeedBytes()));
};


/**
 * optional bytes seed_bytes = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSeedBytes()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSeedBytes()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedBytes = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string seed_hex = 2;
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedHex = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedHex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string seed_mnemonic = 3;
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedMnemonic = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedMnemonic = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeSeedRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeSeedRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeSeedRequest.displayName = 'proto.walletrpc.DecodeSeedRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeSeedRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeSeedRequest} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    userInput: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeSeedRequest}
 */
proto.walletrpc.DecodeSeedRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeSeedRequest;
  return proto.walletrpc.DecodeSeedRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeSeedRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeSeedRequest}
 */
proto.walletrpc.DecodeSeedRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserInput(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeSeedRequest} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeSeedRequest.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeSeedRequest.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getUserInput();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string user_input = 1;
 * @return {string}
 */
proto.walletrpc.DecodeSeedRequest.prototype.getUserInput = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.DecodeSeedRequest.prototype.setUserInput = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeSeedResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeSeedResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeSeedResponse.displayName = 'proto.walletrpc.DecodeSeedResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeSeedResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeSeedResponse} msg The msg instance to transform.
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    decodedSeed: msg.getDecodedSeed_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeSeedResponse}
 */
proto.walletrpc.DecodeSeedResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeSeedResponse;
  return proto.walletrpc.DecodeSeedResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeSeedResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeSeedResponse}
 */
proto.walletrpc.DecodeSeedResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDecodedSeed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Class method variant: serializes the given message to binary data
 * (in protobuf wire format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeSeedResponse} message
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeSeedResponse.serializeBinaryToWriter = function(message, writer) {
  message.serializeBinaryToWriter(writer);
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  this.serializeBinaryToWriter(writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the message to binary data (in protobuf wire format),
 * writing to the given BinaryWriter.
 * @param {!jspb.BinaryWriter} writer
 */
proto.walletrpc.DecodeSeedResponse.prototype.serializeBinaryToWriter = function (writer) {
  var f = undefined;
  f = this.getDecodedSeed_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes decoded_seed = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes decoded_seed = 1;
 * This is a type-conversion wrapper around `getDecodedSeed()`
 * @return {string}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDecodedSeed()));
};


/**
 * optional bytes decoded_seed = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDecodedSeed()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDecodedSeed()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DecodeSeedResponse.prototype.setDecodedSeed = function(value) {
  jspb.Message.setField(this, 1, value);
};


goog.object.extend(exports, proto.walletrpc);
