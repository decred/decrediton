/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.walletrpc.AccountBalance', null, global);
goog.exportSymbol('proto.walletrpc.AccountNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountNumberRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountNumberResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountsRequest', null, global);
goog.exportSymbol('proto.walletrpc.AccountsResponse', null, global);
goog.exportSymbol('proto.walletrpc.AccountsResponse.Account', null, global);
goog.exportSymbol('proto.walletrpc.AgendasRequest', null, global);
goog.exportSymbol('proto.walletrpc.AgendasResponse', null, global);
goog.exportSymbol('proto.walletrpc.AgendasResponse.Agenda', null, global);
goog.exportSymbol('proto.walletrpc.AgendasResponse.Choice', null, global);
goog.exportSymbol('proto.walletrpc.BalanceRequest', null, global);
goog.exportSymbol('proto.walletrpc.BalanceResponse', null, global);
goog.exportSymbol('proto.walletrpc.BlockDetails', null, global);
goog.exportSymbol('proto.walletrpc.BlockInfoRequest', null, global);
goog.exportSymbol('proto.walletrpc.BlockInfoResponse', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseRequest', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseRequest.Key', null, global);
goog.exportSymbol('proto.walletrpc.ChangePassphraseResponse', null, global);
goog.exportSymbol('proto.walletrpc.CloseWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.CloseWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.ConfirmationNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.ConfirmationNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.Output', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.OutputDestination', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm', null, global);
goog.exportSymbol('proto.walletrpc.ConstructTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.CreateSignatureRequest', null, global);
goog.exportSymbol('proto.walletrpc.CreateSignatureRequest.SigHashType', null, global);
goog.exportSymbol('proto.walletrpc.CreateSignatureResponse', null, global);
goog.exportSymbol('proto.walletrpc.CreateWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.CreateWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.DecodeRawTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.DecodeRawTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.DecodeSeedRequest', null, global);
goog.exportSymbol('proto.walletrpc.DecodeSeedResponse', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction.Input', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction.Input.TreeType', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction.Output', null, global);
goog.exportSymbol('proto.walletrpc.DecodedTransaction.Output.ScriptClass', null, global);
goog.exportSymbol('proto.walletrpc.DiscoverAddressesRequest', null, global);
goog.exportSymbol('proto.walletrpc.DiscoverAddressesResponse', null, global);
goog.exportSymbol('proto.walletrpc.FetchHeadersRequest', null, global);
goog.exportSymbol('proto.walletrpc.FetchHeadersResponse', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.FundTransactionResponse.PreviousOutput', null, global);
goog.exportSymbol('proto.walletrpc.GenerateRandomSeedRequest', null, global);
goog.exportSymbol('proto.walletrpc.GenerateRandomSeedResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsResponse.TicketDetails', null, global);
goog.exportSymbol('proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionsRequest', null, global);
goog.exportSymbol('proto.walletrpc.GetTransactionsResponse', null, global);
goog.exportSymbol('proto.walletrpc.ImportPrivateKeyRequest', null, global);
goog.exportSymbol('proto.walletrpc.ImportPrivateKeyResponse', null, global);
goog.exportSymbol('proto.walletrpc.ImportScriptRequest', null, global);
goog.exportSymbol('proto.walletrpc.ImportScriptResponse', null, global);
goog.exportSymbol('proto.walletrpc.LoadActiveDataFiltersRequest', null, global);
goog.exportSymbol('proto.walletrpc.LoadActiveDataFiltersResponse', null, global);
goog.exportSymbol('proto.walletrpc.NetworkRequest', null, global);
goog.exportSymbol('proto.walletrpc.NetworkResponse', null, global);
goog.exportSymbol('proto.walletrpc.NextAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.NextAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressRequest.GapPolicy', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressRequest.Kind', null, global);
goog.exportSymbol('proto.walletrpc.NextAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.OpenWalletRequest', null, global);
goog.exportSymbol('proto.walletrpc.OpenWalletResponse', null, global);
goog.exportSymbol('proto.walletrpc.PingRequest', null, global);
goog.exportSymbol('proto.walletrpc.PingResponse', null, global);
goog.exportSymbol('proto.walletrpc.PublishTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.PublishTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.PublishUnminedTransactionsRequest', null, global);
goog.exportSymbol('proto.walletrpc.PublishUnminedTransactionsResponse', null, global);
goog.exportSymbol('proto.walletrpc.PurchaseTicketsRequest', null, global);
goog.exportSymbol('proto.walletrpc.PurchaseTicketsResponse', null, global);
goog.exportSymbol('proto.walletrpc.RenameAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.RenameAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.RescanRequest', null, global);
goog.exportSymbol('proto.walletrpc.RescanResponse', null, global);
goog.exportSymbol('proto.walletrpc.RevokeTicketsRequest', null, global);
goog.exportSymbol('proto.walletrpc.RevokeTicketsResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetAccountRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetAccountResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetBalanceToMaintainRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetBalanceToMaintainResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxFeeRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxFeeResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPerBlockRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPerBlockResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPriceAbsoluteRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPriceAbsoluteResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPriceRelativeRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetMaxPriceRelativeResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetPoolAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetPoolAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetPoolFeesRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetPoolFeesResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetVoteChoicesRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetVoteChoicesRequest.Choice', null, global);
goog.exportSymbol('proto.walletrpc.SetVoteChoicesResponse', null, global);
goog.exportSymbol('proto.walletrpc.SetVotingAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.SetVotingAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.SignMessageRequest', null, global);
goog.exportSymbol('proto.walletrpc.SignMessageResponse', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionRequest', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionRequest.AdditionalScript', null, global);
goog.exportSymbol('proto.walletrpc.SignTransactionResponse', null, global);
goog.exportSymbol('proto.walletrpc.StakeInfoRequest', null, global);
goog.exportSymbol('proto.walletrpc.StakeInfoResponse', null, global);
goog.exportSymbol('proto.walletrpc.StartAutoBuyerRequest', null, global);
goog.exportSymbol('proto.walletrpc.StartAutoBuyerResponse', null, global);
goog.exportSymbol('proto.walletrpc.StartConsensusRpcRequest', null, global);
goog.exportSymbol('proto.walletrpc.StartConsensusRpcResponse', null, global);
goog.exportSymbol('proto.walletrpc.StopAutoBuyerRequest', null, global);
goog.exportSymbol('proto.walletrpc.StopAutoBuyerResponse', null, global);
goog.exportSymbol('proto.walletrpc.SubscribeToBlockNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.SubscribeToBlockNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.TicketBuyerConfigRequest', null, global);
goog.exportSymbol('proto.walletrpc.TicketBuyerConfigResponse', null, global);
goog.exportSymbol('proto.walletrpc.TicketPriceRequest', null, global);
goog.exportSymbol('proto.walletrpc.TicketPriceResponse', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails.Input', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails.Output', null, global);
goog.exportSymbol('proto.walletrpc.TransactionDetails.TransactionType', null, global);
goog.exportSymbol('proto.walletrpc.TransactionNotificationsRequest', null, global);
goog.exportSymbol('proto.walletrpc.TransactionNotificationsResponse', null, global);
goog.exportSymbol('proto.walletrpc.ValidateAddressRequest', null, global);
goog.exportSymbol('proto.walletrpc.ValidateAddressResponse', null, global);
goog.exportSymbol('proto.walletrpc.ValidateAddressResponse.ScriptType', null, global);
goog.exportSymbol('proto.walletrpc.VerifyMessageRequest', null, global);
goog.exportSymbol('proto.walletrpc.VerifyMessageResponse', null, global);
goog.exportSymbol('proto.walletrpc.VersionRequest', null, global);
goog.exportSymbol('proto.walletrpc.VersionResponse', null, global);
goog.exportSymbol('proto.walletrpc.VoteChoicesRequest', null, global);
goog.exportSymbol('proto.walletrpc.VoteChoicesResponse', null, global);
goog.exportSymbol('proto.walletrpc.VoteChoicesResponse.Choice', null, global);
goog.exportSymbol('proto.walletrpc.WalletExistsRequest', null, global);
goog.exportSymbol('proto.walletrpc.WalletExistsResponse', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VersionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VersionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VersionRequest.displayName = 'proto.walletrpc.VersionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VersionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VersionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VersionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VersionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VersionRequest}
 */
proto.walletrpc.VersionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VersionRequest;
  return proto.walletrpc.VersionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VersionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VersionRequest}
 */
proto.walletrpc.VersionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VersionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.VersionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VersionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VersionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VersionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VersionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VersionResponse.displayName = 'proto.walletrpc.VersionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VersionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VersionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VersionResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VersionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    versionString: jspb.Message.getFieldWithDefault(msg, 1, ""),
    major: jspb.Message.getFieldWithDefault(msg, 2, 0),
    minor: jspb.Message.getFieldWithDefault(msg, 3, 0),
    patch: jspb.Message.getFieldWithDefault(msg, 4, 0),
    prerelease: jspb.Message.getFieldWithDefault(msg, 5, ""),
    buildMetadata: jspb.Message.getFieldWithDefault(msg, 6, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VersionResponse}
 */
proto.walletrpc.VersionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VersionResponse;
  return proto.walletrpc.VersionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VersionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VersionResponse}
 */
proto.walletrpc.VersionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVersionString(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMajor(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMinor(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPatch(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setPrerelease(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setBuildMetadata(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VersionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.VersionResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VersionResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VersionResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVersionString();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getMajor();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getMinor();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getPatch();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getPrerelease();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getBuildMetadata();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
};


/**
 * optional string version_string = 1;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getVersionString = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.VersionResponse.prototype.setVersionString = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 major = 2;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getMajor = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.VersionResponse.prototype.setMajor = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 minor = 3;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getMinor = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.VersionResponse.prototype.setMinor = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 patch = 4;
 * @return {number}
 */
proto.walletrpc.VersionResponse.prototype.getPatch = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.VersionResponse.prototype.setPatch = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string prerelease = 5;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getPrerelease = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.walletrpc.VersionResponse.prototype.setPrerelease = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional string build_metadata = 6;
 * @return {string}
 */
proto.walletrpc.VersionResponse.prototype.getBuildMetadata = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.walletrpc.VersionResponse.prototype.setBuildMetadata = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.TransactionDetails.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.TransactionDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.displayName = 'proto.walletrpc.TransactionDetails';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.TransactionDetails.repeatedFields_ = [3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: msg.getHash_asB64(),
    transaction: msg.getTransaction_asB64(),
    debitsList: jspb.Message.toObjectList(msg.getDebitsList(),
    proto.walletrpc.TransactionDetails.Input.toObject, includeInstance),
    creditsList: jspb.Message.toObjectList(msg.getCreditsList(),
    proto.walletrpc.TransactionDetails.Output.toObject, includeInstance),
    fee: jspb.Message.getFieldWithDefault(msg, 5, 0),
    timestamp: jspb.Message.getFieldWithDefault(msg, 6, 0),
    transactionType: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.TransactionDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails;
  return proto.walletrpc.TransactionDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.TransactionDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransaction(value);
      break;
    case 3:
      var value = new proto.walletrpc.TransactionDetails.Input;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader);
      msg.addDebits(value);
      break;
    case 4:
      var value = new proto.walletrpc.TransactionDetails.Output;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader);
      msg.addCredits(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFee(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    case 7:
      var value = /** @type {!proto.walletrpc.TransactionDetails.TransactionType} */ (reader.readEnum());
      msg.setTransactionType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TransactionDetails.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionDetails.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getDebitsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.walletrpc.TransactionDetails.Input.serializeBinaryToWriter
    );
  }
  f = message.getCreditsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.TransactionDetails.Output.serializeBinaryToWriter
    );
  }
  f = message.getFee();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getTransactionType();
  if (f !== 0.0) {
    writer.writeEnum(
      7,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.TransactionDetails.TransactionType = {
  REGULAR: 0,
  COINBASE: 4,
  TICKET_PURCHASE: 1,
  VOTE: 2,
  REVOCATION: 3
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails.Input = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionDetails.Input, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.Input.displayName = 'proto.walletrpc.TransactionDetails.Input';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Input.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.Input.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails.Input} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionDetails.Input.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0),
    previousAccount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    previousAmount: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails.Input}
 */
proto.walletrpc.TransactionDetails.Input.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails.Input;
  return proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails.Input} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails.Input}
 */
proto.walletrpc.TransactionDetails.Input.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPreviousAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setPreviousAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.Input.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TransactionDetails.Input.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails.Input} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionDetails.Input.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getPreviousAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getPreviousAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * optional uint32 index = 1;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Input.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 previous_account = 2;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getPreviousAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Input.prototype.setPreviousAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 previous_amount = 3;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Input.prototype.getPreviousAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Input.prototype.setPreviousAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionDetails.Output = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionDetails.Output, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionDetails.Output.displayName = 'proto.walletrpc.TransactionDetails.Output';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionDetails.Output.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionDetails.Output.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionDetails.Output} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionDetails.Output.toObject = function(includeInstance, msg) {
  var f, obj = {
    index: jspb.Message.getFieldWithDefault(msg, 1, 0),
    account: jspb.Message.getFieldWithDefault(msg, 2, 0),
    internal: jspb.Message.getFieldWithDefault(msg, 3, false),
    amount: jspb.Message.getFieldWithDefault(msg, 4, 0),
    address: jspb.Message.getFieldWithDefault(msg, 5, ""),
    outputScript: msg.getOutputScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionDetails.Output}
 */
proto.walletrpc.TransactionDetails.Output.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionDetails.Output;
  return proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionDetails.Output} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionDetails.Output}
 */
proto.walletrpc.TransactionDetails.Output.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setInternal(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setOutputScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.Output.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TransactionDetails.Output.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionDetails.Output} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionDetails.Output.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getInternal();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getOutputScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
};


/**
 * optional uint32 index = 1;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Output.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Output.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool internal = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getInternal = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.walletrpc.TransactionDetails.Output.prototype.setInternal = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 amount = 4;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.Output.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string address = 5;
 * @return {string}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.walletrpc.TransactionDetails.Output.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bytes output_script = 6;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getOutputScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes output_script = 6;
 * This is a type-conversion wrapper around `getOutputScript()`
 * @return {string}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getOutputScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getOutputScript()));
};


/**
 * optional bytes output_script = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getOutputScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.Output.prototype.getOutputScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getOutputScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.TransactionDetails.Output.prototype.setOutputScript = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional bytes hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.TransactionDetails.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes hash = 1;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.walletrpc.TransactionDetails.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.TransactionDetails.prototype.setHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes transaction = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes transaction = 2;
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {string}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransaction()));
};


/**
 * optional bytes transaction = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionDetails.prototype.getTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.TransactionDetails.prototype.setTransaction = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * repeated Input debits = 3;
 * @return {!Array.<!proto.walletrpc.TransactionDetails.Input>}
 */
proto.walletrpc.TransactionDetails.prototype.getDebitsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails.Input>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails.Input, 3));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails.Input>} value */
proto.walletrpc.TransactionDetails.prototype.setDebitsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails.Input=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails.Input}
 */
proto.walletrpc.TransactionDetails.prototype.addDebits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.walletrpc.TransactionDetails.Input, opt_index);
};


proto.walletrpc.TransactionDetails.prototype.clearDebitsList = function() {
  this.setDebitsList([]);
};


/**
 * repeated Output credits = 4;
 * @return {!Array.<!proto.walletrpc.TransactionDetails.Output>}
 */
proto.walletrpc.TransactionDetails.prototype.getCreditsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails.Output>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails.Output, 4));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails.Output>} value */
proto.walletrpc.TransactionDetails.prototype.setCreditsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails.Output=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails.Output}
 */
proto.walletrpc.TransactionDetails.prototype.addCredits = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.walletrpc.TransactionDetails.Output, opt_index);
};


proto.walletrpc.TransactionDetails.prototype.clearCreditsList = function() {
  this.setCreditsList([]);
};


/**
 * optional int64 fee = 5;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.prototype.getFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.prototype.setFee = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 timestamp = 6;
 * @return {number}
 */
proto.walletrpc.TransactionDetails.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.TransactionDetails.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional TransactionType transaction_type = 7;
 * @return {!proto.walletrpc.TransactionDetails.TransactionType}
 */
proto.walletrpc.TransactionDetails.prototype.getTransactionType = function() {
  return /** @type {!proto.walletrpc.TransactionDetails.TransactionType} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {!proto.walletrpc.TransactionDetails.TransactionType} value */
proto.walletrpc.TransactionDetails.prototype.setTransactionType = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BlockDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.BlockDetails.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.BlockDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BlockDetails.displayName = 'proto.walletrpc.BlockDetails';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.BlockDetails.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BlockDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BlockDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BlockDetails} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BlockDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: msg.getHash_asB64(),
    height: jspb.Message.getFieldWithDefault(msg, 2, 0),
    timestamp: jspb.Message.getFieldWithDefault(msg, 3, 0),
    transactionsList: jspb.Message.toObjectList(msg.getTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BlockDetails}
 */
proto.walletrpc.BlockDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BlockDetails;
  return proto.walletrpc.BlockDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BlockDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BlockDetails}
 */
proto.walletrpc.BlockDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHeight(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    case 4:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.addTransactions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.BlockDetails.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BlockDetails} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BlockDetails.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockDetails.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes hash = 1;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.walletrpc.BlockDetails.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockDetails.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.BlockDetails.prototype.setHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 height = 2;
 * @return {number}
 */
proto.walletrpc.BlockDetails.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.BlockDetails.prototype.setHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 timestamp = 3;
 * @return {number}
 */
proto.walletrpc.BlockDetails.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.BlockDetails.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * repeated TransactionDetails transactions = 4;
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.BlockDetails.prototype.getTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 4));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails>} value */
proto.walletrpc.BlockDetails.prototype.setTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.BlockDetails.prototype.addTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.walletrpc.TransactionDetails, opt_index);
};


proto.walletrpc.BlockDetails.prototype.clearTransactionsList = function() {
  this.setTransactionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountBalance = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountBalance, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountBalance.displayName = 'proto.walletrpc.AccountBalance';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountBalance.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountBalance.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountBalance} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountBalance.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0),
    totalBalance: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountBalance}
 */
proto.walletrpc.AccountBalance.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountBalance;
  return proto.walletrpc.AccountBalance.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountBalance} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountBalance}
 */
proto.walletrpc.AccountBalance.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalBalance(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountBalance.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AccountBalance.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountBalance} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountBalance.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getTotalBalance();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.AccountBalance.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AccountBalance.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 total_balance = 2;
 * @return {number}
 */
proto.walletrpc.AccountBalance.prototype.getTotalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.AccountBalance.prototype.setTotalBalance = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PingRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PingRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PingRequest.displayName = 'proto.walletrpc.PingRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PingRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PingRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PingRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PingRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PingRequest}
 */
proto.walletrpc.PingRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PingRequest;
  return proto.walletrpc.PingRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PingRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PingRequest}
 */
proto.walletrpc.PingRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PingRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.PingRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PingRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PingRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PingResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PingResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PingResponse.displayName = 'proto.walletrpc.PingResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PingResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PingResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PingResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PingResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PingResponse}
 */
proto.walletrpc.PingResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PingResponse;
  return proto.walletrpc.PingResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PingResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PingResponse}
 */
proto.walletrpc.PingResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PingResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.PingResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PingResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PingResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NetworkRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NetworkRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NetworkRequest.displayName = 'proto.walletrpc.NetworkRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NetworkRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NetworkRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NetworkRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NetworkRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NetworkRequest}
 */
proto.walletrpc.NetworkRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NetworkRequest;
  return proto.walletrpc.NetworkRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NetworkRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NetworkRequest}
 */
proto.walletrpc.NetworkRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NetworkRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.NetworkRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NetworkRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NetworkRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NetworkResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NetworkResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NetworkResponse.displayName = 'proto.walletrpc.NetworkResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NetworkResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NetworkResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NetworkResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NetworkResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    activeNetwork: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NetworkResponse}
 */
proto.walletrpc.NetworkResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NetworkResponse;
  return proto.walletrpc.NetworkResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NetworkResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NetworkResponse}
 */
proto.walletrpc.NetworkResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setActiveNetwork(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NetworkResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.NetworkResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NetworkResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NetworkResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getActiveNetwork();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 active_network = 1;
 * @return {number}
 */
proto.walletrpc.NetworkResponse.prototype.getActiveNetwork = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.NetworkResponse.prototype.setActiveNetwork = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNumberRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNumberRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNumberRequest.displayName = 'proto.walletrpc.AccountNumberRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNumberRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNumberRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNumberRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountNumberRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountName: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNumberRequest}
 */
proto.walletrpc.AccountNumberRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNumberRequest;
  return proto.walletrpc.AccountNumberRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNumberRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNumberRequest}
 */
proto.walletrpc.AccountNumberRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNumberRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AccountNumberRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNumberRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountNumberRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string account_name = 1;
 * @return {string}
 */
proto.walletrpc.AccountNumberRequest.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.AccountNumberRequest.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNumberResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNumberResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNumberResponse.displayName = 'proto.walletrpc.AccountNumberResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNumberResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNumberResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNumberResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountNumberResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNumberResponse}
 */
proto.walletrpc.AccountNumberResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNumberResponse;
  return proto.walletrpc.AccountNumberResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNumberResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNumberResponse}
 */
proto.walletrpc.AccountNumberResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNumberResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AccountNumberResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNumberResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountNumberResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountNumberResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNumberResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsRequest.displayName = 'proto.walletrpc.AccountsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsRequest}
 */
proto.walletrpc.AccountsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsRequest;
  return proto.walletrpc.AccountsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsRequest}
 */
proto.walletrpc.AccountsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AccountsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.AccountsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.AccountsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsResponse.displayName = 'proto.walletrpc.AccountsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.AccountsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountsList: jspb.Message.toObjectList(msg.getAccountsList(),
    proto.walletrpc.AccountsResponse.Account.toObject, includeInstance),
    currentBlockHash: msg.getCurrentBlockHash_asB64(),
    currentBlockHeight: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsResponse}
 */
proto.walletrpc.AccountsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsResponse;
  return proto.walletrpc.AccountsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsResponse}
 */
proto.walletrpc.AccountsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.AccountsResponse.Account;
      reader.readMessage(value,proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader);
      msg.addAccounts(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCurrentBlockHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCurrentBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AccountsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.AccountsResponse.Account.serializeBinaryToWriter
    );
  }
  f = message.getCurrentBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getCurrentBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountsResponse.Account = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountsResponse.Account, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountsResponse.Account.displayName = 'proto.walletrpc.AccountsResponse.Account';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountsResponse.Account.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountsResponse.Account.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountsResponse.Account} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountsResponse.Account.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0),
    accountName: jspb.Message.getFieldWithDefault(msg, 2, ""),
    totalBalance: jspb.Message.getFieldWithDefault(msg, 3, 0),
    externalKeyCount: jspb.Message.getFieldWithDefault(msg, 4, 0),
    internalKeyCount: jspb.Message.getFieldWithDefault(msg, 5, 0),
    importedKeyCount: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountsResponse.Account}
 */
proto.walletrpc.AccountsResponse.Account.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountsResponse.Account;
  return proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountsResponse.Account} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountsResponse.Account}
 */
proto.walletrpc.AccountsResponse.Account.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalBalance(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExternalKeyCount(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInternalKeyCount(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImportedKeyCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.Account.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AccountsResponse.Account.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountsResponse.Account} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountsResponse.Account.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getTotalBalance();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getExternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getInternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getImportedKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.AccountsResponse.Account.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_balance = 3;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getTotalBalance = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setTotalBalance = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 external_key_count = 4;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getExternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setExternalKeyCount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 internal_key_count = 5;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getInternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setInternalKeyCount = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 imported_key_count = 6;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.Account.prototype.getImportedKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.Account.prototype.setImportedKeyCount = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * repeated Account accounts = 1;
 * @return {!Array.<!proto.walletrpc.AccountsResponse.Account>}
 */
proto.walletrpc.AccountsResponse.prototype.getAccountsList = function() {
  return /** @type{!Array.<!proto.walletrpc.AccountsResponse.Account>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.AccountsResponse.Account, 1));
};


/** @param {!Array.<!proto.walletrpc.AccountsResponse.Account>} value */
proto.walletrpc.AccountsResponse.prototype.setAccountsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.walletrpc.AccountsResponse.Account=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.AccountsResponse.Account}
 */
proto.walletrpc.AccountsResponse.prototype.addAccounts = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.walletrpc.AccountsResponse.Account, opt_index);
};


proto.walletrpc.AccountsResponse.prototype.clearAccountsList = function() {
  this.setAccountsList([]);
};


/**
 * optional bytes current_block_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes current_block_hash = 2;
 * This is a type-conversion wrapper around `getCurrentBlockHash()`
 * @return {string}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCurrentBlockHash()));
};


/**
 * optional bytes current_block_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCurrentBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCurrentBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.AccountsResponse.prototype.setCurrentBlockHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 current_block_height = 3;
 * @return {number}
 */
proto.walletrpc.AccountsResponse.prototype.getCurrentBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.AccountsResponse.prototype.setCurrentBlockHeight = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RenameAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RenameAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RenameAccountRequest.displayName = 'proto.walletrpc.RenameAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RenameAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RenameAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RenameAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RenameAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0),
    newName: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RenameAccountRequest}
 */
proto.walletrpc.RenameAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RenameAccountRequest;
  return proto.walletrpc.RenameAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RenameAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RenameAccountRequest}
 */
proto.walletrpc.RenameAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setNewName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RenameAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.RenameAccountRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RenameAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RenameAccountRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getNewName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.RenameAccountRequest.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.RenameAccountRequest.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string new_name = 2;
 * @return {string}
 */
proto.walletrpc.RenameAccountRequest.prototype.getNewName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.RenameAccountRequest.prototype.setNewName = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RenameAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RenameAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RenameAccountResponse.displayName = 'proto.walletrpc.RenameAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RenameAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RenameAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RenameAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RenameAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RenameAccountResponse}
 */
proto.walletrpc.RenameAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RenameAccountResponse;
  return proto.walletrpc.RenameAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RenameAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RenameAccountResponse}
 */
proto.walletrpc.RenameAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RenameAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.RenameAccountResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RenameAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RenameAccountResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanRequest.displayName = 'proto.walletrpc.RescanRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RescanRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    beginHeight: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanRequest}
 */
proto.walletrpc.RescanRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanRequest;
  return proto.walletrpc.RescanRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanRequest}
 */
proto.walletrpc.RescanRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBeginHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.RescanRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RescanRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBeginHeight();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 begin_height = 1;
 * @return {number}
 */
proto.walletrpc.RescanRequest.prototype.getBeginHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.RescanRequest.prototype.setBeginHeight = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RescanResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RescanResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RescanResponse.displayName = 'proto.walletrpc.RescanResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RescanResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RescanResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RescanResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RescanResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    rescannedThrough: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RescanResponse}
 */
proto.walletrpc.RescanResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RescanResponse;
  return proto.walletrpc.RescanResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RescanResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RescanResponse}
 */
proto.walletrpc.RescanResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRescannedThrough(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RescanResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.RescanResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RescanResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RescanResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRescannedThrough();
  if (f !== 0) {
    writer.writeInt32(
      1,
      f
    );
  }
};


/**
 * optional int32 rescanned_through = 1;
 * @return {number}
 */
proto.walletrpc.RescanResponse.prototype.getRescannedThrough = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.RescanResponse.prototype.setRescannedThrough = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAccountRequest.displayName = 'proto.walletrpc.NextAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NextAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    accountName: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAccountRequest}
 */
proto.walletrpc.NextAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAccountRequest;
  return proto.walletrpc.NextAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAccountRequest}
 */
proto.walletrpc.NextAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.NextAccountRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NextAccountRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.NextAccountRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.NextAccountRequest.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.NextAccountRequest.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAccountResponse.displayName = 'proto.walletrpc.NextAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NextAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAccountResponse}
 */
proto.walletrpc.NextAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAccountResponse;
  return proto.walletrpc.NextAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAccountResponse}
 */
proto.walletrpc.NextAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.NextAccountResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NextAccountResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.NextAccountResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.NextAccountResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAddressRequest.displayName = 'proto.walletrpc.NextAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NextAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0),
    kind: jspb.Message.getFieldWithDefault(msg, 2, 0),
    gapPolicy: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAddressRequest}
 */
proto.walletrpc.NextAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAddressRequest;
  return proto.walletrpc.NextAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAddressRequest}
 */
proto.walletrpc.NextAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {!proto.walletrpc.NextAddressRequest.Kind} */ (reader.readEnum());
      msg.setKind(value);
      break;
    case 3:
      var value = /** @type {!proto.walletrpc.NextAddressRequest.GapPolicy} */ (reader.readEnum());
      msg.setGapPolicy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.NextAddressRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NextAddressRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getKind();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getGapPolicy();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.NextAddressRequest.Kind = {
  BIP0044_EXTERNAL: 0,
  BIP0044_INTERNAL: 1
};

/**
 * @enum {number}
 */
proto.walletrpc.NextAddressRequest.GapPolicy = {
  GAP_POLICY_UNSPECIFIED: 0,
  GAP_POLICY_ERROR: 1,
  GAP_POLICY_IGNORE: 2,
  GAP_POLICY_WRAP: 3
};

/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.NextAddressRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.NextAddressRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional Kind kind = 2;
 * @return {!proto.walletrpc.NextAddressRequest.Kind}
 */
proto.walletrpc.NextAddressRequest.prototype.getKind = function() {
  return /** @type {!proto.walletrpc.NextAddressRequest.Kind} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.walletrpc.NextAddressRequest.Kind} value */
proto.walletrpc.NextAddressRequest.prototype.setKind = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional GapPolicy gap_policy = 3;
 * @return {!proto.walletrpc.NextAddressRequest.GapPolicy}
 */
proto.walletrpc.NextAddressRequest.prototype.getGapPolicy = function() {
  return /** @type {!proto.walletrpc.NextAddressRequest.GapPolicy} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {!proto.walletrpc.NextAddressRequest.GapPolicy} value */
proto.walletrpc.NextAddressRequest.prototype.setGapPolicy = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.NextAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.NextAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.NextAddressResponse.displayName = 'proto.walletrpc.NextAddressResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.NextAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.NextAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.NextAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NextAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, ""),
    publicKey: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.NextAddressResponse}
 */
proto.walletrpc.NextAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.NextAddressResponse;
  return proto.walletrpc.NextAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.NextAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.NextAddressResponse}
 */
proto.walletrpc.NextAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPublicKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.NextAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.NextAddressResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.NextAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.NextAddressResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPublicKey();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.NextAddressResponse.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.NextAddressResponse.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string public_key = 2;
 * @return {string}
 */
proto.walletrpc.NextAddressResponse.prototype.getPublicKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.NextAddressResponse.prototype.setPublicKey = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportPrivateKeyRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportPrivateKeyRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportPrivateKeyRequest.displayName = 'proto.walletrpc.ImportPrivateKeyRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportPrivateKeyRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ImportPrivateKeyRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: jspb.Message.getFieldWithDefault(msg, 2, 0),
    privateKeyWif: jspb.Message.getFieldWithDefault(msg, 3, ""),
    rescan: jspb.Message.getFieldWithDefault(msg, 4, false),
    scanFrom: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportPrivateKeyRequest}
 */
proto.walletrpc.ImportPrivateKeyRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportPrivateKeyRequest;
  return proto.walletrpc.ImportPrivateKeyRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportPrivateKeyRequest}
 */
proto.walletrpc.ImportPrivateKeyRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPrivateKeyWif(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRescan(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setScanFrom(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ImportPrivateKeyRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportPrivateKeyRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ImportPrivateKeyRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getPrivateKeyWif();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getRescan();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getScanFrom();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string private_key_wif = 3;
 * @return {string}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getPrivateKeyWif = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setPrivateKeyWif = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool rescan = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getRescan = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setRescan = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 scan_from = 5;
 * @return {number}
 */
proto.walletrpc.ImportPrivateKeyRequest.prototype.getScanFrom = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.ImportPrivateKeyRequest.prototype.setScanFrom = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportPrivateKeyResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportPrivateKeyResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportPrivateKeyResponse.displayName = 'proto.walletrpc.ImportPrivateKeyResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportPrivateKeyResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ImportPrivateKeyResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportPrivateKeyResponse}
 */
proto.walletrpc.ImportPrivateKeyResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportPrivateKeyResponse;
  return proto.walletrpc.ImportPrivateKeyResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportPrivateKeyResponse}
 */
proto.walletrpc.ImportPrivateKeyResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportPrivateKeyResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ImportPrivateKeyResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportPrivateKeyResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ImportPrivateKeyResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportScriptRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportScriptRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportScriptRequest.displayName = 'proto.walletrpc.ImportScriptRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportScriptRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportScriptRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportScriptRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ImportScriptRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    script: msg.getScript_asB64(),
    rescan: jspb.Message.getFieldWithDefault(msg, 3, false),
    scanFrom: jspb.Message.getFieldWithDefault(msg, 4, 0),
    requireRedeemable: jspb.Message.getFieldWithDefault(msg, 5, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportScriptRequest}
 */
proto.walletrpc.ImportScriptRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportScriptRequest;
  return proto.walletrpc.ImportScriptRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportScriptRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportScriptRequest}
 */
proto.walletrpc.ImportScriptRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRescan(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setScanFrom(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRequireRedeemable(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ImportScriptRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportScriptRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ImportScriptRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getRescan();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getScanFrom();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getRequireRedeemable();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ImportScriptRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes script = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes script = 2;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ImportScriptRequest.prototype.setScript = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bool rescan = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportScriptRequest.prototype.getRescan = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.walletrpc.ImportScriptRequest.prototype.setRescan = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 scan_from = 4;
 * @return {number}
 */
proto.walletrpc.ImportScriptRequest.prototype.getScanFrom = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.ImportScriptRequest.prototype.setScanFrom = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool require_redeemable = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportScriptRequest.prototype.getRequireRedeemable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.walletrpc.ImportScriptRequest.prototype.setRequireRedeemable = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ImportScriptResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ImportScriptResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ImportScriptResponse.displayName = 'proto.walletrpc.ImportScriptResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ImportScriptResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ImportScriptResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ImportScriptResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ImportScriptResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    p2shAddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    redeemable: jspb.Message.getFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ImportScriptResponse}
 */
proto.walletrpc.ImportScriptResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ImportScriptResponse;
  return proto.walletrpc.ImportScriptResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ImportScriptResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ImportScriptResponse}
 */
proto.walletrpc.ImportScriptResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setP2shAddress(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRedeemable(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ImportScriptResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ImportScriptResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ImportScriptResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ImportScriptResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getP2shAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getRedeemable();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional string p2sh_address = 1;
 * @return {string}
 */
proto.walletrpc.ImportScriptResponse.prototype.getP2shAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.ImportScriptResponse.prototype.setP2shAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool redeemable = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ImportScriptResponse.prototype.getRedeemable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.walletrpc.ImportScriptResponse.prototype.setRedeemable = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BalanceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BalanceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BalanceRequest.displayName = 'proto.walletrpc.BalanceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BalanceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BalanceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BalanceRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BalanceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0),
    requiredConfirmations: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BalanceRequest}
 */
proto.walletrpc.BalanceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BalanceRequest;
  return proto.walletrpc.BalanceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BalanceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BalanceRequest}
 */
proto.walletrpc.BalanceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BalanceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.BalanceRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BalanceRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BalanceRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.BalanceRequest.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceRequest.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 required_confirmations = 2;
 * @return {number}
 */
proto.walletrpc.BalanceRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BalanceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BalanceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BalanceResponse.displayName = 'proto.walletrpc.BalanceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BalanceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BalanceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BalanceResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BalanceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    total: jspb.Message.getFieldWithDefault(msg, 1, 0),
    spendable: jspb.Message.getFieldWithDefault(msg, 2, 0),
    immatureReward: jspb.Message.getFieldWithDefault(msg, 3, 0),
    immatureStakeGeneration: jspb.Message.getFieldWithDefault(msg, 4, 0),
    lockedByTickets: jspb.Message.getFieldWithDefault(msg, 5, 0),
    votingAuthority: jspb.Message.getFieldWithDefault(msg, 6, 0),
    unconfirmed: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BalanceResponse}
 */
proto.walletrpc.BalanceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BalanceResponse;
  return proto.walletrpc.BalanceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BalanceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BalanceResponse}
 */
proto.walletrpc.BalanceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotal(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSpendable(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setImmatureReward(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setImmatureStakeGeneration(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setLockedByTickets(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setVotingAuthority(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUnconfirmed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BalanceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.BalanceResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BalanceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BalanceResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTotal();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getSpendable();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getImmatureReward();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getImmatureStakeGeneration();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getLockedByTickets();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getVotingAuthority();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getUnconfirmed();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
};


/**
 * optional int64 total = 1;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getTotal = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setTotal = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 spendable = 2;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getSpendable = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setSpendable = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 immature_reward = 3;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getImmatureReward = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setImmatureReward = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 immature_stake_generation = 4;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getImmatureStakeGeneration = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setImmatureStakeGeneration = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 locked_by_tickets = 5;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getLockedByTickets = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setLockedByTickets = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 voting_authority = 6;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getVotingAuthority = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setVotingAuthority = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 unconfirmed = 7;
 * @return {number}
 */
proto.walletrpc.BalanceResponse.prototype.getUnconfirmed = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.walletrpc.BalanceResponse.prototype.setUnconfirmed = function(value) {
  jspb.Message.setField(this, 7, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionRequest.displayName = 'proto.walletrpc.GetTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionRequest}
 */
proto.walletrpc.GetTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionRequest;
  return proto.walletrpc.GetTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionRequest}
 */
proto.walletrpc.GetTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GetTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionRequest.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionRequest.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionRequest.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GetTransactionRequest.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionResponse.displayName = 'proto.walletrpc.GetTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transaction: (f = msg.getTransaction()) && proto.walletrpc.TransactionDetails.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionResponse}
 */
proto.walletrpc.GetTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionResponse;
  return proto.walletrpc.GetTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionResponse}
 */
proto.walletrpc.GetTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.setTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GetTransactionResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransaction();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
};


/**
 * optional TransactionDetails transaction = 1;
 * @return {?proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.GetTransactionResponse.prototype.getTransaction = function() {
  return /** @type{?proto.walletrpc.TransactionDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.TransactionDetails, 1));
};


/** @param {?proto.walletrpc.TransactionDetails|undefined} value */
proto.walletrpc.GetTransactionResponse.prototype.setTransaction = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTransactionResponse.prototype.clearTransaction = function() {
  this.setTransaction(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.GetTransactionResponse.prototype.hasTransaction = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTransactionsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionsRequest.displayName = 'proto.walletrpc.GetTransactionsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTransactionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    startingBlockHash: msg.getStartingBlockHash_asB64(),
    startingBlockHeight: jspb.Message.getFieldWithDefault(msg, 2, 0),
    endingBlockHash: msg.getEndingBlockHash_asB64(),
    endingBlockHeight: jspb.Message.getFieldWithDefault(msg, 4, 0),
    minimumRecentTransactions: jspb.Message.getFieldWithDefault(msg, 5, 0),
    targetTransactionCount: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionsRequest}
 */
proto.walletrpc.GetTransactionsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionsRequest;
  return proto.walletrpc.GetTransactionsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionsRequest}
 */
proto.walletrpc.GetTransactionsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStartingBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readSint32());
      msg.setStartingBlockHeight(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEndingBlockHash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setEndingBlockHeight(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinimumRecentTransactions(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTargetTransactionCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GetTransactionsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTransactionsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStartingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getStartingBlockHeight();
  if (f !== 0) {
    writer.writeSint32(
      2,
      f
    );
  }
  f = message.getEndingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getEndingBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getMinimumRecentTransactions();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
  f = message.getTargetTransactionCount();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
};


/**
 * optional bytes starting_block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes starting_block_hash = 1;
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStartingBlockHash()));
};


/**
 * optional bytes starting_block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStartingBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GetTransactionsRequest.prototype.setStartingBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional sint32 starting_block_height = 2;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getStartingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.GetTransactionsRequest.prototype.setStartingBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes ending_block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes ending_block_hash = 3;
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEndingBlockHash()));
};


/**
 * optional bytes ending_block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEndingBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GetTransactionsRequest.prototype.setEndingBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 ending_block_height = 4;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getEndingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.GetTransactionsRequest.prototype.setEndingBlockHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 minimum_recent_transactions = 5;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getMinimumRecentTransactions = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.GetTransactionsRequest.prototype.setMinimumRecentTransactions = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int32 target_transaction_count = 6;
 * @return {number}
 */
proto.walletrpc.GetTransactionsRequest.prototype.getTargetTransactionCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.GetTransactionsRequest.prototype.setTargetTransactionCount = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTransactionsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.GetTransactionsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.GetTransactionsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTransactionsResponse.displayName = 'proto.walletrpc.GetTransactionsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.GetTransactionsResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTransactionsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTransactionsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTransactionsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTransactionsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    minedTransactions: (f = msg.getMinedTransactions()) && proto.walletrpc.BlockDetails.toObject(includeInstance, f),
    unminedTransactionsList: jspb.Message.toObjectList(msg.getUnminedTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTransactionsResponse}
 */
proto.walletrpc.GetTransactionsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTransactionsResponse;
  return proto.walletrpc.GetTransactionsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTransactionsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTransactionsResponse}
 */
proto.walletrpc.GetTransactionsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.BlockDetails;
      reader.readMessage(value,proto.walletrpc.BlockDetails.deserializeBinaryFromReader);
      msg.setMinedTransactions(value);
      break;
    case 2:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.addUnminedTransactions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTransactionsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GetTransactionsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTransactionsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTransactionsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMinedTransactions();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.BlockDetails.serializeBinaryToWriter
    );
  }
  f = message.getUnminedTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
};


/**
 * optional BlockDetails mined_transactions = 1;
 * @return {?proto.walletrpc.BlockDetails}
 */
proto.walletrpc.GetTransactionsResponse.prototype.getMinedTransactions = function() {
  return /** @type{?proto.walletrpc.BlockDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.BlockDetails, 1));
};


/** @param {?proto.walletrpc.BlockDetails|undefined} value */
proto.walletrpc.GetTransactionsResponse.prototype.setMinedTransactions = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTransactionsResponse.prototype.clearMinedTransactions = function() {
  this.setMinedTransactions(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.GetTransactionsResponse.prototype.hasMinedTransactions = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated TransactionDetails unmined_transactions = 2;
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.GetTransactionsResponse.prototype.getUnminedTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 2));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails>} value */
proto.walletrpc.GetTransactionsResponse.prototype.setUnminedTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.GetTransactionsResponse.prototype.addUnminedTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.walletrpc.TransactionDetails, opt_index);
};


proto.walletrpc.GetTransactionsResponse.prototype.clearUnminedTransactionsList = function() {
  this.setUnminedTransactionsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTicketsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTicketsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTicketsRequest.displayName = 'proto.walletrpc.GetTicketsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTicketsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTicketsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTicketsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTicketsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    startingBlockHash: msg.getStartingBlockHash_asB64(),
    startingBlockHeight: jspb.Message.getFieldWithDefault(msg, 2, 0),
    endingBlockHash: msg.getEndingBlockHash_asB64(),
    endingBlockHeight: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTicketsRequest}
 */
proto.walletrpc.GetTicketsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTicketsRequest;
  return proto.walletrpc.GetTicketsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTicketsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTicketsRequest}
 */
proto.walletrpc.GetTicketsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStartingBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readSint32());
      msg.setStartingBlockHeight(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEndingBlockHash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setEndingBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GetTicketsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTicketsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTicketsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStartingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getStartingBlockHeight();
  if (f !== 0) {
    writer.writeSint32(
      2,
      f
    );
  }
  f = message.getEndingBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getEndingBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
};


/**
 * optional bytes starting_block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTicketsRequest.prototype.getStartingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes starting_block_hash = 1;
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTicketsRequest.prototype.getStartingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStartingBlockHash()));
};


/**
 * optional bytes starting_block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStartingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsRequest.prototype.getStartingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStartingBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GetTicketsRequest.prototype.setStartingBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional sint32 starting_block_height = 2;
 * @return {number}
 */
proto.walletrpc.GetTicketsRequest.prototype.getStartingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.GetTicketsRequest.prototype.setStartingBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes ending_block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GetTicketsRequest.prototype.getEndingBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes ending_block_hash = 3;
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {string}
 */
proto.walletrpc.GetTicketsRequest.prototype.getEndingBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEndingBlockHash()));
};


/**
 * optional bytes ending_block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEndingBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsRequest.prototype.getEndingBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEndingBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GetTicketsRequest.prototype.setEndingBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 ending_block_height = 4;
 * @return {number}
 */
proto.walletrpc.GetTicketsRequest.prototype.getEndingBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.GetTicketsRequest.prototype.setEndingBlockHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTicketsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTicketsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTicketsResponse.displayName = 'proto.walletrpc.GetTicketsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTicketsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTicketsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTicketsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTicketsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticket: (f = msg.getTicket()) && proto.walletrpc.GetTicketsResponse.TicketDetails.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTicketsResponse}
 */
proto.walletrpc.GetTicketsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTicketsResponse;
  return proto.walletrpc.GetTicketsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTicketsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTicketsResponse}
 */
proto.walletrpc.GetTicketsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.GetTicketsResponse.TicketDetails;
      reader.readMessage(value,proto.walletrpc.GetTicketsResponse.TicketDetails.deserializeBinaryFromReader);
      msg.setTicket(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GetTicketsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTicketsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTicketsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTicket();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.GetTicketsResponse.TicketDetails.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GetTicketsResponse.TicketDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GetTicketsResponse.TicketDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GetTicketsResponse.TicketDetails.displayName = 'proto.walletrpc.GetTicketsResponse.TicketDetails';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GetTicketsResponse.TicketDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GetTicketsResponse.TicketDetails} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticket: (f = msg.getTicket()) && proto.walletrpc.TransactionDetails.toObject(includeInstance, f),
    spender: (f = msg.getSpender()) && proto.walletrpc.TransactionDetails.toObject(includeInstance, f),
    ticketStatus: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GetTicketsResponse.TicketDetails}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GetTicketsResponse.TicketDetails;
  return proto.walletrpc.GetTicketsResponse.TicketDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GetTicketsResponse.TicketDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GetTicketsResponse.TicketDetails}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.setTicket(value);
      break;
    case 2:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.setSpender(value);
      break;
    case 3:
      var value = /** @type {!proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus} */ (reader.readEnum());
      msg.setTicketStatus(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GetTicketsResponse.TicketDetails.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GetTicketsResponse.TicketDetails} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTicket();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
  f = message.getSpender();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
  f = message.getTicketStatus();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus = {
  UNKNOWN: 0,
  UNMINED: 1,
  IMMATURE: 2,
  LIVE: 3,
  VOTED: 4,
  MISSED: 5,
  EXPIRED: 6,
  REVOKED: 7
};

/**
 * optional TransactionDetails ticket = 1;
 * @return {?proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.getTicket = function() {
  return /** @type{?proto.walletrpc.TransactionDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.TransactionDetails, 1));
};


/** @param {?proto.walletrpc.TransactionDetails|undefined} value */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.setTicket = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.clearTicket = function() {
  this.setTicket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.hasTicket = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TransactionDetails spender = 2;
 * @return {?proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.getSpender = function() {
  return /** @type{?proto.walletrpc.TransactionDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.TransactionDetails, 2));
};


/** @param {?proto.walletrpc.TransactionDetails|undefined} value */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.setSpender = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.clearSpender = function() {
  this.setSpender(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.hasSpender = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TicketStatus ticket_status = 3;
 * @return {!proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus}
 */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.getTicketStatus = function() {
  return /** @type {!proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {!proto.walletrpc.GetTicketsResponse.TicketDetails.TicketStatus} value */
proto.walletrpc.GetTicketsResponse.TicketDetails.prototype.setTicketStatus = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional TicketDetails ticket = 1;
 * @return {?proto.walletrpc.GetTicketsResponse.TicketDetails}
 */
proto.walletrpc.GetTicketsResponse.prototype.getTicket = function() {
  return /** @type{?proto.walletrpc.GetTicketsResponse.TicketDetails} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.GetTicketsResponse.TicketDetails, 1));
};


/** @param {?proto.walletrpc.GetTicketsResponse.TicketDetails|undefined} value */
proto.walletrpc.GetTicketsResponse.prototype.setTicket = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.GetTicketsResponse.prototype.clearTicket = function() {
  this.setTicket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.GetTicketsResponse.prototype.hasTicket = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketPriceRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketPriceRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketPriceRequest.displayName = 'proto.walletrpc.TicketPriceRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketPriceRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketPriceRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketPriceRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TicketPriceRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketPriceRequest}
 */
proto.walletrpc.TicketPriceRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketPriceRequest;
  return proto.walletrpc.TicketPriceRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketPriceRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketPriceRequest}
 */
proto.walletrpc.TicketPriceRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketPriceRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TicketPriceRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketPriceRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TicketPriceRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketPriceResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketPriceResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketPriceResponse.displayName = 'proto.walletrpc.TicketPriceResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketPriceResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketPriceResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketPriceResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TicketPriceResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketPrice: jspb.Message.getFieldWithDefault(msg, 1, 0),
    height: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketPriceResponse}
 */
proto.walletrpc.TicketPriceResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketPriceResponse;
  return proto.walletrpc.TicketPriceResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketPriceResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketPriceResponse}
 */
proto.walletrpc.TicketPriceResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTicketPrice(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketPriceResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TicketPriceResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketPriceResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TicketPriceResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTicketPrice();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional int64 ticket_price = 1;
 * @return {number}
 */
proto.walletrpc.TicketPriceResponse.prototype.getTicketPrice = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.TicketPriceResponse.prototype.setTicketPrice = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 height = 2;
 * @return {number}
 */
proto.walletrpc.TicketPriceResponse.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.TicketPriceResponse.prototype.setHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StakeInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StakeInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StakeInfoRequest.displayName = 'proto.walletrpc.StakeInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StakeInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StakeInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StakeInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StakeInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StakeInfoRequest}
 */
proto.walletrpc.StakeInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StakeInfoRequest;
  return proto.walletrpc.StakeInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StakeInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StakeInfoRequest}
 */
proto.walletrpc.StakeInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StakeInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.StakeInfoRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StakeInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StakeInfoRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StakeInfoResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StakeInfoResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StakeInfoResponse.displayName = 'proto.walletrpc.StakeInfoResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StakeInfoResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StakeInfoResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StakeInfoResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StakeInfoResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    poolSize: jspb.Message.getFieldWithDefault(msg, 1, 0),
    allMempoolTix: jspb.Message.getFieldWithDefault(msg, 2, 0),
    ownMempoolTix: jspb.Message.getFieldWithDefault(msg, 3, 0),
    immature: jspb.Message.getFieldWithDefault(msg, 4, 0),
    live: jspb.Message.getFieldWithDefault(msg, 5, 0),
    voted: jspb.Message.getFieldWithDefault(msg, 6, 0),
    missed: jspb.Message.getFieldWithDefault(msg, 7, 0),
    revoked: jspb.Message.getFieldWithDefault(msg, 8, 0),
    expired: jspb.Message.getFieldWithDefault(msg, 9, 0),
    totalSubsidy: jspb.Message.getFieldWithDefault(msg, 10, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StakeInfoResponse}
 */
proto.walletrpc.StakeInfoResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StakeInfoResponse;
  return proto.walletrpc.StakeInfoResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StakeInfoResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StakeInfoResponse}
 */
proto.walletrpc.StakeInfoResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPoolSize(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAllMempoolTix(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOwnMempoolTix(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImmature(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLive(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVoted(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMissed(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRevoked(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpired(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalSubsidy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StakeInfoResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.StakeInfoResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StakeInfoResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StakeInfoResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPoolSize();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getAllMempoolTix();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getOwnMempoolTix();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getImmature();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getLive();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = message.getVoted();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getMissed();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = message.getRevoked();
  if (f !== 0) {
    writer.writeUint32(
      8,
      f
    );
  }
  f = message.getExpired();
  if (f !== 0) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = message.getTotalSubsidy();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
};


/**
 * optional uint32 pool_size = 1;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getPoolSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setPoolSize = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 all_mempool_tix = 2;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getAllMempoolTix = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setAllMempoolTix = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 own_mempool_tix = 3;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getOwnMempoolTix = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setOwnMempoolTix = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 immature = 4;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getImmature = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setImmature = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 live = 5;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getLive = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setLive = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 voted = 6;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getVoted = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setVoted = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint32 missed = 7;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getMissed = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setMissed = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional uint32 revoked = 8;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getRevoked = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setRevoked = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional uint32 expired = 9;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getExpired = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setExpired = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 total_subsidy = 10;
 * @return {number}
 */
proto.walletrpc.StakeInfoResponse.prototype.getTotalSubsidy = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.walletrpc.StakeInfoResponse.prototype.setTotalSubsidy = function(value) {
  jspb.Message.setField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BlockInfoRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BlockInfoRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BlockInfoRequest.displayName = 'proto.walletrpc.BlockInfoRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BlockInfoRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BlockInfoRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BlockInfoRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BlockInfoRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    blockHash: msg.getBlockHash_asB64(),
    blockHeight: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BlockInfoRequest}
 */
proto.walletrpc.BlockInfoRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BlockInfoRequest;
  return proto.walletrpc.BlockInfoRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BlockInfoRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BlockInfoRequest}
 */
proto.walletrpc.BlockInfoRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.BlockInfoRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BlockInfoRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BlockInfoRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * optional bytes block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockInfoRequest.prototype.getBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes block_hash = 1;
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {string}
 */
proto.walletrpc.BlockInfoRequest.prototype.getBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHash()));
};


/**
 * optional bytes block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoRequest.prototype.getBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.BlockInfoRequest.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 block_height = 2;
 * @return {number}
 */
proto.walletrpc.BlockInfoRequest.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.BlockInfoRequest.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.BlockInfoResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.BlockInfoResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.BlockInfoResponse.displayName = 'proto.walletrpc.BlockInfoResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.BlockInfoResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.BlockInfoResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.BlockInfoResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BlockInfoResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    blockHash: msg.getBlockHash_asB64(),
    blockHeight: jspb.Message.getFieldWithDefault(msg, 2, 0),
    confirmations: jspb.Message.getFieldWithDefault(msg, 3, 0),
    timestamp: jspb.Message.getFieldWithDefault(msg, 4, 0),
    blockHeader: msg.getBlockHeader_asB64(),
    stakeInvalidated: jspb.Message.getFieldWithDefault(msg, 6, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.BlockInfoResponse}
 */
proto.walletrpc.BlockInfoResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.BlockInfoResponse;
  return proto.walletrpc.BlockInfoResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.BlockInfoResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.BlockInfoResponse}
 */
proto.walletrpc.BlockInfoResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlockHeight(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setConfirmations(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTimestamp(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHeader(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setStakeInvalidated(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.BlockInfoResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.BlockInfoResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.BlockInfoResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getTimestamp();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getBlockHeader_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getStakeInvalidated();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
};


/**
 * optional bytes block_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes block_hash = 1;
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {string}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHash()));
};


/**
 * optional bytes block_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.BlockInfoResponse.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 block_height = 2;
 * @return {number}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.BlockInfoResponse.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 confirmations = 3;
 * @return {number}
 */
proto.walletrpc.BlockInfoResponse.prototype.getConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.BlockInfoResponse.prototype.setConfirmations = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 timestamp = 4;
 * @return {number}
 */
proto.walletrpc.BlockInfoResponse.prototype.getTimestamp = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.BlockInfoResponse.prototype.setTimestamp = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bytes block_header = 5;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHeader = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes block_header = 5;
 * This is a type-conversion wrapper around `getBlockHeader()`
 * @return {string}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHeader_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHeader()));
};


/**
 * optional bytes block_header = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHeader()`
 * @return {!Uint8Array}
 */
proto.walletrpc.BlockInfoResponse.prototype.getBlockHeader_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHeader()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.BlockInfoResponse.prototype.setBlockHeader = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool stake_invalidated = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.BlockInfoResponse.prototype.getStakeInvalidated = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.walletrpc.BlockInfoResponse.prototype.setStakeInvalidated = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ChangePassphraseRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ChangePassphraseRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ChangePassphraseRequest.displayName = 'proto.walletrpc.ChangePassphraseRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ChangePassphraseRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ChangePassphraseRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ChangePassphraseRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: jspb.Message.getFieldWithDefault(msg, 1, 0),
    oldPassphrase: msg.getOldPassphrase_asB64(),
    newPassphrase: msg.getNewPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ChangePassphraseRequest}
 */
proto.walletrpc.ChangePassphraseRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ChangePassphraseRequest;
  return proto.walletrpc.ChangePassphraseRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ChangePassphraseRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ChangePassphraseRequest}
 */
proto.walletrpc.ChangePassphraseRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.walletrpc.ChangePassphraseRequest.Key} */ (reader.readEnum());
      msg.setKey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setOldPassphrase(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNewPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ChangePassphraseRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ChangePassphraseRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ChangePassphraseRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKey();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getOldPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getNewPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.ChangePassphraseRequest.Key = {
  PRIVATE: 0,
  PUBLIC: 1
};

/**
 * optional Key key = 1;
 * @return {!proto.walletrpc.ChangePassphraseRequest.Key}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getKey = function() {
  return /** @type {!proto.walletrpc.ChangePassphraseRequest.Key} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.walletrpc.ChangePassphraseRequest.Key} value */
proto.walletrpc.ChangePassphraseRequest.prototype.setKey = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes old_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes old_passphrase = 2;
 * This is a type-conversion wrapper around `getOldPassphrase()`
 * @return {string}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getOldPassphrase()));
};


/**
 * optional bytes old_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getOldPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getOldPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getOldPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ChangePassphraseRequest.prototype.setOldPassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes new_passphrase = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes new_passphrase = 3;
 * This is a type-conversion wrapper around `getNewPassphrase()`
 * @return {string}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNewPassphrase()));
};


/**
 * optional bytes new_passphrase = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNewPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseRequest.prototype.getNewPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNewPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ChangePassphraseRequest.prototype.setNewPassphrase = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ChangePassphraseResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ChangePassphraseResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ChangePassphraseResponse.displayName = 'proto.walletrpc.ChangePassphraseResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ChangePassphraseResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ChangePassphraseResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ChangePassphraseResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ChangePassphraseResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ChangePassphraseResponse}
 */
proto.walletrpc.ChangePassphraseResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ChangePassphraseResponse;
  return proto.walletrpc.ChangePassphraseResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ChangePassphraseResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ChangePassphraseResponse}
 */
proto.walletrpc.ChangePassphraseResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ChangePassphraseResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ChangePassphraseResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ChangePassphraseResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ChangePassphraseResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FundTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionRequest.displayName = 'proto.walletrpc.FundTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FundTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0),
    targetAmount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    requiredConfirmations: jspb.Message.getFieldWithDefault(msg, 3, 0),
    includeImmatureCoinbases: jspb.Message.getFieldWithDefault(msg, 4, false),
    includeChangeScript: jspb.Message.getFieldWithDefault(msg, 5, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionRequest}
 */
proto.walletrpc.FundTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionRequest;
  return proto.walletrpc.FundTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionRequest}
 */
proto.walletrpc.FundTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTargetAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeImmatureCoinbases(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIncludeChangeScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.FundTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FundTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getTargetAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getIncludeImmatureCoinbases();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getIncludeChangeScript();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 target_amount = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getTargetAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionRequest.prototype.setTargetAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 required_confirmations = 3;
 * @return {number}
 */
proto.walletrpc.FundTransactionRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool include_immature_coinbases = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionRequest.prototype.getIncludeImmatureCoinbases = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.walletrpc.FundTransactionRequest.prototype.setIncludeImmatureCoinbases = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool include_change_script = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionRequest.prototype.getIncludeChangeScript = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.walletrpc.FundTransactionRequest.prototype.setIncludeChangeScript = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.FundTransactionResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.FundTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionResponse.displayName = 'proto.walletrpc.FundTransactionResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.FundTransactionResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FundTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    selectedOutputsList: jspb.Message.toObjectList(msg.getSelectedOutputsList(),
    proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject, includeInstance),
    totalAmount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    changePkScript: msg.getChangePkScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionResponse}
 */
proto.walletrpc.FundTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionResponse;
  return proto.walletrpc.FundTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionResponse}
 */
proto.walletrpc.FundTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.FundTransactionResponse.PreviousOutput;
      reader.readMessage(value,proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader);
      msg.addSelectedOutputs(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalAmount(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChangePkScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.FundTransactionResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FundTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSelectedOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.FundTransactionResponse.PreviousOutput.serializeBinaryToWriter
    );
  }
  f = message.getTotalAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getChangePkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FundTransactionResponse.PreviousOutput, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FundTransactionResponse.PreviousOutput.displayName = 'proto.walletrpc.FundTransactionResponse.PreviousOutput';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    outputIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    amount: jspb.Message.getFieldWithDefault(msg, 3, 0),
    pkScript: msg.getPkScript_asB64(),
    receiveTime: jspb.Message.getFieldWithDefault(msg, 5, 0),
    fromCoinbase: jspb.Message.getFieldWithDefault(msg, 6, false),
    tree: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FundTransactionResponse.PreviousOutput;
  return proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPkScript(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setReceiveTime(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFromCoinbase(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTree(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.FundTransactionResponse.PreviousOutput.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getReceiveTime();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getFromCoinbase();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getTree();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 amount = 3;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes pk_script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes pk_script = 4;
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPkScript()));
};


/**
 * optional bytes pk_script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPkScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setPkScript = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 receive_time = 5;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getReceiveTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setReceiveTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool from_coinbase = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getFromCoinbase = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setFromCoinbase = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int32 tree = 7;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.getTree = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.PreviousOutput.prototype.setTree = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * repeated PreviousOutput selected_outputs = 1;
 * @return {!Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>}
 */
proto.walletrpc.FundTransactionResponse.prototype.getSelectedOutputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.FundTransactionResponse.PreviousOutput, 1));
};


/** @param {!Array.<!proto.walletrpc.FundTransactionResponse.PreviousOutput>} value */
proto.walletrpc.FundTransactionResponse.prototype.setSelectedOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.walletrpc.FundTransactionResponse.PreviousOutput=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.FundTransactionResponse.PreviousOutput}
 */
proto.walletrpc.FundTransactionResponse.prototype.addSelectedOutputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.walletrpc.FundTransactionResponse.PreviousOutput, opt_index);
};


proto.walletrpc.FundTransactionResponse.prototype.clearSelectedOutputsList = function() {
  this.setSelectedOutputsList([]);
};


/**
 * optional int64 total_amount = 2;
 * @return {number}
 */
proto.walletrpc.FundTransactionResponse.prototype.getTotalAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.FundTransactionResponse.prototype.setTotalAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes change_pk_script = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes change_pk_script = 3;
 * This is a type-conversion wrapper around `getChangePkScript()`
 * @return {string}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChangePkScript()));
};


/**
 * optional bytes change_pk_script = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChangePkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FundTransactionResponse.prototype.getChangePkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChangePkScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FundTransactionResponse.prototype.setChangePkScript = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ConstructTransactionRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.displayName = 'proto.walletrpc.ConstructTransactionRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ConstructTransactionRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConstructTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    sourceAccount: jspb.Message.getFieldWithDefault(msg, 1, 0),
    requiredConfirmations: jspb.Message.getFieldWithDefault(msg, 2, 0),
    feePerKb: jspb.Message.getFieldWithDefault(msg, 3, 0),
    outputSelectionAlgorithm: jspb.Message.getFieldWithDefault(msg, 4, 0),
    nonChangeOutputsList: jspb.Message.toObjectList(msg.getNonChangeOutputsList(),
    proto.walletrpc.ConstructTransactionRequest.Output.toObject, includeInstance),
    changeDestination: (f = msg.getChangeDestination()) && proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest}
 */
proto.walletrpc.ConstructTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest;
  return proto.walletrpc.ConstructTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest}
 */
proto.walletrpc.ConstructTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSourceAccount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredConfirmations(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFeePerKb(value);
      break;
    case 4:
      var value = /** @type {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} */ (reader.readEnum());
      msg.setOutputSelectionAlgorithm(value);
      break;
    case 5:
      var value = new proto.walletrpc.ConstructTransactionRequest.Output;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader);
      msg.addNonChangeOutputs(value);
      break;
    case 6:
      var value = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader);
      msg.setChangeDestination(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ConstructTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConstructTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSourceAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getFeePerKb();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getOutputSelectionAlgorithm();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = message.getNonChangeOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.walletrpc.ConstructTransactionRequest.Output.serializeBinaryToWriter
    );
  }
  f = message.getChangeDestination();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm = {
  UNSPECIFIED: 0,
  ALL: 1
};


/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest.OutputDestination, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.OutputDestination.displayName = 'proto.walletrpc.ConstructTransactionRequest.OutputDestination';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, ""),
    script: msg.getScript_asB64(),
    scriptVersion: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
  return proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setScriptVersion(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest.OutputDestination} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getScriptVersion();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes script = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes script = 2;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setScript = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 script_version = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.getScriptVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.OutputDestination.prototype.setScriptVersion = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionRequest.Output = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionRequest.Output, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionRequest.Output.displayName = 'proto.walletrpc.ConstructTransactionRequest.Output';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionRequest.Output.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConstructTransactionRequest.Output.toObject = function(includeInstance, msg) {
  var f, obj = {
    destination: (f = msg.getDestination()) && proto.walletrpc.ConstructTransactionRequest.OutputDestination.toObject(includeInstance, f),
    amount: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output}
 */
proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionRequest.Output;
  return proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output}
 */
proto.walletrpc.ConstructTransactionRequest.Output.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.ConstructTransactionRequest.OutputDestination;
      reader.readMessage(value,proto.walletrpc.ConstructTransactionRequest.OutputDestination.deserializeBinaryFromReader);
      msg.setDestination(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ConstructTransactionRequest.Output.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConstructTransactionRequest.Output.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDestination();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.ConstructTransactionRequest.OutputDestination.serializeBinaryToWriter
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional OutputDestination destination = 1;
 * @return {?proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.getDestination = function() {
  return /** @type{?proto.walletrpc.ConstructTransactionRequest.OutputDestination} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.ConstructTransactionRequest.OutputDestination, 1));
};


/** @param {?proto.walletrpc.ConstructTransactionRequest.OutputDestination|undefined} value */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.setDestination = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.ConstructTransactionRequest.Output.prototype.clearDestination = function() {
  this.setDestination(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.hasDestination = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int64 amount = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.Output.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 source_account = 1;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getSourceAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setSourceAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 required_confirmations = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 fee_per_kb = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setFeePerKb = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional OutputSelectionAlgorithm output_selection_algorithm = 4;
 * @return {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getOutputSelectionAlgorithm = function() {
  return /** @type {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {!proto.walletrpc.ConstructTransactionRequest.OutputSelectionAlgorithm} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setOutputSelectionAlgorithm = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * repeated Output non_change_outputs = 5;
 * @return {!Array.<!proto.walletrpc.ConstructTransactionRequest.Output>}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getNonChangeOutputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.ConstructTransactionRequest.Output>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.ConstructTransactionRequest.Output, 5));
};


/** @param {!Array.<!proto.walletrpc.ConstructTransactionRequest.Output>} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setNonChangeOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.walletrpc.ConstructTransactionRequest.Output=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.ConstructTransactionRequest.Output}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.addNonChangeOutputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.walletrpc.ConstructTransactionRequest.Output, opt_index);
};


proto.walletrpc.ConstructTransactionRequest.prototype.clearNonChangeOutputsList = function() {
  this.setNonChangeOutputsList([]);
};


/**
 * optional OutputDestination change_destination = 6;
 * @return {?proto.walletrpc.ConstructTransactionRequest.OutputDestination}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.getChangeDestination = function() {
  return /** @type{?proto.walletrpc.ConstructTransactionRequest.OutputDestination} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.ConstructTransactionRequest.OutputDestination, 6));
};


/** @param {?proto.walletrpc.ConstructTransactionRequest.OutputDestination|undefined} value */
proto.walletrpc.ConstructTransactionRequest.prototype.setChangeDestination = function(value) {
  jspb.Message.setWrapperField(this, 6, value);
};


proto.walletrpc.ConstructTransactionRequest.prototype.clearChangeDestination = function() {
  this.setChangeDestination(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.ConstructTransactionRequest.prototype.hasChangeDestination = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConstructTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConstructTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConstructTransactionResponse.displayName = 'proto.walletrpc.ConstructTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConstructTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConstructTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConstructTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    unsignedTransaction: msg.getUnsignedTransaction_asB64(),
    totalPreviousOutputAmount: jspb.Message.getFieldWithDefault(msg, 2, 0),
    totalOutputAmount: jspb.Message.getFieldWithDefault(msg, 3, 0),
    estimatedSignedSize: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConstructTransactionResponse}
 */
proto.walletrpc.ConstructTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConstructTransactionResponse;
  return proto.walletrpc.ConstructTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConstructTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConstructTransactionResponse}
 */
proto.walletrpc.ConstructTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setUnsignedTransaction(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalPreviousOutputAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTotalOutputAmount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setEstimatedSignedSize(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ConstructTransactionResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConstructTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConstructTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUnsignedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getTotalPreviousOutputAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getTotalOutputAmount();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getEstimatedSignedSize();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional bytes unsigned_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes unsigned_transaction = 1;
 * This is a type-conversion wrapper around `getUnsignedTransaction()`
 * @return {string}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getUnsignedTransaction()));
};


/**
 * optional bytes unsigned_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUnsignedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getUnsignedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getUnsignedTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ConstructTransactionResponse.prototype.setUnsignedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int64 total_previous_output_amount = 2;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getTotalPreviousOutputAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionResponse.prototype.setTotalPreviousOutputAmount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 total_output_amount = 3;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getTotalOutputAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionResponse.prototype.setTotalOutputAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 estimated_signed_size = 4;
 * @return {number}
 */
proto.walletrpc.ConstructTransactionResponse.prototype.getEstimatedSignedSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.ConstructTransactionResponse.prototype.setEstimatedSignedSize = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionRequest.displayName = 'proto.walletrpc.SignTransactionRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionRequest.repeatedFields_ = [3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    serializedTransaction: msg.getSerializedTransaction_asB64(),
    inputIndexesList: jspb.Message.getRepeatedField(msg, 3),
    additionalScriptsList: jspb.Message.toObjectList(msg.getAdditionalScriptsList(),
    proto.walletrpc.SignTransactionRequest.AdditionalScript.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionRequest}
 */
proto.walletrpc.SignTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionRequest;
  return proto.walletrpc.SignTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionRequest}
 */
proto.walletrpc.SignTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTransaction(value);
      break;
    case 3:
      var value = /** @type {!Array.<number>} */ (reader.readPackedUint32());
      msg.setInputIndexesList(value);
      break;
    case 4:
      var value = new proto.walletrpc.SignTransactionRequest.AdditionalScript;
      reader.readMessage(value,proto.walletrpc.SignTransactionRequest.AdditionalScript.deserializeBinaryFromReader);
      msg.addAdditionalScripts(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SignTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getSerializedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getInputIndexesList();
  if (f.length > 0) {
    writer.writePackedUint32(
      3,
      f
    );
  }
  f = message.getAdditionalScriptsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.SignTransactionRequest.AdditionalScript.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignTransactionRequest.AdditionalScript, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionRequest.AdditionalScript.displayName = 'proto.walletrpc.SignTransactionRequest.AdditionalScript';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionRequest.AdditionalScript.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionRequest.AdditionalScript} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    outputIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    tree: jspb.Message.getFieldWithDefault(msg, 3, 0),
    pkScript: msg.getPkScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionRequest.AdditionalScript}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionRequest.AdditionalScript;
  return proto.walletrpc.SignTransactionRequest.AdditionalScript.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionRequest.AdditionalScript} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionRequest.AdditionalScript}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setTree(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPkScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SignTransactionRequest.AdditionalScript.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionRequest.AdditionalScript} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getTree();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 output_index = 2;
 * @return {number}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.setOutputIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 tree = 3;
 * @return {number}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getTree = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.setTree = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes pk_script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes pk_script = 4;
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPkScript()));
};


/**
 * optional bytes pk_script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.getPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPkScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignTransactionRequest.AdditionalScript.prototype.setPkScript = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignTransactionRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes serialized_transaction = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes serialized_transaction = 2;
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {string}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTransaction()));
};


/**
 * optional bytes serialized_transaction = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionRequest.prototype.getSerializedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignTransactionRequest.prototype.setSerializedTransaction = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * repeated uint32 input_indexes = 3;
 * @return {!Array.<number>}
 */
proto.walletrpc.SignTransactionRequest.prototype.getInputIndexesList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 3));
};


/** @param {!Array.<number>} value */
proto.walletrpc.SignTransactionRequest.prototype.setInputIndexesList = function(value) {
  jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.walletrpc.SignTransactionRequest.prototype.addInputIndexes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


proto.walletrpc.SignTransactionRequest.prototype.clearInputIndexesList = function() {
  this.setInputIndexesList([]);
};


/**
 * repeated AdditionalScript additional_scripts = 4;
 * @return {!Array.<!proto.walletrpc.SignTransactionRequest.AdditionalScript>}
 */
proto.walletrpc.SignTransactionRequest.prototype.getAdditionalScriptsList = function() {
  return /** @type{!Array.<!proto.walletrpc.SignTransactionRequest.AdditionalScript>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SignTransactionRequest.AdditionalScript, 4));
};


/** @param {!Array.<!proto.walletrpc.SignTransactionRequest.AdditionalScript>} value */
proto.walletrpc.SignTransactionRequest.prototype.setAdditionalScriptsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.walletrpc.SignTransactionRequest.AdditionalScript=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.SignTransactionRequest.AdditionalScript}
 */
proto.walletrpc.SignTransactionRequest.prototype.addAdditionalScripts = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.walletrpc.SignTransactionRequest.AdditionalScript, opt_index);
};


proto.walletrpc.SignTransactionRequest.prototype.clearAdditionalScriptsList = function() {
  this.setAdditionalScriptsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SignTransactionResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SignTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignTransactionResponse.displayName = 'proto.walletrpc.SignTransactionResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SignTransactionResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transaction: msg.getTransaction_asB64(),
    unsignedInputIndexesList: jspb.Message.getRepeatedField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignTransactionResponse}
 */
proto.walletrpc.SignTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignTransactionResponse;
  return proto.walletrpc.SignTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignTransactionResponse}
 */
proto.walletrpc.SignTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransaction(value);
      break;
    case 2:
      var value = /** @type {!Array.<number>} */ (reader.readPackedUint32());
      msg.setUnsignedInputIndexesList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SignTransactionResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getUnsignedInputIndexesList();
  if (f.length > 0) {
    writer.writePackedUint32(
      2,
      f
    );
  }
};


/**
 * optional bytes transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction = 1;
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {string}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransaction()));
};


/**
 * optional bytes transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignTransactionResponse.prototype.getTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignTransactionResponse.prototype.setTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated uint32 unsigned_input_indexes = 2;
 * @return {!Array.<number>}
 */
proto.walletrpc.SignTransactionResponse.prototype.getUnsignedInputIndexesList = function() {
  return /** @type {!Array.<number>} */ (jspb.Message.getRepeatedField(this, 2));
};


/** @param {!Array.<number>} value */
proto.walletrpc.SignTransactionResponse.prototype.setUnsignedInputIndexesList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.walletrpc.SignTransactionResponse.prototype.addUnsignedInputIndexes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.walletrpc.SignTransactionResponse.prototype.clearUnsignedInputIndexesList = function() {
  this.setUnsignedInputIndexesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateSignatureRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateSignatureRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateSignatureRequest.displayName = 'proto.walletrpc.CreateSignatureRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateSignatureRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateSignatureRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateSignatureRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CreateSignatureRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    address: jspb.Message.getFieldWithDefault(msg, 2, ""),
    serializedTransaction: msg.getSerializedTransaction_asB64(),
    inputIndex: jspb.Message.getFieldWithDefault(msg, 4, 0),
    hashType: jspb.Message.getFieldWithDefault(msg, 5, 0),
    previousPkScript: msg.getPreviousPkScript_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateSignatureRequest}
 */
proto.walletrpc.CreateSignatureRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateSignatureRequest;
  return proto.walletrpc.CreateSignatureRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateSignatureRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateSignatureRequest}
 */
proto.walletrpc.CreateSignatureRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTransaction(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInputIndex(value);
      break;
    case 5:
      var value = /** @type {!proto.walletrpc.CreateSignatureRequest.SigHashType} */ (reader.readEnum());
      msg.setHashType(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPreviousPkScript(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.CreateSignatureRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateSignatureRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CreateSignatureRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSerializedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getInputIndex();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getHashType();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = message.getPreviousPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.CreateSignatureRequest.SigHashType = {
  SIGHASH_OLD: 0,
  SIGHASH_ALL: 1,
  SIGHASH_NONE: 2,
  SIGHASH_SINGLE: 3,
  SIGHASH_ALLVALUE: 4,
  SIGHASH_ANYONECANPAY: 128
};

/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateSignatureRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string address = 2;
 * @return {string}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.CreateSignatureRequest.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes serialized_transaction = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getSerializedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes serialized_transaction = 3;
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getSerializedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTransaction()));
};


/**
 * optional bytes serialized_transaction = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getSerializedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateSignatureRequest.prototype.setSerializedTransaction = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 input_index = 4;
 * @return {number}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getInputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.CreateSignatureRequest.prototype.setInputIndex = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional SigHashType hash_type = 5;
 * @return {!proto.walletrpc.CreateSignatureRequest.SigHashType}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getHashType = function() {
  return /** @type {!proto.walletrpc.CreateSignatureRequest.SigHashType} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {!proto.walletrpc.CreateSignatureRequest.SigHashType} value */
proto.walletrpc.CreateSignatureRequest.prototype.setHashType = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bytes previous_pk_script = 6;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPreviousPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes previous_pk_script = 6;
 * This is a type-conversion wrapper around `getPreviousPkScript()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPreviousPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPreviousPkScript()));
};


/**
 * optional bytes previous_pk_script = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPreviousPkScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureRequest.prototype.getPreviousPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPreviousPkScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateSignatureRequest.prototype.setPreviousPkScript = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateSignatureResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateSignatureResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateSignatureResponse.displayName = 'proto.walletrpc.CreateSignatureResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateSignatureResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateSignatureResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateSignatureResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CreateSignatureResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: msg.getSignature_asB64(),
    publicKey: msg.getPublicKey_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateSignatureResponse}
 */
proto.walletrpc.CreateSignatureResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateSignatureResponse;
  return proto.walletrpc.CreateSignatureResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateSignatureResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateSignatureResponse}
 */
proto.walletrpc.CreateSignatureResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.CreateSignatureResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateSignatureResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CreateSignatureResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPublicKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes signature = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes signature = 1;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateSignatureResponse.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes public_key = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getPublicKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes public_key = 2;
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {string}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getPublicKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicKey()));
};


/**
 * optional bytes public_key = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateSignatureResponse.prototype.getPublicKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateSignatureResponse.prototype.setPublicKey = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishTransactionRequest.displayName = 'proto.walletrpc.PublishTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PublishTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    signedTransaction: msg.getSignedTransaction_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishTransactionRequest}
 */
proto.walletrpc.PublishTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishTransactionRequest;
  return proto.walletrpc.PublishTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishTransactionRequest}
 */
proto.walletrpc.PublishTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignedTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.PublishTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PublishTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSignedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes signed_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes signed_transaction = 1;
 * This is a type-conversion wrapper around `getSignedTransaction()`
 * @return {string}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignedTransaction()));
};


/**
 * optional bytes signed_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionRequest.prototype.getSignedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignedTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.PublishTransactionRequest.prototype.setSignedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishTransactionResponse.displayName = 'proto.walletrpc.PublishTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PublishTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishTransactionResponse}
 */
proto.walletrpc.PublishTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishTransactionResponse;
  return proto.walletrpc.PublishTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishTransactionResponse}
 */
proto.walletrpc.PublishTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.PublishTransactionResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PublishTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishTransactionResponse.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.PublishTransactionResponse.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishUnminedTransactionsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishUnminedTransactionsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishUnminedTransactionsRequest.displayName = 'proto.walletrpc.PublishUnminedTransactionsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishUnminedTransactionsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishUnminedTransactionsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PublishUnminedTransactionsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishUnminedTransactionsRequest}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishUnminedTransactionsRequest;
  return proto.walletrpc.PublishUnminedTransactionsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishUnminedTransactionsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishUnminedTransactionsRequest}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishUnminedTransactionsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.PublishUnminedTransactionsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishUnminedTransactionsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PublishUnminedTransactionsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PublishUnminedTransactionsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PublishUnminedTransactionsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PublishUnminedTransactionsResponse.displayName = 'proto.walletrpc.PublishUnminedTransactionsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PublishUnminedTransactionsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PublishUnminedTransactionsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PublishUnminedTransactionsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PublishUnminedTransactionsResponse}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PublishUnminedTransactionsResponse;
  return proto.walletrpc.PublishUnminedTransactionsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PublishUnminedTransactionsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PublishUnminedTransactionsResponse}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PublishUnminedTransactionsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.PublishUnminedTransactionsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PublishUnminedTransactionsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PublishUnminedTransactionsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PurchaseTicketsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.PurchaseTicketsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PurchaseTicketsRequest.displayName = 'proto.walletrpc.PurchaseTicketsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PurchaseTicketsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PurchaseTicketsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PurchaseTicketsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: jspb.Message.getFieldWithDefault(msg, 2, 0),
    spendLimit: jspb.Message.getFieldWithDefault(msg, 3, 0),
    requiredConfirmations: jspb.Message.getFieldWithDefault(msg, 4, 0),
    ticketAddress: jspb.Message.getFieldWithDefault(msg, 5, ""),
    numTickets: jspb.Message.getFieldWithDefault(msg, 6, 0),
    poolAddress: jspb.Message.getFieldWithDefault(msg, 7, ""),
    poolFees: +jspb.Message.getFieldWithDefault(msg, 8, 0.0),
    expiry: jspb.Message.getFieldWithDefault(msg, 9, 0),
    txFee: jspb.Message.getFieldWithDefault(msg, 10, 0),
    ticketFee: jspb.Message.getFieldWithDefault(msg, 11, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PurchaseTicketsRequest}
 */
proto.walletrpc.PurchaseTicketsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PurchaseTicketsRequest;
  return proto.walletrpc.PurchaseTicketsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PurchaseTicketsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PurchaseTicketsRequest}
 */
proto.walletrpc.PurchaseTicketsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSpendLimit(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRequiredConfirmations(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setTicketAddress(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumTickets(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpiry(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTxFee(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTicketFee(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.PurchaseTicketsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PurchaseTicketsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PurchaseTicketsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getSpendLimit();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getRequiredConfirmations();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getTicketAddress();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getNumTickets();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      8,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = message.getTxFee();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = message.getTicketFee();
  if (f !== 0) {
    writer.writeInt64(
      11,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 spend_limit = 3;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getSpendLimit = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setSpendLimit = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 required_confirmations = 4;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getRequiredConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setRequiredConfirmations = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string ticket_address = 5;
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTicketAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTicketAddress = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 num_tickets = 6;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getNumTickets = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setNumTickets = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional string pool_address = 7;
 * @return {string}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/** @param {string} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional double pool_fees = 8;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getPoolFees = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 8, 0.0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional uint32 expiry = 9;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 tx_fee = 10;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTxFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTxFee = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int64 ticket_fee = 11;
 * @return {number}
 */
proto.walletrpc.PurchaseTicketsRequest.prototype.getTicketFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.walletrpc.PurchaseTicketsRequest.prototype.setTicketFee = function(value) {
  jspb.Message.setField(this, 11, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.PurchaseTicketsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.PurchaseTicketsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.PurchaseTicketsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.PurchaseTicketsResponse.displayName = 'proto.walletrpc.PurchaseTicketsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.PurchaseTicketsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.PurchaseTicketsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.PurchaseTicketsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PurchaseTicketsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    ticketHashesList: msg.getTicketHashesList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.PurchaseTicketsResponse}
 */
proto.walletrpc.PurchaseTicketsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.PurchaseTicketsResponse;
  return proto.walletrpc.PurchaseTicketsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.PurchaseTicketsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.PurchaseTicketsResponse}
 */
proto.walletrpc.PurchaseTicketsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addTicketHashes(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.PurchaseTicketsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.PurchaseTicketsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.PurchaseTicketsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTicketHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
};


/**
 * repeated bytes ticket_hashes = 1;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * repeated bytes ticket_hashes = 1;
 * This is a type-conversion wrapper around `getTicketHashesList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getTicketHashesList()));
};


/**
 * repeated bytes ticket_hashes = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTicketHashesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.getTicketHashesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getTicketHashesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.walletrpc.PurchaseTicketsResponse.prototype.setTicketHashesList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.walletrpc.PurchaseTicketsResponse.prototype.addTicketHashes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.walletrpc.PurchaseTicketsResponse.prototype.clearTicketHashesList = function() {
  this.setTicketHashesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RevokeTicketsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RevokeTicketsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RevokeTicketsRequest.displayName = 'proto.walletrpc.RevokeTicketsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RevokeTicketsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RevokeTicketsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RevokeTicketsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RevokeTicketsRequest}
 */
proto.walletrpc.RevokeTicketsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RevokeTicketsRequest;
  return proto.walletrpc.RevokeTicketsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RevokeTicketsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RevokeTicketsRequest}
 */
proto.walletrpc.RevokeTicketsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.RevokeTicketsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RevokeTicketsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RevokeTicketsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.RevokeTicketsRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.RevokeTicketsRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.RevokeTicketsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.RevokeTicketsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.RevokeTicketsResponse.displayName = 'proto.walletrpc.RevokeTicketsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.RevokeTicketsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.RevokeTicketsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.RevokeTicketsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RevokeTicketsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.RevokeTicketsResponse}
 */
proto.walletrpc.RevokeTicketsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.RevokeTicketsResponse;
  return proto.walletrpc.RevokeTicketsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.RevokeTicketsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.RevokeTicketsResponse}
 */
proto.walletrpc.RevokeTicketsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.RevokeTicketsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.RevokeTicketsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.RevokeTicketsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.RevokeTicketsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.LoadActiveDataFiltersRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.LoadActiveDataFiltersRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.LoadActiveDataFiltersRequest.displayName = 'proto.walletrpc.LoadActiveDataFiltersRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.LoadActiveDataFiltersRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.LoadActiveDataFiltersRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.LoadActiveDataFiltersRequest}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.LoadActiveDataFiltersRequest;
  return proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.LoadActiveDataFiltersRequest}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.LoadActiveDataFiltersRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.LoadActiveDataFiltersRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.LoadActiveDataFiltersRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.LoadActiveDataFiltersRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.LoadActiveDataFiltersResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.LoadActiveDataFiltersResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.LoadActiveDataFiltersResponse.displayName = 'proto.walletrpc.LoadActiveDataFiltersResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.LoadActiveDataFiltersResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.LoadActiveDataFiltersResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.LoadActiveDataFiltersResponse}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.LoadActiveDataFiltersResponse;
  return proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.LoadActiveDataFiltersResponse}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.LoadActiveDataFiltersResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.LoadActiveDataFiltersResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.LoadActiveDataFiltersResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.LoadActiveDataFiltersResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignMessageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignMessageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignMessageRequest.displayName = 'proto.walletrpc.SignMessageRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignMessageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignMessageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignMessageRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignMessageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, ""),
    message: jspb.Message.getFieldWithDefault(msg, 2, ""),
    passphrase: msg.getPassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignMessageRequest}
 */
proto.walletrpc.SignMessageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignMessageRequest;
  return proto.walletrpc.SignMessageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignMessageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignMessageRequest}
 */
proto.walletrpc.SignMessageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SignMessageRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignMessageRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignMessageRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.SignMessageRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.SignMessageRequest.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.walletrpc.SignMessageRequest.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.SignMessageRequest.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes passphrase = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignMessageRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes passphrase = 3;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.SignMessageRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessageRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignMessageRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SignMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SignMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SignMessageResponse.displayName = 'proto.walletrpc.SignMessageResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SignMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SignMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SignMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SignMessageResponse}
 */
proto.walletrpc.SignMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SignMessageResponse;
  return proto.walletrpc.SignMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SignMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SignMessageResponse}
 */
proto.walletrpc.SignMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SignMessageResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SignMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SignMessageResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes signature = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.SignMessageResponse.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes signature = 1;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.walletrpc.SignMessageResponse.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.walletrpc.SignMessageResponse.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.SignMessageResponse.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TransactionNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionNotificationsRequest.displayName = 'proto.walletrpc.TransactionNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionNotificationsRequest}
 */
proto.walletrpc.TransactionNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionNotificationsRequest;
  return proto.walletrpc.TransactionNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionNotificationsRequest}
 */
proto.walletrpc.TransactionNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TransactionNotificationsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TransactionNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.TransactionNotificationsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.TransactionNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TransactionNotificationsResponse.displayName = 'proto.walletrpc.TransactionNotificationsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.TransactionNotificationsResponse.repeatedFields_ = [1,2,3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TransactionNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TransactionNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    attachedBlocksList: jspb.Message.toObjectList(msg.getAttachedBlocksList(),
    proto.walletrpc.BlockDetails.toObject, includeInstance),
    detachedBlocksList: msg.getDetachedBlocksList_asB64(),
    unminedTransactionsList: jspb.Message.toObjectList(msg.getUnminedTransactionsList(),
    proto.walletrpc.TransactionDetails.toObject, includeInstance),
    unminedTransactionHashesList: msg.getUnminedTransactionHashesList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TransactionNotificationsResponse}
 */
proto.walletrpc.TransactionNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TransactionNotificationsResponse;
  return proto.walletrpc.TransactionNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TransactionNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TransactionNotificationsResponse}
 */
proto.walletrpc.TransactionNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.BlockDetails;
      reader.readMessage(value,proto.walletrpc.BlockDetails.deserializeBinaryFromReader);
      msg.addAttachedBlocks(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addDetachedBlocks(value);
      break;
    case 3:
      var value = new proto.walletrpc.TransactionDetails;
      reader.readMessage(value,proto.walletrpc.TransactionDetails.deserializeBinaryFromReader);
      msg.addUnminedTransactions(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addUnminedTransactionHashes(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TransactionNotificationsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TransactionNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TransactionNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAttachedBlocksList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.BlockDetails.serializeBinaryToWriter
    );
  }
  f = message.getDetachedBlocksList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
  f = message.getUnminedTransactionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.walletrpc.TransactionDetails.serializeBinaryToWriter
    );
  }
  f = message.getUnminedTransactionHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      4,
      f
    );
  }
};


/**
 * repeated BlockDetails attached_blocks = 1;
 * @return {!Array.<!proto.walletrpc.BlockDetails>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getAttachedBlocksList = function() {
  return /** @type{!Array.<!proto.walletrpc.BlockDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.BlockDetails, 1));
};


/** @param {!Array.<!proto.walletrpc.BlockDetails>} value */
proto.walletrpc.TransactionNotificationsResponse.prototype.setAttachedBlocksList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.walletrpc.BlockDetails=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.BlockDetails}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.addAttachedBlocks = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.walletrpc.BlockDetails, opt_index);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearAttachedBlocksList = function() {
  this.setAttachedBlocksList([]);
};


/**
 * repeated bytes detached_blocks = 2;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * repeated bytes detached_blocks = 2;
 * This is a type-conversion wrapper around `getDetachedBlocksList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getDetachedBlocksList()));
};


/**
 * repeated bytes detached_blocks = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDetachedBlocksList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getDetachedBlocksList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getDetachedBlocksList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.walletrpc.TransactionNotificationsResponse.prototype.setDetachedBlocksList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.addDetachedBlocks = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearDetachedBlocksList = function() {
  this.setDetachedBlocksList([]);
};


/**
 * repeated TransactionDetails unmined_transactions = 3;
 * @return {!Array.<!proto.walletrpc.TransactionDetails>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionsList = function() {
  return /** @type{!Array.<!proto.walletrpc.TransactionDetails>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.TransactionDetails, 3));
};


/** @param {!Array.<!proto.walletrpc.TransactionDetails>} value */
proto.walletrpc.TransactionNotificationsResponse.prototype.setUnminedTransactionsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.walletrpc.TransactionDetails=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.TransactionDetails}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.addUnminedTransactions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.walletrpc.TransactionDetails, opt_index);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearUnminedTransactionsList = function() {
  this.setUnminedTransactionsList([]);
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 4));
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * This is a type-conversion wrapper around `getUnminedTransactionHashesList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getUnminedTransactionHashesList()));
};


/**
 * repeated bytes unmined_transaction_hashes = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUnminedTransactionHashesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.getUnminedTransactionHashesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getUnminedTransactionHashesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.walletrpc.TransactionNotificationsResponse.prototype.setUnminedTransactionHashesList = function(value) {
  jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.walletrpc.TransactionNotificationsResponse.prototype.addUnminedTransactionHashes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


proto.walletrpc.TransactionNotificationsResponse.prototype.clearUnminedTransactionHashesList = function() {
  this.setUnminedTransactionHashesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNotificationsRequest.displayName = 'proto.walletrpc.AccountNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNotificationsRequest}
 */
proto.walletrpc.AccountNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNotificationsRequest;
  return proto.walletrpc.AccountNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNotificationsRequest}
 */
proto.walletrpc.AccountNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AccountNotificationsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AccountNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AccountNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AccountNotificationsResponse.displayName = 'proto.walletrpc.AccountNotificationsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AccountNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AccountNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountNumber: jspb.Message.getFieldWithDefault(msg, 1, 0),
    accountName: jspb.Message.getFieldWithDefault(msg, 2, ""),
    externalKeyCount: jspb.Message.getFieldWithDefault(msg, 3, 0),
    internalKeyCount: jspb.Message.getFieldWithDefault(msg, 4, 0),
    importedKeyCount: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AccountNotificationsResponse}
 */
proto.walletrpc.AccountNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AccountNotificationsResponse;
  return proto.walletrpc.AccountNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AccountNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AccountNotificationsResponse}
 */
proto.walletrpc.AccountNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAccountName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExternalKeyCount(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInternalKeyCount(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setImportedKeyCount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AccountNotificationsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AccountNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AccountNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getAccountName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getExternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getInternalKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getImportedKeyCount();
  if (f !== 0) {
    writer.writeUint32(
      5,
      f
    );
  }
};


/**
 * optional uint32 account_number = 1;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string account_name = 2;
 * @return {string}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getAccountName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setAccountName = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 external_key_count = 3;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getExternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setExternalKeyCount = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 internal_key_count = 4;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getInternalKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setInternalKeyCount = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 imported_key_count = 5;
 * @return {number}
 */
proto.walletrpc.AccountNotificationsResponse.prototype.getImportedKeyCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.AccountNotificationsResponse.prototype.setImportedKeyCount = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConfirmationNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ConfirmationNotificationsRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ConfirmationNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConfirmationNotificationsRequest.displayName = 'proto.walletrpc.ConfirmationNotificationsRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ConfirmationNotificationsRequest.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConfirmationNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConfirmationNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConfirmationNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    txHashesList: msg.getTxHashesList_asB64(),
    stopAfter: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConfirmationNotificationsRequest}
 */
proto.walletrpc.ConfirmationNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConfirmationNotificationsRequest;
  return proto.walletrpc.ConfirmationNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConfirmationNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConfirmationNotificationsRequest}
 */
proto.walletrpc.ConfirmationNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addTxHashes(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setStopAfter(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ConfirmationNotificationsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConfirmationNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConfirmationNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTxHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
  f = message.getStopAfter();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
};


/**
 * repeated bytes tx_hashes = 1;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.getTxHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * repeated bytes tx_hashes = 1;
 * This is a type-conversion wrapper around `getTxHashesList()`
 * @return {!Array.<string>}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.getTxHashesList_asB64 = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.bytesListAsB64(
      this.getTxHashesList()));
};


/**
 * repeated bytes tx_hashes = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTxHashesList()`
 * @return {!Array.<!Uint8Array>}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.getTxHashesList_asU8 = function() {
  return /** @type {!Array.<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getTxHashesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.setTxHashesList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.addTxHashes = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.walletrpc.ConfirmationNotificationsRequest.prototype.clearTxHashesList = function() {
  this.setTxHashesList([]);
};


/**
 * optional int32 stop_after = 2;
 * @return {number}
 */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.getStopAfter = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ConfirmationNotificationsRequest.prototype.setStopAfter = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConfirmationNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ConfirmationNotificationsResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ConfirmationNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConfirmationNotificationsResponse.displayName = 'proto.walletrpc.ConfirmationNotificationsResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ConfirmationNotificationsResponse.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConfirmationNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConfirmationNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    confirmationsList: jspb.Message.toObjectList(msg.getConfirmationsList(),
    proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse}
 */
proto.walletrpc.ConfirmationNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConfirmationNotificationsResponse;
  return proto.walletrpc.ConfirmationNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse}
 */
proto.walletrpc.ConfirmationNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations;
      reader.readMessage(value,proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.deserializeBinaryFromReader);
      msg.addConfirmations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ConfirmationNotificationsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConfirmationNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getConfirmationsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.displayName = 'proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.toObject = function(includeInstance, msg) {
  var f, obj = {
    txHash: msg.getTxHash_asB64(),
    confirmations: jspb.Message.getFieldWithDefault(msg, 2, 0),
    blockHash: msg.getBlockHash_asB64(),
    blockHeight: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations;
  return proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTxHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setConfirmations(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBlockHash(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTxHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getConfirmations();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
};


/**
 * optional bytes tx_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getTxHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes tx_hash = 1;
 * This is a type-conversion wrapper around `getTxHash()`
 * @return {string}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getTxHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTxHash()));
};


/**
 * optional bytes tx_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTxHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getTxHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTxHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.setTxHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 confirmations = 2;
 * @return {number}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getConfirmations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.setConfirmations = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes block_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes block_hash = 3;
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {string}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBlockHash()));
};


/**
 * optional bytes block_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.setBlockHash = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int32 block_height = 4;
 * @return {number}
 */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * repeated TransactionConfirmations confirmations = 1;
 * @return {!Array.<!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations>}
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.getConfirmationsList = function() {
  return /** @type{!Array.<!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations, 1));
};


/** @param {!Array.<!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations>} value */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.setConfirmationsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations}
 */
proto.walletrpc.ConfirmationNotificationsResponse.prototype.addConfirmations = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.walletrpc.ConfirmationNotificationsResponse.TransactionConfirmations, opt_index);
};


proto.walletrpc.ConfirmationNotificationsResponse.prototype.clearConfirmationsList = function() {
  this.setConfirmationsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateWalletRequest.displayName = 'proto.walletrpc.CreateWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CreateWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    publicPassphrase: msg.getPublicPassphrase_asB64(),
    privatePassphrase: msg.getPrivatePassphrase_asB64(),
    seed: msg.getSeed_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateWalletRequest}
 */
proto.walletrpc.CreateWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateWalletRequest;
  return proto.walletrpc.CreateWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateWalletRequest}
 */
proto.walletrpc.CreateWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSeed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.CreateWalletRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CreateWalletRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPublicPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getSeed_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional bytes public_passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes public_passphrase = 1;
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicPassphrase()));
};


/**
 * optional bytes public_passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPublicPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateWalletRequest.prototype.setPublicPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes private_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes private_passphrase = 2;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateWalletRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes seed = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes seed = 3;
 * This is a type-conversion wrapper around `getSeed()`
 * @return {string}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSeed()));
};


/**
 * optional bytes seed = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSeed()`
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletRequest.prototype.getSeed_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSeed()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.CreateWalletRequest.prototype.setSeed = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CreateWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CreateWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CreateWalletResponse.displayName = 'proto.walletrpc.CreateWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CreateWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CreateWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CreateWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CreateWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CreateWalletResponse}
 */
proto.walletrpc.CreateWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CreateWalletResponse;
  return proto.walletrpc.CreateWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CreateWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CreateWalletResponse}
 */
proto.walletrpc.CreateWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CreateWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.CreateWalletResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CreateWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CreateWalletResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.OpenWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.OpenWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.OpenWalletRequest.displayName = 'proto.walletrpc.OpenWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.OpenWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.OpenWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.OpenWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.OpenWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    publicPassphrase: msg.getPublicPassphrase_asB64(),
    privatePassphrase: msg.getPrivatePassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.OpenWalletRequest}
 */
proto.walletrpc.OpenWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.OpenWalletRequest;
  return proto.walletrpc.OpenWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.OpenWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.OpenWalletRequest}
 */
proto.walletrpc.OpenWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicPassphrase(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.OpenWalletRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.OpenWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.OpenWalletRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPublicPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes public_passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes public_passphrase = 1;
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {string}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicPassphrase()));
};


/**
 * optional bytes public_passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPublicPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.OpenWalletRequest.prototype.setPublicPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes private_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes private_passphrase = 2;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.OpenWalletRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.OpenWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.OpenWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.OpenWalletResponse.displayName = 'proto.walletrpc.OpenWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.OpenWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.OpenWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.OpenWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.OpenWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.OpenWalletResponse}
 */
proto.walletrpc.OpenWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.OpenWalletResponse;
  return proto.walletrpc.OpenWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.OpenWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.OpenWalletResponse}
 */
proto.walletrpc.OpenWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.OpenWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.OpenWalletResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.OpenWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.OpenWalletResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CloseWalletRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CloseWalletRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CloseWalletRequest.displayName = 'proto.walletrpc.CloseWalletRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CloseWalletRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CloseWalletRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CloseWalletRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CloseWalletRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CloseWalletRequest}
 */
proto.walletrpc.CloseWalletRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CloseWalletRequest;
  return proto.walletrpc.CloseWalletRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CloseWalletRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CloseWalletRequest}
 */
proto.walletrpc.CloseWalletRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CloseWalletRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.CloseWalletRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CloseWalletRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CloseWalletRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.CloseWalletResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.CloseWalletResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.CloseWalletResponse.displayName = 'proto.walletrpc.CloseWalletResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.CloseWalletResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.CloseWalletResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.CloseWalletResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CloseWalletResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.CloseWalletResponse}
 */
proto.walletrpc.CloseWalletResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.CloseWalletResponse;
  return proto.walletrpc.CloseWalletResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.CloseWalletResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.CloseWalletResponse}
 */
proto.walletrpc.CloseWalletResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.CloseWalletResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.CloseWalletResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.CloseWalletResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.CloseWalletResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.WalletExistsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.WalletExistsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.WalletExistsRequest.displayName = 'proto.walletrpc.WalletExistsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.WalletExistsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.WalletExistsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.WalletExistsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.WalletExistsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.WalletExistsRequest}
 */
proto.walletrpc.WalletExistsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.WalletExistsRequest;
  return proto.walletrpc.WalletExistsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.WalletExistsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.WalletExistsRequest}
 */
proto.walletrpc.WalletExistsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.WalletExistsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.WalletExistsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.WalletExistsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.WalletExistsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.WalletExistsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.WalletExistsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.WalletExistsResponse.displayName = 'proto.walletrpc.WalletExistsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.WalletExistsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.WalletExistsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.WalletExistsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.WalletExistsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    exists: jspb.Message.getFieldWithDefault(msg, 1, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.WalletExistsResponse}
 */
proto.walletrpc.WalletExistsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.WalletExistsResponse;
  return proto.walletrpc.WalletExistsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.WalletExistsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.WalletExistsResponse}
 */
proto.walletrpc.WalletExistsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setExists(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.WalletExistsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.WalletExistsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.WalletExistsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.WalletExistsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getExists();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool exists = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.WalletExistsResponse.prototype.getExists = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.walletrpc.WalletExistsResponse.prototype.setExists = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartConsensusRpcRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartConsensusRpcRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartConsensusRpcRequest.displayName = 'proto.walletrpc.StartConsensusRpcRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartConsensusRpcRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartConsensusRpcRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StartConsensusRpcRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    networkAddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    username: jspb.Message.getFieldWithDefault(msg, 2, ""),
    password: msg.getPassword_asB64(),
    certificate: msg.getCertificate_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartConsensusRpcRequest}
 */
proto.walletrpc.StartConsensusRpcRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartConsensusRpcRequest;
  return proto.walletrpc.StartConsensusRpcRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartConsensusRpcRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartConsensusRpcRequest}
 */
proto.walletrpc.StartConsensusRpcRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setNetworkAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUsername(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassword(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setCertificate(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.StartConsensusRpcRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartConsensusRpcRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StartConsensusRpcRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNetworkAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getUsername();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getPassword_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getCertificate_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional string network_address = 1;
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getNetworkAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.StartConsensusRpcRequest.prototype.setNetworkAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string username = 2;
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getUsername = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.StartConsensusRpcRequest.prototype.setUsername = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes password = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes password = 3;
 * This is a type-conversion wrapper around `getPassword()`
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassword()));
};


/**
 * optional bytes password = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassword()`
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getPassword_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassword()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.StartConsensusRpcRequest.prototype.setPassword = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes certificate = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes certificate = 4;
 * This is a type-conversion wrapper around `getCertificate()`
 * @return {string}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getCertificate()));
};


/**
 * optional bytes certificate = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getCertificate()`
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcRequest.prototype.getCertificate_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getCertificate()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.StartConsensusRpcRequest.prototype.setCertificate = function(value) {
  jspb.Message.setField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartConsensusRpcResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartConsensusRpcResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartConsensusRpcResponse.displayName = 'proto.walletrpc.StartConsensusRpcResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartConsensusRpcResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartConsensusRpcResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StartConsensusRpcResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartConsensusRpcResponse}
 */
proto.walletrpc.StartConsensusRpcResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartConsensusRpcResponse;
  return proto.walletrpc.StartConsensusRpcResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartConsensusRpcResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartConsensusRpcResponse}
 */
proto.walletrpc.StartConsensusRpcResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartConsensusRpcResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.StartConsensusRpcResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartConsensusRpcResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StartConsensusRpcResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DiscoverAddressesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DiscoverAddressesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DiscoverAddressesRequest.displayName = 'proto.walletrpc.DiscoverAddressesRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DiscoverAddressesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DiscoverAddressesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DiscoverAddressesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    discoverAccounts: jspb.Message.getFieldWithDefault(msg, 1, false),
    privatePassphrase: msg.getPrivatePassphrase_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DiscoverAddressesRequest}
 */
proto.walletrpc.DiscoverAddressesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DiscoverAddressesRequest;
  return proto.walletrpc.DiscoverAddressesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DiscoverAddressesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DiscoverAddressesRequest}
 */
proto.walletrpc.DiscoverAddressesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDiscoverAccounts(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivatePassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DiscoverAddressesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DiscoverAddressesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DiscoverAddressesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDiscoverAccounts();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getPrivatePassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bool discover_accounts = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getDiscoverAccounts = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.walletrpc.DiscoverAddressesRequest.prototype.setDiscoverAccounts = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes private_passphrase = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes private_passphrase = 2;
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {string}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivatePassphrase()));
};


/**
 * optional bytes private_passphrase = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivatePassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesRequest.prototype.getPrivatePassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivatePassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DiscoverAddressesRequest.prototype.setPrivatePassphrase = function(value) {
  jspb.Message.setField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DiscoverAddressesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DiscoverAddressesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DiscoverAddressesResponse.displayName = 'proto.walletrpc.DiscoverAddressesResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DiscoverAddressesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DiscoverAddressesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DiscoverAddressesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DiscoverAddressesResponse}
 */
proto.walletrpc.DiscoverAddressesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DiscoverAddressesResponse;
  return proto.walletrpc.DiscoverAddressesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DiscoverAddressesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DiscoverAddressesResponse}
 */
proto.walletrpc.DiscoverAddressesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DiscoverAddressesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DiscoverAddressesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DiscoverAddressesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DiscoverAddressesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SubscribeToBlockNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SubscribeToBlockNotificationsRequest.displayName = 'proto.walletrpc.SubscribeToBlockNotificationsRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SubscribeToBlockNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsRequest}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SubscribeToBlockNotificationsRequest;
  return proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsRequest}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SubscribeToBlockNotificationsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SubscribeToBlockNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SubscribeToBlockNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SubscribeToBlockNotificationsResponse.displayName = 'proto.walletrpc.SubscribeToBlockNotificationsResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SubscribeToBlockNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsResponse}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SubscribeToBlockNotificationsResponse;
  return proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SubscribeToBlockNotificationsResponse}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SubscribeToBlockNotificationsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SubscribeToBlockNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SubscribeToBlockNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchHeadersRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchHeadersRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchHeadersRequest.displayName = 'proto.walletrpc.FetchHeadersRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchHeadersRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchHeadersRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FetchHeadersRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchHeadersRequest}
 */
proto.walletrpc.FetchHeadersRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchHeadersRequest;
  return proto.walletrpc.FetchHeadersRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchHeadersRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchHeadersRequest}
 */
proto.walletrpc.FetchHeadersRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.FetchHeadersRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchHeadersRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FetchHeadersRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.FetchHeadersResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.FetchHeadersResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.FetchHeadersResponse.displayName = 'proto.walletrpc.FetchHeadersResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.FetchHeadersResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.FetchHeadersResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.FetchHeadersResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FetchHeadersResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    fetchedHeadersCount: jspb.Message.getFieldWithDefault(msg, 1, 0),
    firstNewBlockHash: msg.getFirstNewBlockHash_asB64(),
    firstNewBlockHeight: jspb.Message.getFieldWithDefault(msg, 3, 0),
    mainChainTipBlockHash: msg.getMainChainTipBlockHash_asB64(),
    mainChainTipBlockHeight: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.FetchHeadersResponse}
 */
proto.walletrpc.FetchHeadersResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.FetchHeadersResponse;
  return proto.walletrpc.FetchHeadersResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.FetchHeadersResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.FetchHeadersResponse}
 */
proto.walletrpc.FetchHeadersResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFetchedHeadersCount(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setFirstNewBlockHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setFirstNewBlockHeight(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMainChainTipBlockHash(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMainChainTipBlockHeight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.FetchHeadersResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.FetchHeadersResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.FetchHeadersResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getFetchedHeadersCount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getFirstNewBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getFirstNewBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getMainChainTipBlockHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getMainChainTipBlockHeight();
  if (f !== 0) {
    writer.writeInt32(
      5,
      f
    );
  }
};


/**
 * optional uint32 fetched_headers_count = 1;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFetchedHeadersCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.FetchHeadersResponse.prototype.setFetchedHeadersCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bytes first_new_block_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes first_new_block_hash = 2;
 * This is a type-conversion wrapper around `getFirstNewBlockHash()`
 * @return {string}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getFirstNewBlockHash()));
};


/**
 * optional bytes first_new_block_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFirstNewBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getFirstNewBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FetchHeadersResponse.prototype.setFirstNewBlockHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 first_new_block_height = 3;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getFirstNewBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.FetchHeadersResponse.prototype.setFirstNewBlockHeight = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * This is a type-conversion wrapper around `getMainChainTipBlockHash()`
 * @return {string}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMainChainTipBlockHash()));
};


/**
 * optional bytes main_chain_tip_block_hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMainChainTipBlockHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMainChainTipBlockHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.FetchHeadersResponse.prototype.setMainChainTipBlockHash = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int32 main_chain_tip_block_height = 5;
 * @return {number}
 */
proto.walletrpc.FetchHeadersResponse.prototype.getMainChainTipBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.FetchHeadersResponse.prototype.setMainChainTipBlockHeight = function(value) {
  jspb.Message.setField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GenerateRandomSeedRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GenerateRandomSeedRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GenerateRandomSeedRequest.displayName = 'proto.walletrpc.GenerateRandomSeedRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GenerateRandomSeedRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GenerateRandomSeedRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    seedLength: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GenerateRandomSeedRequest}
 */
proto.walletrpc.GenerateRandomSeedRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GenerateRandomSeedRequest;
  return proto.walletrpc.GenerateRandomSeedRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GenerateRandomSeedRequest}
 */
proto.walletrpc.GenerateRandomSeedRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSeedLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GenerateRandomSeedRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GenerateRandomSeedRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GenerateRandomSeedRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSeedLength();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 seed_length = 1;
 * @return {number}
 */
proto.walletrpc.GenerateRandomSeedRequest.prototype.getSeedLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.GenerateRandomSeedRequest.prototype.setSeedLength = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.GenerateRandomSeedResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.GenerateRandomSeedResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.GenerateRandomSeedResponse.displayName = 'proto.walletrpc.GenerateRandomSeedResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.GenerateRandomSeedResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GenerateRandomSeedResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    seedBytes: msg.getSeedBytes_asB64(),
    seedHex: jspb.Message.getFieldWithDefault(msg, 2, ""),
    seedMnemonic: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.GenerateRandomSeedResponse}
 */
proto.walletrpc.GenerateRandomSeedResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.GenerateRandomSeedResponse;
  return proto.walletrpc.GenerateRandomSeedResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.GenerateRandomSeedResponse}
 */
proto.walletrpc.GenerateRandomSeedResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSeedBytes(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSeedHex(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setSeedMnemonic(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.GenerateRandomSeedResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.GenerateRandomSeedResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.GenerateRandomSeedResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSeedBytes_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getSeedHex();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSeedMnemonic();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional bytes seed_bytes = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes seed_bytes = 1;
 * This is a type-conversion wrapper around `getSeedBytes()`
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSeedBytes()));
};


/**
 * optional bytes seed_bytes = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSeedBytes()`
 * @return {!Uint8Array}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedBytes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSeedBytes()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedBytes = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string seed_hex = 2;
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedHex = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedHex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string seed_mnemonic = 3;
 * @return {string}
 */
proto.walletrpc.GenerateRandomSeedResponse.prototype.getSeedMnemonic = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.walletrpc.GenerateRandomSeedResponse.prototype.setSeedMnemonic = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeSeedRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeSeedRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeSeedRequest.displayName = 'proto.walletrpc.DecodeSeedRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeSeedRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeSeedRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodeSeedRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    userInput: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeSeedRequest}
 */
proto.walletrpc.DecodeSeedRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeSeedRequest;
  return proto.walletrpc.DecodeSeedRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeSeedRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeSeedRequest}
 */
proto.walletrpc.DecodeSeedRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserInput(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DecodeSeedRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeSeedRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodeSeedRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getUserInput();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string user_input = 1;
 * @return {string}
 */
proto.walletrpc.DecodeSeedRequest.prototype.getUserInput = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.DecodeSeedRequest.prototype.setUserInput = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeSeedResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeSeedResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeSeedResponse.displayName = 'proto.walletrpc.DecodeSeedResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeSeedResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeSeedResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeSeedResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodeSeedResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    decodedSeed: msg.getDecodedSeed_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeSeedResponse}
 */
proto.walletrpc.DecodeSeedResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeSeedResponse;
  return proto.walletrpc.DecodeSeedResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeSeedResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeSeedResponse}
 */
proto.walletrpc.DecodeSeedResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDecodedSeed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DecodeSeedResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeSeedResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodeSeedResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDecodedSeed_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes decoded_seed = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes decoded_seed = 1;
 * This is a type-conversion wrapper around `getDecodedSeed()`
 * @return {string}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDecodedSeed()));
};


/**
 * optional bytes decoded_seed = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDecodedSeed()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeSeedResponse.prototype.getDecodedSeed_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDecodedSeed()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DecodeSeedResponse.prototype.setDecodedSeed = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartAutoBuyerRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartAutoBuyerRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartAutoBuyerRequest.displayName = 'proto.walletrpc.StartAutoBuyerRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartAutoBuyerRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartAutoBuyerRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StartAutoBuyerRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: msg.getPassphrase_asB64(),
    account: jspb.Message.getFieldWithDefault(msg, 2, 0),
    balanceToMaintain: jspb.Message.getFieldWithDefault(msg, 3, 0),
    maxFeePerKb: jspb.Message.getFieldWithDefault(msg, 4, 0),
    maxPriceRelative: +jspb.Message.getFieldWithDefault(msg, 5, 0.0),
    maxPriceAbsolute: jspb.Message.getFieldWithDefault(msg, 6, 0),
    votingAddress: jspb.Message.getFieldWithDefault(msg, 7, ""),
    poolAddress: jspb.Message.getFieldWithDefault(msg, 8, ""),
    poolFees: +jspb.Message.getFieldWithDefault(msg, 9, 0.0),
    maxPerBlock: jspb.Message.getFieldWithDefault(msg, 10, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartAutoBuyerRequest}
 */
proto.walletrpc.StartAutoBuyerRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartAutoBuyerRequest;
  return proto.walletrpc.StartAutoBuyerRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartAutoBuyerRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartAutoBuyerRequest}
 */
proto.walletrpc.StartAutoBuyerRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPassphrase(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBalanceToMaintain(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxFeePerKb(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setMaxPriceRelative(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPriceAbsolute(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setVotingAddress(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPerBlock(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.StartAutoBuyerRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartAutoBuyerRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StartAutoBuyerRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPassphrase_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getBalanceToMaintain();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getMaxFeePerKb();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getMaxPriceRelative();
  if (f !== 0.0) {
    writer.writeDouble(
      5,
      f
    );
  }
  f = message.getMaxPriceAbsolute();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
  f = message.getVotingAddress();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      9,
      f
    );
  }
  f = message.getMaxPerBlock();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
};


/**
 * optional bytes passphrase = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPassphrase = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes passphrase = 1;
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {string}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPassphrase_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPassphrase()));
};


/**
 * optional bytes passphrase = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPassphrase()`
 * @return {!Uint8Array}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPassphrase_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPassphrase()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 account = 2;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 balance_to_maintain = 3;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getBalanceToMaintain = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setBalanceToMaintain = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 max_fee_per_kb = 4;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getMaxFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setMaxFeePerKb = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional double max_price_relative = 5;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getMaxPriceRelative = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 5, 0.0));
};


/** @param {number} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setMaxPriceRelative = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 max_price_absolute = 6;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getMaxPriceAbsolute = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setMaxPriceAbsolute = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional string voting_address = 7;
 * @return {string}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getVotingAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/** @param {string} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setVotingAddress = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional string pool_address = 8;
 * @return {string}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional double pool_fees = 9;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getPoolFees = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 9, 0.0));
};


/** @param {number} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 max_per_block = 10;
 * @return {number}
 */
proto.walletrpc.StartAutoBuyerRequest.prototype.getMaxPerBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.walletrpc.StartAutoBuyerRequest.prototype.setMaxPerBlock = function(value) {
  jspb.Message.setField(this, 10, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StartAutoBuyerResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StartAutoBuyerResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StartAutoBuyerResponse.displayName = 'proto.walletrpc.StartAutoBuyerResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StartAutoBuyerResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StartAutoBuyerResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StartAutoBuyerResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StartAutoBuyerResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StartAutoBuyerResponse}
 */
proto.walletrpc.StartAutoBuyerResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StartAutoBuyerResponse;
  return proto.walletrpc.StartAutoBuyerResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StartAutoBuyerResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StartAutoBuyerResponse}
 */
proto.walletrpc.StartAutoBuyerResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StartAutoBuyerResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.StartAutoBuyerResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StartAutoBuyerResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StartAutoBuyerResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StopAutoBuyerRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StopAutoBuyerRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StopAutoBuyerRequest.displayName = 'proto.walletrpc.StopAutoBuyerRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StopAutoBuyerRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StopAutoBuyerRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StopAutoBuyerRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StopAutoBuyerRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StopAutoBuyerRequest}
 */
proto.walletrpc.StopAutoBuyerRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StopAutoBuyerRequest;
  return proto.walletrpc.StopAutoBuyerRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StopAutoBuyerRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StopAutoBuyerRequest}
 */
proto.walletrpc.StopAutoBuyerRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StopAutoBuyerRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.StopAutoBuyerRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StopAutoBuyerRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StopAutoBuyerRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.StopAutoBuyerResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.StopAutoBuyerResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.StopAutoBuyerResponse.displayName = 'proto.walletrpc.StopAutoBuyerResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.StopAutoBuyerResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.StopAutoBuyerResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.StopAutoBuyerResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StopAutoBuyerResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.StopAutoBuyerResponse}
 */
proto.walletrpc.StopAutoBuyerResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.StopAutoBuyerResponse;
  return proto.walletrpc.StopAutoBuyerResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.StopAutoBuyerResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.StopAutoBuyerResponse}
 */
proto.walletrpc.StopAutoBuyerResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.StopAutoBuyerResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.StopAutoBuyerResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.StopAutoBuyerResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.StopAutoBuyerResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketBuyerConfigRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketBuyerConfigRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketBuyerConfigRequest.displayName = 'proto.walletrpc.TicketBuyerConfigRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketBuyerConfigRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketBuyerConfigRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketBuyerConfigRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TicketBuyerConfigRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketBuyerConfigRequest}
 */
proto.walletrpc.TicketBuyerConfigRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketBuyerConfigRequest;
  return proto.walletrpc.TicketBuyerConfigRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketBuyerConfigRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketBuyerConfigRequest}
 */
proto.walletrpc.TicketBuyerConfigRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketBuyerConfigRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TicketBuyerConfigRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketBuyerConfigRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TicketBuyerConfigRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.TicketBuyerConfigResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.TicketBuyerConfigResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.TicketBuyerConfigResponse.displayName = 'proto.walletrpc.TicketBuyerConfigResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.TicketBuyerConfigResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.TicketBuyerConfigResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TicketBuyerConfigResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0),
    avgPriceMode: jspb.Message.getFieldWithDefault(msg, 2, ""),
    avgPricevwapDelta: jspb.Message.getFieldWithDefault(msg, 3, 0),
    balanceToMaintain: jspb.Message.getFieldWithDefault(msg, 4, 0),
    blocksToAvg: jspb.Message.getFieldWithDefault(msg, 5, 0),
    dontWaitForTickets: jspb.Message.getFieldWithDefault(msg, 6, false),
    expiryDelta: jspb.Message.getFieldWithDefault(msg, 7, 0),
    feeSource: jspb.Message.getFieldWithDefault(msg, 8, ""),
    feeTargetScaling: +jspb.Message.getFieldWithDefault(msg, 9, 0.0),
    minFee: jspb.Message.getFieldWithDefault(msg, 10, 0),
    maxFee: jspb.Message.getFieldWithDefault(msg, 12, 0),
    maxPerBlock: jspb.Message.getFieldWithDefault(msg, 13, 0),
    maxPriceAbsolute: jspb.Message.getFieldWithDefault(msg, 14, 0),
    maxPriceRelative: +jspb.Message.getFieldWithDefault(msg, 15, 0.0),
    maxInMempool: jspb.Message.getFieldWithDefault(msg, 17, 0),
    poolAddress: jspb.Message.getFieldWithDefault(msg, 18, ""),
    poolFees: +jspb.Message.getFieldWithDefault(msg, 19, 0.0),
    spreadTicketPurchases: jspb.Message.getFieldWithDefault(msg, 20, false),
    votingAddress: jspb.Message.getFieldWithDefault(msg, 21, ""),
    txFee: jspb.Message.getFieldWithDefault(msg, 22, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.TicketBuyerConfigResponse}
 */
proto.walletrpc.TicketBuyerConfigResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.TicketBuyerConfigResponse;
  return proto.walletrpc.TicketBuyerConfigResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.TicketBuyerConfigResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.TicketBuyerConfigResponse}
 */
proto.walletrpc.TicketBuyerConfigResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAvgPriceMode(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAvgPricevwapDelta(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBalanceToMaintain(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBlocksToAvg(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDontWaitForTickets(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setExpiryDelta(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setFeeSource(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setFeeTargetScaling(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMinFee(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxFee(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPerBlock(value);
      break;
    case 14:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPriceAbsolute(value);
      break;
    case 15:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setMaxPriceRelative(value);
      break;
    case 17:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxInMempool(value);
      break;
    case 18:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    case 19:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    case 20:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSpreadTicketPurchases(value);
      break;
    case 21:
      var value = /** @type {string} */ (reader.readString());
      msg.setVotingAddress(value);
      break;
    case 22:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setTxFee(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.TicketBuyerConfigResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.TicketBuyerConfigResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.TicketBuyerConfigResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getAvgPriceMode();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAvgPricevwapDelta();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getBalanceToMaintain();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getBlocksToAvg();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getDontWaitForTickets();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getExpiryDelta();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getFeeSource();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
  f = message.getFeeTargetScaling();
  if (f !== 0.0) {
    writer.writeDouble(
      9,
      f
    );
  }
  f = message.getMinFee();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = message.getMaxFee();
  if (f !== 0) {
    writer.writeInt64(
      12,
      f
    );
  }
  f = message.getMaxPerBlock();
  if (f !== 0) {
    writer.writeInt64(
      13,
      f
    );
  }
  f = message.getMaxPriceAbsolute();
  if (f !== 0) {
    writer.writeInt64(
      14,
      f
    );
  }
  f = message.getMaxPriceRelative();
  if (f !== 0.0) {
    writer.writeDouble(
      15,
      f
    );
  }
  f = message.getMaxInMempool();
  if (f !== 0) {
    writer.writeInt64(
      17,
      f
    );
  }
  f = message.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      18,
      f
    );
  }
  f = message.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      19,
      f
    );
  }
  f = message.getSpreadTicketPurchases();
  if (f) {
    writer.writeBool(
      20,
      f
    );
  }
  f = message.getVotingAddress();
  if (f.length > 0) {
    writer.writeString(
      21,
      f
    );
  }
  f = message.getTxFee();
  if (f !== 0) {
    writer.writeInt64(
      22,
      f
    );
  }
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string avg_price_mode = 2;
 * @return {string}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getAvgPriceMode = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setAvgPriceMode = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int64 avg_priceVWAP_delta = 3;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getAvgPricevwapDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setAvgPricevwapDelta = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional int64 balance_to_maintain = 4;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getBalanceToMaintain = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setBalanceToMaintain = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 blocks_to_avg = 5;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getBlocksToAvg = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setBlocksToAvg = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool dont_wait_for_tickets = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getDontWaitForTickets = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setDontWaitForTickets = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional int64 expiry_delta = 7;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getExpiryDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setExpiryDelta = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional string fee_source = 8;
 * @return {string}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getFeeSource = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setFeeSource = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional double fee_target_scaling = 9;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getFeeTargetScaling = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 9, 0.0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setFeeTargetScaling = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional int64 min_fee = 10;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMinFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMinFee = function(value) {
  jspb.Message.setField(this, 10, value);
};


/**
 * optional int64 max_fee = 12;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxFee = function(value) {
  jspb.Message.setField(this, 12, value);
};


/**
 * optional int64 max_per_block = 13;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxPerBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxPerBlock = function(value) {
  jspb.Message.setField(this, 13, value);
};


/**
 * optional int64 max_price_absolute = 14;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxPriceAbsolute = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 14, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxPriceAbsolute = function(value) {
  jspb.Message.setField(this, 14, value);
};


/**
 * optional double max_price_relative = 15;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxPriceRelative = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 15, 0.0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxPriceRelative = function(value) {
  jspb.Message.setField(this, 15, value);
};


/**
 * optional int64 max_in_mempool = 17;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getMaxInMempool = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 17, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setMaxInMempool = function(value) {
  jspb.Message.setField(this, 17, value);
};


/**
 * optional string pool_address = 18;
 * @return {string}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 18, ""));
};


/** @param {string} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 18, value);
};


/**
 * optional double pool_fees = 19;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getPoolFees = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 19, 0.0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 19, value);
};


/**
 * optional bool spread_ticket_purchases = 20;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getSpreadTicketPurchases = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 20, false));
};


/** @param {boolean} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setSpreadTicketPurchases = function(value) {
  jspb.Message.setField(this, 20, value);
};


/**
 * optional string voting_address = 21;
 * @return {string}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getVotingAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 21, ""));
};


/** @param {string} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setVotingAddress = function(value) {
  jspb.Message.setField(this, 21, value);
};


/**
 * optional int64 tx_fee = 22;
 * @return {number}
 */
proto.walletrpc.TicketBuyerConfigResponse.prototype.getTxFee = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 22, 0));
};


/** @param {number} value */
proto.walletrpc.TicketBuyerConfigResponse.prototype.setTxFee = function(value) {
  jspb.Message.setField(this, 22, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetAccountRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetAccountRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetAccountRequest.displayName = 'proto.walletrpc.SetAccountRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetAccountRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetAccountRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetAccountRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetAccountRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetAccountRequest}
 */
proto.walletrpc.SetAccountRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetAccountRequest;
  return proto.walletrpc.SetAccountRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetAccountRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetAccountRequest}
 */
proto.walletrpc.SetAccountRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetAccountRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetAccountRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetAccountRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetAccountRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccount();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 account = 1;
 * @return {number}
 */
proto.walletrpc.SetAccountRequest.prototype.getAccount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.SetAccountRequest.prototype.setAccount = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetAccountResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetAccountResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetAccountResponse.displayName = 'proto.walletrpc.SetAccountResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetAccountResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetAccountResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetAccountResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetAccountResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetAccountResponse}
 */
proto.walletrpc.SetAccountResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetAccountResponse;
  return proto.walletrpc.SetAccountResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetAccountResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetAccountResponse}
 */
proto.walletrpc.SetAccountResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetAccountResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetAccountResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetAccountResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetAccountResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetBalanceToMaintainRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetBalanceToMaintainRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetBalanceToMaintainRequest.displayName = 'proto.walletrpc.SetBalanceToMaintainRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetBalanceToMaintainRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetBalanceToMaintainRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetBalanceToMaintainRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    balanceToMaintain: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetBalanceToMaintainRequest}
 */
proto.walletrpc.SetBalanceToMaintainRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetBalanceToMaintainRequest;
  return proto.walletrpc.SetBalanceToMaintainRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetBalanceToMaintainRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetBalanceToMaintainRequest}
 */
proto.walletrpc.SetBalanceToMaintainRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setBalanceToMaintain(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetBalanceToMaintainRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetBalanceToMaintainRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetBalanceToMaintainRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBalanceToMaintain();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * optional int64 balance_to_maintain = 1;
 * @return {number}
 */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.getBalanceToMaintain = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.SetBalanceToMaintainRequest.prototype.setBalanceToMaintain = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetBalanceToMaintainResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetBalanceToMaintainResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetBalanceToMaintainResponse.displayName = 'proto.walletrpc.SetBalanceToMaintainResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetBalanceToMaintainResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetBalanceToMaintainResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetBalanceToMaintainResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetBalanceToMaintainResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetBalanceToMaintainResponse}
 */
proto.walletrpc.SetBalanceToMaintainResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetBalanceToMaintainResponse;
  return proto.walletrpc.SetBalanceToMaintainResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetBalanceToMaintainResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetBalanceToMaintainResponse}
 */
proto.walletrpc.SetBalanceToMaintainResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetBalanceToMaintainResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetBalanceToMaintainResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetBalanceToMaintainResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetBalanceToMaintainResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxFeeRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxFeeRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxFeeRequest.displayName = 'proto.walletrpc.SetMaxFeeRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxFeeRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxFeeRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxFeeRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxFeeRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    maxFeePerKb: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxFeeRequest}
 */
proto.walletrpc.SetMaxFeeRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxFeeRequest;
  return proto.walletrpc.SetMaxFeeRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxFeeRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxFeeRequest}
 */
proto.walletrpc.SetMaxFeeRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxFeePerKb(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxFeeRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetMaxFeeRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxFeeRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxFeeRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMaxFeePerKb();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * optional int64 max_fee_per_kb = 1;
 * @return {number}
 */
proto.walletrpc.SetMaxFeeRequest.prototype.getMaxFeePerKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.SetMaxFeeRequest.prototype.setMaxFeePerKb = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxFeeResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxFeeResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxFeeResponse.displayName = 'proto.walletrpc.SetMaxFeeResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxFeeResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxFeeResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxFeeResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxFeeResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxFeeResponse}
 */
proto.walletrpc.SetMaxFeeResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxFeeResponse;
  return proto.walletrpc.SetMaxFeeResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxFeeResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxFeeResponse}
 */
proto.walletrpc.SetMaxFeeResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxFeeResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetMaxFeeResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxFeeResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxFeeResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPriceRelativeRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPriceRelativeRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPriceRelativeRequest.displayName = 'proto.walletrpc.SetMaxPriceRelativeRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPriceRelativeRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPriceRelativeRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPriceRelativeRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    maxPriceRelative: +jspb.Message.getFieldWithDefault(msg, 1, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPriceRelativeRequest}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPriceRelativeRequest;
  return proto.walletrpc.SetMaxPriceRelativeRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPriceRelativeRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPriceRelativeRequest}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setMaxPriceRelative(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetMaxPriceRelativeRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPriceRelativeRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPriceRelativeRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMaxPriceRelative();
  if (f !== 0.0) {
    writer.writeDouble(
      1,
      f
    );
  }
};


/**
 * optional double max_price_relative = 1;
 * @return {number}
 */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.getMaxPriceRelative = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.walletrpc.SetMaxPriceRelativeRequest.prototype.setMaxPriceRelative = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPriceRelativeResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPriceRelativeResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPriceRelativeResponse.displayName = 'proto.walletrpc.SetMaxPriceRelativeResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPriceRelativeResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPriceRelativeResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPriceRelativeResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPriceRelativeResponse}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPriceRelativeResponse;
  return proto.walletrpc.SetMaxPriceRelativeResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPriceRelativeResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPriceRelativeResponse}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPriceRelativeResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetMaxPriceRelativeResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPriceRelativeResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPriceRelativeResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPriceAbsoluteRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPriceAbsoluteRequest.displayName = 'proto.walletrpc.SetMaxPriceAbsoluteRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPriceAbsoluteRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    maxPriceAbsolute: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteRequest}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPriceAbsoluteRequest;
  return proto.walletrpc.SetMaxPriceAbsoluteRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteRequest}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPriceAbsolute(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetMaxPriceAbsoluteRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMaxPriceAbsolute();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * optional int64 max_price_absolute = 1;
 * @return {number}
 */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.getMaxPriceAbsolute = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.SetMaxPriceAbsoluteRequest.prototype.setMaxPriceAbsolute = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPriceAbsoluteResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPriceAbsoluteResponse.displayName = 'proto.walletrpc.SetMaxPriceAbsoluteResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPriceAbsoluteResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteResponse}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPriceAbsoluteResponse;
  return proto.walletrpc.SetMaxPriceAbsoluteResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPriceAbsoluteResponse}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetMaxPriceAbsoluteResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPriceAbsoluteResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPriceAbsoluteResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVotingAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetVotingAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVotingAddressRequest.displayName = 'proto.walletrpc.SetVotingAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVotingAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVotingAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVotingAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVotingAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    votingAddress: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVotingAddressRequest}
 */
proto.walletrpc.SetVotingAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVotingAddressRequest;
  return proto.walletrpc.SetVotingAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVotingAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVotingAddressRequest}
 */
proto.walletrpc.SetVotingAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVotingAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVotingAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetVotingAddressRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVotingAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVotingAddressRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVotingAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string voting_address = 1;
 * @return {string}
 */
proto.walletrpc.SetVotingAddressRequest.prototype.getVotingAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.SetVotingAddressRequest.prototype.setVotingAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVotingAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetVotingAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVotingAddressResponse.displayName = 'proto.walletrpc.SetVotingAddressResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVotingAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVotingAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVotingAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVotingAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVotingAddressResponse}
 */
proto.walletrpc.SetVotingAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVotingAddressResponse;
  return proto.walletrpc.SetVotingAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVotingAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVotingAddressResponse}
 */
proto.walletrpc.SetVotingAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVotingAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetVotingAddressResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVotingAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVotingAddressResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetPoolAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetPoolAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetPoolAddressRequest.displayName = 'proto.walletrpc.SetPoolAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetPoolAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetPoolAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetPoolAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetPoolAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    poolAddress: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetPoolAddressRequest}
 */
proto.walletrpc.SetPoolAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetPoolAddressRequest;
  return proto.walletrpc.SetPoolAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetPoolAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetPoolAddressRequest}
 */
proto.walletrpc.SetPoolAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPoolAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetPoolAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetPoolAddressRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetPoolAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetPoolAddressRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPoolAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string pool_address = 1;
 * @return {string}
 */
proto.walletrpc.SetPoolAddressRequest.prototype.getPoolAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.SetPoolAddressRequest.prototype.setPoolAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetPoolAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetPoolAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetPoolAddressResponse.displayName = 'proto.walletrpc.SetPoolAddressResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetPoolAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetPoolAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetPoolAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetPoolAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetPoolAddressResponse}
 */
proto.walletrpc.SetPoolAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetPoolAddressResponse;
  return proto.walletrpc.SetPoolAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetPoolAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetPoolAddressResponse}
 */
proto.walletrpc.SetPoolAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetPoolAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetPoolAddressResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetPoolAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetPoolAddressResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetPoolFeesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetPoolFeesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetPoolFeesRequest.displayName = 'proto.walletrpc.SetPoolFeesRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetPoolFeesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetPoolFeesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetPoolFeesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetPoolFeesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    poolFees: +jspb.Message.getFieldWithDefault(msg, 1, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetPoolFeesRequest}
 */
proto.walletrpc.SetPoolFeesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetPoolFeesRequest;
  return proto.walletrpc.SetPoolFeesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetPoolFeesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetPoolFeesRequest}
 */
proto.walletrpc.SetPoolFeesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setPoolFees(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetPoolFeesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetPoolFeesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetPoolFeesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetPoolFeesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPoolFees();
  if (f !== 0.0) {
    writer.writeDouble(
      1,
      f
    );
  }
};


/**
 * optional double pool_fees = 1;
 * @return {number}
 */
proto.walletrpc.SetPoolFeesRequest.prototype.getPoolFees = function() {
  return /** @type {number} */ (+jspb.Message.getFieldWithDefault(this, 1, 0.0));
};


/** @param {number} value */
proto.walletrpc.SetPoolFeesRequest.prototype.setPoolFees = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetPoolFeesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetPoolFeesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetPoolFeesResponse.displayName = 'proto.walletrpc.SetPoolFeesResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetPoolFeesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetPoolFeesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetPoolFeesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetPoolFeesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetPoolFeesResponse}
 */
proto.walletrpc.SetPoolFeesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetPoolFeesResponse;
  return proto.walletrpc.SetPoolFeesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetPoolFeesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetPoolFeesResponse}
 */
proto.walletrpc.SetPoolFeesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetPoolFeesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetPoolFeesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetPoolFeesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetPoolFeesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPerBlockRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPerBlockRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPerBlockRequest.displayName = 'proto.walletrpc.SetMaxPerBlockRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPerBlockRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPerBlockRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPerBlockRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPerBlockRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    maxPerBlock: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPerBlockRequest}
 */
proto.walletrpc.SetMaxPerBlockRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPerBlockRequest;
  return proto.walletrpc.SetMaxPerBlockRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPerBlockRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPerBlockRequest}
 */
proto.walletrpc.SetMaxPerBlockRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setMaxPerBlock(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPerBlockRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetMaxPerBlockRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPerBlockRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPerBlockRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMaxPerBlock();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
};


/**
 * optional int64 max_per_block = 1;
 * @return {number}
 */
proto.walletrpc.SetMaxPerBlockRequest.prototype.getMaxPerBlock = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.SetMaxPerBlockRequest.prototype.setMaxPerBlock = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetMaxPerBlockResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetMaxPerBlockResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetMaxPerBlockResponse.displayName = 'proto.walletrpc.SetMaxPerBlockResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetMaxPerBlockResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetMaxPerBlockResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetMaxPerBlockResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPerBlockResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetMaxPerBlockResponse}
 */
proto.walletrpc.SetMaxPerBlockResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetMaxPerBlockResponse;
  return proto.walletrpc.SetMaxPerBlockResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetMaxPerBlockResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetMaxPerBlockResponse}
 */
proto.walletrpc.SetMaxPerBlockResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetMaxPerBlockResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetMaxPerBlockResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetMaxPerBlockResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetMaxPerBlockResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AgendasRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AgendasRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AgendasRequest.displayName = 'proto.walletrpc.AgendasRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AgendasRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AgendasRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AgendasRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AgendasRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AgendasRequest}
 */
proto.walletrpc.AgendasRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AgendasRequest;
  return proto.walletrpc.AgendasRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AgendasRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AgendasRequest}
 */
proto.walletrpc.AgendasRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AgendasRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AgendasRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AgendasRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AgendasRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AgendasResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.AgendasResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.AgendasResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AgendasResponse.displayName = 'proto.walletrpc.AgendasResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.AgendasResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AgendasResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AgendasResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AgendasResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: jspb.Message.getFieldWithDefault(msg, 1, 0),
    agendasList: jspb.Message.toObjectList(msg.getAgendasList(),
    proto.walletrpc.AgendasResponse.Agenda.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AgendasResponse}
 */
proto.walletrpc.AgendasResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AgendasResponse;
  return proto.walletrpc.AgendasResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AgendasResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AgendasResponse}
 */
proto.walletrpc.AgendasResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 2:
      var value = new proto.walletrpc.AgendasResponse.Agenda;
      reader.readMessage(value,proto.walletrpc.AgendasResponse.Agenda.deserializeBinaryFromReader);
      msg.addAgendas(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AgendasResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AgendasResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AgendasResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AgendasResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVersion();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getAgendasList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.AgendasResponse.Agenda.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AgendasResponse.Agenda = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.AgendasResponse.Agenda.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.AgendasResponse.Agenda, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AgendasResponse.Agenda.displayName = 'proto.walletrpc.AgendasResponse.Agenda';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.AgendasResponse.Agenda.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AgendasResponse.Agenda.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AgendasResponse.Agenda} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AgendasResponse.Agenda.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    description: jspb.Message.getFieldWithDefault(msg, 2, ""),
    mask: jspb.Message.getFieldWithDefault(msg, 3, 0),
    choicesList: jspb.Message.toObjectList(msg.getChoicesList(),
    proto.walletrpc.AgendasResponse.Choice.toObject, includeInstance),
    startTime: jspb.Message.getFieldWithDefault(msg, 5, 0),
    expireTime: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AgendasResponse.Agenda}
 */
proto.walletrpc.AgendasResponse.Agenda.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AgendasResponse.Agenda;
  return proto.walletrpc.AgendasResponse.Agenda.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AgendasResponse.Agenda} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AgendasResponse.Agenda}
 */
proto.walletrpc.AgendasResponse.Agenda.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDescription(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMask(value);
      break;
    case 4:
      var value = new proto.walletrpc.AgendasResponse.Choice;
      reader.readMessage(value,proto.walletrpc.AgendasResponse.Choice.deserializeBinaryFromReader);
      msg.addChoices(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setStartTime(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setExpireTime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AgendasResponse.Agenda.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AgendasResponse.Agenda} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AgendasResponse.Agenda.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDescription();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getMask();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getChoicesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.walletrpc.AgendasResponse.Choice.serializeBinaryToWriter
    );
  }
  f = message.getStartTime();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getExpireTime();
  if (f !== 0) {
    writer.writeInt64(
      6,
      f
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.AgendasResponse.Agenda.prototype.setId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string description = 2;
 * @return {string}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.AgendasResponse.Agenda.prototype.setDescription = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 mask = 3;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getMask = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.AgendasResponse.Agenda.prototype.setMask = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * repeated Choice choices = 4;
 * @return {!Array.<!proto.walletrpc.AgendasResponse.Choice>}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getChoicesList = function() {
  return /** @type{!Array.<!proto.walletrpc.AgendasResponse.Choice>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.AgendasResponse.Choice, 4));
};


/** @param {!Array.<!proto.walletrpc.AgendasResponse.Choice>} value */
proto.walletrpc.AgendasResponse.Agenda.prototype.setChoicesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.walletrpc.AgendasResponse.Choice=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.AgendasResponse.Choice}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.addChoices = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.walletrpc.AgendasResponse.Choice, opt_index);
};


proto.walletrpc.AgendasResponse.Agenda.prototype.clearChoicesList = function() {
  this.setChoicesList([]);
};


/**
 * optional int64 start_time = 5;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getStartTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.AgendasResponse.Agenda.prototype.setStartTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int64 expire_time = 6;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.Agenda.prototype.getExpireTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.AgendasResponse.Agenda.prototype.setExpireTime = function(value) {
  jspb.Message.setField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.AgendasResponse.Choice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.AgendasResponse.Choice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.AgendasResponse.Choice.displayName = 'proto.walletrpc.AgendasResponse.Choice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.AgendasResponse.Choice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.AgendasResponse.Choice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AgendasResponse.Choice.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: jspb.Message.getFieldWithDefault(msg, 1, ""),
    description: jspb.Message.getFieldWithDefault(msg, 2, ""),
    bits: jspb.Message.getFieldWithDefault(msg, 3, 0),
    isAbstain: jspb.Message.getFieldWithDefault(msg, 4, false),
    isNo: jspb.Message.getFieldWithDefault(msg, 5, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.AgendasResponse.Choice}
 */
proto.walletrpc.AgendasResponse.Choice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.AgendasResponse.Choice;
  return proto.walletrpc.AgendasResponse.Choice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.AgendasResponse.Choice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.AgendasResponse.Choice}
 */
proto.walletrpc.AgendasResponse.Choice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDescription(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBits(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsAbstain(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsNo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.AgendasResponse.Choice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.AgendasResponse.Choice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.AgendasResponse.Choice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDescription();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getBits();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getIsAbstain();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getIsNo();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.AgendasResponse.Choice.prototype.setId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string description = 2;
 * @return {string}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.AgendasResponse.Choice.prototype.setDescription = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 bits = 3;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getBits = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.AgendasResponse.Choice.prototype.setBits = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bool is_abstain = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getIsAbstain = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.walletrpc.AgendasResponse.Choice.prototype.setIsAbstain = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bool is_no = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.AgendasResponse.Choice.prototype.getIsNo = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.walletrpc.AgendasResponse.Choice.prototype.setIsNo = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 version = 1;
 * @return {number}
 */
proto.walletrpc.AgendasResponse.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.AgendasResponse.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated Agenda agendas = 2;
 * @return {!Array.<!proto.walletrpc.AgendasResponse.Agenda>}
 */
proto.walletrpc.AgendasResponse.prototype.getAgendasList = function() {
  return /** @type{!Array.<!proto.walletrpc.AgendasResponse.Agenda>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.AgendasResponse.Agenda, 2));
};


/** @param {!Array.<!proto.walletrpc.AgendasResponse.Agenda>} value */
proto.walletrpc.AgendasResponse.prototype.setAgendasList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.walletrpc.AgendasResponse.Agenda=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.AgendasResponse.Agenda}
 */
proto.walletrpc.AgendasResponse.prototype.addAgendas = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.walletrpc.AgendasResponse.Agenda, opt_index);
};


proto.walletrpc.AgendasResponse.prototype.clearAgendasList = function() {
  this.setAgendasList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VoteChoicesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VoteChoicesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VoteChoicesRequest.displayName = 'proto.walletrpc.VoteChoicesRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VoteChoicesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VoteChoicesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VoteChoicesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VoteChoicesRequest}
 */
proto.walletrpc.VoteChoicesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VoteChoicesRequest;
  return proto.walletrpc.VoteChoicesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VoteChoicesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VoteChoicesRequest}
 */
proto.walletrpc.VoteChoicesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VoteChoicesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.VoteChoicesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VoteChoicesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VoteChoicesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VoteChoicesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.VoteChoicesResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.VoteChoicesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VoteChoicesResponse.displayName = 'proto.walletrpc.VoteChoicesResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.VoteChoicesResponse.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VoteChoicesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VoteChoicesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VoteChoicesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: jspb.Message.getFieldWithDefault(msg, 1, 0),
    choicesList: jspb.Message.toObjectList(msg.getChoicesList(),
    proto.walletrpc.VoteChoicesResponse.Choice.toObject, includeInstance),
    votebits: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VoteChoicesResponse}
 */
proto.walletrpc.VoteChoicesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VoteChoicesResponse;
  return proto.walletrpc.VoteChoicesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VoteChoicesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VoteChoicesResponse}
 */
proto.walletrpc.VoteChoicesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 2:
      var value = new proto.walletrpc.VoteChoicesResponse.Choice;
      reader.readMessage(value,proto.walletrpc.VoteChoicesResponse.Choice.deserializeBinaryFromReader);
      msg.addChoices(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVotebits(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VoteChoicesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.VoteChoicesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VoteChoicesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VoteChoicesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVersion();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getChoicesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.walletrpc.VoteChoicesResponse.Choice.serializeBinaryToWriter
    );
  }
  f = message.getVotebits();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VoteChoicesResponse.Choice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VoteChoicesResponse.Choice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VoteChoicesResponse.Choice.displayName = 'proto.walletrpc.VoteChoicesResponse.Choice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VoteChoicesResponse.Choice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VoteChoicesResponse.Choice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VoteChoicesResponse.Choice.toObject = function(includeInstance, msg) {
  var f, obj = {
    agendaId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    agendaDescription: jspb.Message.getFieldWithDefault(msg, 2, ""),
    choiceId: jspb.Message.getFieldWithDefault(msg, 3, ""),
    choiceDescription: jspb.Message.getFieldWithDefault(msg, 4, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VoteChoicesResponse.Choice}
 */
proto.walletrpc.VoteChoicesResponse.Choice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VoteChoicesResponse.Choice;
  return proto.walletrpc.VoteChoicesResponse.Choice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VoteChoicesResponse.Choice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VoteChoicesResponse.Choice}
 */
proto.walletrpc.VoteChoicesResponse.Choice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAgendaId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAgendaDescription(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setChoiceId(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setChoiceDescription(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.VoteChoicesResponse.Choice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VoteChoicesResponse.Choice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VoteChoicesResponse.Choice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAgendaId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAgendaDescription();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getChoiceId();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getChoiceDescription();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string agenda_id = 1;
 * @return {string}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.getAgendaId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.setAgendaId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string agenda_description = 2;
 * @return {string}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.getAgendaDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.setAgendaDescription = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional string choice_id = 3;
 * @return {string}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.getChoiceId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.setChoiceId = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string choice_description = 4;
 * @return {string}
 */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.getChoiceDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.walletrpc.VoteChoicesResponse.Choice.prototype.setChoiceDescription = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional uint32 version = 1;
 * @return {number}
 */
proto.walletrpc.VoteChoicesResponse.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.VoteChoicesResponse.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * repeated Choice choices = 2;
 * @return {!Array.<!proto.walletrpc.VoteChoicesResponse.Choice>}
 */
proto.walletrpc.VoteChoicesResponse.prototype.getChoicesList = function() {
  return /** @type{!Array.<!proto.walletrpc.VoteChoicesResponse.Choice>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.VoteChoicesResponse.Choice, 2));
};


/** @param {!Array.<!proto.walletrpc.VoteChoicesResponse.Choice>} value */
proto.walletrpc.VoteChoicesResponse.prototype.setChoicesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.walletrpc.VoteChoicesResponse.Choice=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.VoteChoicesResponse.Choice}
 */
proto.walletrpc.VoteChoicesResponse.prototype.addChoices = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.walletrpc.VoteChoicesResponse.Choice, opt_index);
};


proto.walletrpc.VoteChoicesResponse.prototype.clearChoicesList = function() {
  this.setChoicesList([]);
};


/**
 * optional uint32 votebits = 3;
 * @return {number}
 */
proto.walletrpc.VoteChoicesResponse.prototype.getVotebits = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.VoteChoicesResponse.prototype.setVotebits = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVoteChoicesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.SetVoteChoicesRequest.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.SetVoteChoicesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVoteChoicesRequest.displayName = 'proto.walletrpc.SetVoteChoicesRequest';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.SetVoteChoicesRequest.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVoteChoicesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVoteChoicesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVoteChoicesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    choicesList: jspb.Message.toObjectList(msg.getChoicesList(),
    proto.walletrpc.SetVoteChoicesRequest.Choice.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVoteChoicesRequest}
 */
proto.walletrpc.SetVoteChoicesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVoteChoicesRequest;
  return proto.walletrpc.SetVoteChoicesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVoteChoicesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVoteChoicesRequest}
 */
proto.walletrpc.SetVoteChoicesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.SetVoteChoicesRequest.Choice;
      reader.readMessage(value,proto.walletrpc.SetVoteChoicesRequest.Choice.deserializeBinaryFromReader);
      msg.addChoices(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetVoteChoicesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVoteChoicesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVoteChoicesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChoicesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.walletrpc.SetVoteChoicesRequest.Choice.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVoteChoicesRequest.Choice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetVoteChoicesRequest.Choice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVoteChoicesRequest.Choice.displayName = 'proto.walletrpc.SetVoteChoicesRequest.Choice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVoteChoicesRequest.Choice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVoteChoicesRequest.Choice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.toObject = function(includeInstance, msg) {
  var f, obj = {
    agendaId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    choiceId: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVoteChoicesRequest.Choice}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVoteChoicesRequest.Choice;
  return proto.walletrpc.SetVoteChoicesRequest.Choice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVoteChoicesRequest.Choice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVoteChoicesRequest.Choice}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAgendaId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setChoiceId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetVoteChoicesRequest.Choice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVoteChoicesRequest.Choice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAgendaId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getChoiceId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional string agenda_id = 1;
 * @return {string}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.getAgendaId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.setAgendaId = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string choice_id = 2;
 * @return {string}
 */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.getChoiceId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.SetVoteChoicesRequest.Choice.prototype.setChoiceId = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * repeated Choice choices = 1;
 * @return {!Array.<!proto.walletrpc.SetVoteChoicesRequest.Choice>}
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.getChoicesList = function() {
  return /** @type{!Array.<!proto.walletrpc.SetVoteChoicesRequest.Choice>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.SetVoteChoicesRequest.Choice, 1));
};


/** @param {!Array.<!proto.walletrpc.SetVoteChoicesRequest.Choice>} value */
proto.walletrpc.SetVoteChoicesRequest.prototype.setChoicesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.walletrpc.SetVoteChoicesRequest.Choice=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.SetVoteChoicesRequest.Choice}
 */
proto.walletrpc.SetVoteChoicesRequest.prototype.addChoices = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.walletrpc.SetVoteChoicesRequest.Choice, opt_index);
};


proto.walletrpc.SetVoteChoicesRequest.prototype.clearChoicesList = function() {
  this.setChoicesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.SetVoteChoicesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.SetVoteChoicesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.SetVoteChoicesResponse.displayName = 'proto.walletrpc.SetVoteChoicesResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.SetVoteChoicesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.SetVoteChoicesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.SetVoteChoicesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVoteChoicesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    votebits: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.SetVoteChoicesResponse}
 */
proto.walletrpc.SetVoteChoicesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.SetVoteChoicesResponse;
  return proto.walletrpc.SetVoteChoicesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.SetVoteChoicesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.SetVoteChoicesResponse}
 */
proto.walletrpc.SetVoteChoicesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVotebits(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.SetVoteChoicesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.SetVoteChoicesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.SetVoteChoicesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.SetVoteChoicesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVotebits();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 votebits = 1;
 * @return {number}
 */
proto.walletrpc.SetVoteChoicesResponse.prototype.getVotebits = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.SetVoteChoicesResponse.prototype.setVotebits = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VerifyMessageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VerifyMessageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VerifyMessageRequest.displayName = 'proto.walletrpc.VerifyMessageRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VerifyMessageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VerifyMessageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VerifyMessageRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VerifyMessageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, ""),
    message: jspb.Message.getFieldWithDefault(msg, 2, ""),
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VerifyMessageRequest}
 */
proto.walletrpc.VerifyMessageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VerifyMessageRequest;
  return proto.walletrpc.VerifyMessageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VerifyMessageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VerifyMessageRequest}
 */
proto.walletrpc.VerifyMessageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VerifyMessageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.VerifyMessageRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VerifyMessageRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VerifyMessageRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getMessage();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.VerifyMessageRequest.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.walletrpc.VerifyMessageRequest.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional bytes signature = 3;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes signature = 3;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.walletrpc.VerifyMessageRequest.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.VerifyMessageRequest.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.VerifyMessageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.VerifyMessageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.VerifyMessageResponse.displayName = 'proto.walletrpc.VerifyMessageResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.VerifyMessageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.VerifyMessageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.VerifyMessageResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VerifyMessageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    valid: jspb.Message.getFieldWithDefault(msg, 1, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.VerifyMessageResponse}
 */
proto.walletrpc.VerifyMessageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.VerifyMessageResponse;
  return proto.walletrpc.VerifyMessageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.VerifyMessageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.VerifyMessageResponse}
 */
proto.walletrpc.VerifyMessageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setValid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.VerifyMessageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.VerifyMessageResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.VerifyMessageResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.VerifyMessageResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValid();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool valid = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.VerifyMessageResponse.prototype.getValid = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.walletrpc.VerifyMessageResponse.prototype.setValid = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodedTransaction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.DecodedTransaction.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.DecodedTransaction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodedTransaction.displayName = 'proto.walletrpc.DecodedTransaction';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.DecodedTransaction.repeatedFields_ = [6,7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodedTransaction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodedTransaction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodedTransaction.toObject = function(includeInstance, msg) {
  var f, obj = {
    transactionHash: msg.getTransactionHash_asB64(),
    version: jspb.Message.getFieldWithDefault(msg, 2, 0),
    lockTime: jspb.Message.getFieldWithDefault(msg, 3, 0),
    expiry: jspb.Message.getFieldWithDefault(msg, 4, 0),
    transactionType: jspb.Message.getFieldWithDefault(msg, 5, 0),
    inputsList: jspb.Message.toObjectList(msg.getInputsList(),
    proto.walletrpc.DecodedTransaction.Input.toObject, includeInstance),
    outputsList: jspb.Message.toObjectList(msg.getOutputsList(),
    proto.walletrpc.DecodedTransaction.Output.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodedTransaction}
 */
proto.walletrpc.DecodedTransaction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodedTransaction;
  return proto.walletrpc.DecodedTransaction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodedTransaction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodedTransaction}
 */
proto.walletrpc.DecodedTransaction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setVersion(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLockTime(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpiry(value);
      break;
    case 5:
      var value = /** @type {!proto.walletrpc.TransactionDetails.TransactionType} */ (reader.readEnum());
      msg.setTransactionType(value);
      break;
    case 6:
      var value = new proto.walletrpc.DecodedTransaction.Input;
      reader.readMessage(value,proto.walletrpc.DecodedTransaction.Input.deserializeBinaryFromReader);
      msg.addInputs(value);
      break;
    case 7:
      var value = new proto.walletrpc.DecodedTransaction.Output;
      reader.readMessage(value,proto.walletrpc.DecodedTransaction.Output.deserializeBinaryFromReader);
      msg.addOutputs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DecodedTransaction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodedTransaction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodedTransaction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getVersion();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getLockTime();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getTransactionType();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = message.getInputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      6,
      f,
      proto.walletrpc.DecodedTransaction.Input.serializeBinaryToWriter
    );
  }
  f = message.getOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      7,
      f,
      proto.walletrpc.DecodedTransaction.Output.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodedTransaction.Input = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodedTransaction.Input, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodedTransaction.Input.displayName = 'proto.walletrpc.DecodedTransaction.Input';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodedTransaction.Input.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodedTransaction.Input} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodedTransaction.Input.toObject = function(includeInstance, msg) {
  var f, obj = {
    previousTransactionHash: msg.getPreviousTransactionHash_asB64(),
    previousTransactionIndex: jspb.Message.getFieldWithDefault(msg, 2, 0),
    tree: jspb.Message.getFieldWithDefault(msg, 3, 0),
    sequence: jspb.Message.getFieldWithDefault(msg, 4, 0),
    amountIn: jspb.Message.getFieldWithDefault(msg, 5, 0),
    blockHeight: jspb.Message.getFieldWithDefault(msg, 6, 0),
    blockIndex: jspb.Message.getFieldWithDefault(msg, 7, 0),
    signatureScript: msg.getSignatureScript_asB64(),
    signatureScriptAsm: jspb.Message.getFieldWithDefault(msg, 9, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodedTransaction.Input}
 */
proto.walletrpc.DecodedTransaction.Input.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodedTransaction.Input;
  return proto.walletrpc.DecodedTransaction.Input.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodedTransaction.Input} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodedTransaction.Input}
 */
proto.walletrpc.DecodedTransaction.Input.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPreviousTransactionHash(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPreviousTransactionIndex(value);
      break;
    case 3:
      var value = /** @type {!proto.walletrpc.DecodedTransaction.Input.TreeType} */ (reader.readEnum());
      msg.setTree(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSequence(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmountIn(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBlockHeight(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBlockIndex(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignatureScript(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setSignatureScriptAsm(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DecodedTransaction.Input.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodedTransaction.Input} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodedTransaction.Input.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPreviousTransactionHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPreviousTransactionIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getTree();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = message.getSequence();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = message.getAmountIn();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
  f = message.getBlockHeight();
  if (f !== 0) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = message.getBlockIndex();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = message.getSignatureScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      8,
      f
    );
  }
  f = message.getSignatureScriptAsm();
  if (f.length > 0) {
    writer.writeString(
      9,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.DecodedTransaction.Input.TreeType = {
  REGULAR: 0,
  UNKNOWN: -1,
  STAKE: 1
};

/**
 * optional bytes previous_transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getPreviousTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes previous_transaction_hash = 1;
 * This is a type-conversion wrapper around `getPreviousTransactionHash()`
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getPreviousTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPreviousTransactionHash()));
};


/**
 * optional bytes previous_transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPreviousTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getPreviousTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPreviousTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setPreviousTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 previous_transaction_index = 2;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getPreviousTransactionIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setPreviousTransactionIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional TreeType tree = 3;
 * @return {!proto.walletrpc.DecodedTransaction.Input.TreeType}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getTree = function() {
  return /** @type {!proto.walletrpc.DecodedTransaction.Input.TreeType} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {!proto.walletrpc.DecodedTransaction.Input.TreeType} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setTree = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 sequence = 4;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSequence = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setSequence = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional int64 amount_in = 5;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getAmountIn = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setAmountIn = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional uint32 block_height = 6;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getBlockHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setBlockHeight = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional uint32 block_index = 7;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getBlockIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setBlockIndex = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * optional bytes signature_script = 8;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSignatureScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * optional bytes signature_script = 8;
 * This is a type-conversion wrapper around `getSignatureScript()`
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSignatureScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignatureScript()));
};


/**
 * optional bytes signature_script = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignatureScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSignatureScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignatureScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setSignatureScript = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional string signature_script_asm = 9;
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Input.prototype.getSignatureScriptAsm = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/** @param {string} value */
proto.walletrpc.DecodedTransaction.Input.prototype.setSignatureScriptAsm = function(value) {
  jspb.Message.setField(this, 9, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodedTransaction.Output = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.DecodedTransaction.Output.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.DecodedTransaction.Output, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodedTransaction.Output.displayName = 'proto.walletrpc.DecodedTransaction.Output';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.DecodedTransaction.Output.repeatedFields_ = [8];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodedTransaction.Output.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodedTransaction.Output} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodedTransaction.Output.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, 0),
    index: jspb.Message.getFieldWithDefault(msg, 2, 0),
    version: jspb.Message.getFieldWithDefault(msg, 3, 0),
    script: msg.getScript_asB64(),
    scriptAsm: jspb.Message.getFieldWithDefault(msg, 5, ""),
    requiredSignatures: jspb.Message.getFieldWithDefault(msg, 6, 0),
    scriptClass: jspb.Message.getFieldWithDefault(msg, 7, 0),
    addressesList: jspb.Message.getRepeatedField(msg, 8),
    commitmentAmount: jspb.Message.getFieldWithDefault(msg, 9, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodedTransaction.Output}
 */
proto.walletrpc.DecodedTransaction.Output.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodedTransaction.Output;
  return proto.walletrpc.DecodedTransaction.Output.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodedTransaction.Output} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodedTransaction.Output}
 */
proto.walletrpc.DecodedTransaction.Output.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setValue(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setVersion(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setScriptAsm(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setRequiredSignatures(value);
      break;
    case 7:
      var value = /** @type {!proto.walletrpc.DecodedTransaction.Output.ScriptClass} */ (reader.readEnum());
      msg.setScriptClass(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.addAddresses(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setCommitmentAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DecodedTransaction.Output.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodedTransaction.Output} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodedTransaction.Output.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = message.getIndex();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getVersion();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getScriptAsm();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getRequiredSignatures();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = message.getScriptClass();
  if (f !== 0.0) {
    writer.writeEnum(
      7,
      f
    );
  }
  f = message.getAddressesList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      8,
      f
    );
  }
  f = message.getCommitmentAmount();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.DecodedTransaction.Output.ScriptClass = {
  NON_STANDARD: 0,
  PUB_KEY: 1,
  PUB_KEY_HASH: 2,
  SCRIPT_HASH: 3,
  MULTI_SIG: 4,
  NULL_DATA: 5,
  STAKE_SUBMISSION: 6,
  STAKE_GEN: 7,
  STAKE_REVOCATION: 8,
  STAKE_SUB_CHANGE: 9,
  PUB_KEY_ALT: 10,
  PUB_KEY_HASH_ALT: 11
};

/**
 * optional int64 value = 1;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setValue = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional uint32 index = 2;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional int32 version = 3;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional bytes script = 4;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes script = 4;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setScript = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional string script_asm = 5;
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScriptAsm = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setScriptAsm = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional int32 required_signatures = 6;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getRequiredSignatures = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setRequiredSignatures = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * optional ScriptClass script_class = 7;
 * @return {!proto.walletrpc.DecodedTransaction.Output.ScriptClass}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getScriptClass = function() {
  return /** @type {!proto.walletrpc.DecodedTransaction.Output.ScriptClass} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {!proto.walletrpc.DecodedTransaction.Output.ScriptClass} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setScriptClass = function(value) {
  jspb.Message.setField(this, 7, value);
};


/**
 * repeated string addresses = 8;
 * @return {!Array.<string>}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getAddressesList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 8));
};


/** @param {!Array.<string>} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setAddressesList = function(value) {
  jspb.Message.setField(this, 8, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.walletrpc.DecodedTransaction.Output.prototype.addAddresses = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 8, value, opt_index);
};


proto.walletrpc.DecodedTransaction.Output.prototype.clearAddressesList = function() {
  this.setAddressesList([]);
};


/**
 * optional int64 commitment_amount = 9;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.Output.prototype.getCommitmentAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.Output.prototype.setCommitmentAmount = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional bytes transaction_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodedTransaction.prototype.getTransactionHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes transaction_hash = 1;
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {string}
 */
proto.walletrpc.DecodedTransaction.prototype.getTransactionHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTransactionHash()));
};


/**
 * optional bytes transaction_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionHash()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodedTransaction.prototype.getTransactionHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTransactionHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DecodedTransaction.prototype.setTransactionHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional int32 version = 2;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 lock_time = 3;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.prototype.getLockTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.prototype.setLockTime = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional uint32 expiry = 4;
 * @return {number}
 */
proto.walletrpc.DecodedTransaction.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.walletrpc.DecodedTransaction.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional TransactionDetails.TransactionType transaction_type = 5;
 * @return {!proto.walletrpc.TransactionDetails.TransactionType}
 */
proto.walletrpc.DecodedTransaction.prototype.getTransactionType = function() {
  return /** @type {!proto.walletrpc.TransactionDetails.TransactionType} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {!proto.walletrpc.TransactionDetails.TransactionType} value */
proto.walletrpc.DecodedTransaction.prototype.setTransactionType = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * repeated Input inputs = 6;
 * @return {!Array.<!proto.walletrpc.DecodedTransaction.Input>}
 */
proto.walletrpc.DecodedTransaction.prototype.getInputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.DecodedTransaction.Input>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.DecodedTransaction.Input, 6));
};


/** @param {!Array.<!proto.walletrpc.DecodedTransaction.Input>} value */
proto.walletrpc.DecodedTransaction.prototype.setInputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 6, value);
};


/**
 * @param {!proto.walletrpc.DecodedTransaction.Input=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.DecodedTransaction.Input}
 */
proto.walletrpc.DecodedTransaction.prototype.addInputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.walletrpc.DecodedTransaction.Input, opt_index);
};


proto.walletrpc.DecodedTransaction.prototype.clearInputsList = function() {
  this.setInputsList([]);
};


/**
 * repeated Output outputs = 7;
 * @return {!Array.<!proto.walletrpc.DecodedTransaction.Output>}
 */
proto.walletrpc.DecodedTransaction.prototype.getOutputsList = function() {
  return /** @type{!Array.<!proto.walletrpc.DecodedTransaction.Output>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.walletrpc.DecodedTransaction.Output, 7));
};


/** @param {!Array.<!proto.walletrpc.DecodedTransaction.Output>} value */
proto.walletrpc.DecodedTransaction.prototype.setOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 7, value);
};


/**
 * @param {!proto.walletrpc.DecodedTransaction.Output=} opt_value
 * @param {number=} opt_index
 * @return {!proto.walletrpc.DecodedTransaction.Output}
 */
proto.walletrpc.DecodedTransaction.prototype.addOutputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.walletrpc.DecodedTransaction.Output, opt_index);
};


proto.walletrpc.DecodedTransaction.prototype.clearOutputsList = function() {
  this.setOutputsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeRawTransactionRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeRawTransactionRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeRawTransactionRequest.displayName = 'proto.walletrpc.DecodeRawTransactionRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeRawTransactionRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeRawTransactionRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodeRawTransactionRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    serializedTransaction: msg.getSerializedTransaction_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeRawTransactionRequest}
 */
proto.walletrpc.DecodeRawTransactionRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeRawTransactionRequest;
  return proto.walletrpc.DecodeRawTransactionRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeRawTransactionRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeRawTransactionRequest}
 */
proto.walletrpc.DecodeRawTransactionRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DecodeRawTransactionRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeRawTransactionRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodeRawTransactionRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSerializedTransaction_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes serialized_transaction = 1;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.getSerializedTransaction = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes serialized_transaction = 1;
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {string}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.getSerializedTransaction_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTransaction()));
};


/**
 * optional bytes serialized_transaction = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTransaction()`
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeRawTransactionRequest.prototype.getSerializedTransaction_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTransaction()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.DecodeRawTransactionRequest.prototype.setSerializedTransaction = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.DecodeRawTransactionResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.DecodeRawTransactionResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.DecodeRawTransactionResponse.displayName = 'proto.walletrpc.DecodeRawTransactionResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.DecodeRawTransactionResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.DecodeRawTransactionResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodeRawTransactionResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    transaction: (f = msg.getTransaction()) && proto.walletrpc.DecodedTransaction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.DecodeRawTransactionResponse}
 */
proto.walletrpc.DecodeRawTransactionResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.DecodeRawTransactionResponse;
  return proto.walletrpc.DecodeRawTransactionResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.DecodeRawTransactionResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.DecodeRawTransactionResponse}
 */
proto.walletrpc.DecodeRawTransactionResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.walletrpc.DecodedTransaction;
      reader.readMessage(value,proto.walletrpc.DecodedTransaction.deserializeBinaryFromReader);
      msg.setTransaction(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.DecodeRawTransactionResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.DecodeRawTransactionResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.DecodeRawTransactionResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransaction();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.walletrpc.DecodedTransaction.serializeBinaryToWriter
    );
  }
};


/**
 * optional DecodedTransaction transaction = 1;
 * @return {?proto.walletrpc.DecodedTransaction}
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.getTransaction = function() {
  return /** @type{?proto.walletrpc.DecodedTransaction} */ (
    jspb.Message.getWrapperField(this, proto.walletrpc.DecodedTransaction, 1));
};


/** @param {?proto.walletrpc.DecodedTransaction|undefined} value */
proto.walletrpc.DecodeRawTransactionResponse.prototype.setTransaction = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.walletrpc.DecodeRawTransactionResponse.prototype.clearTransaction = function() {
  this.setTransaction(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.walletrpc.DecodeRawTransactionResponse.prototype.hasTransaction = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ValidateAddressRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.walletrpc.ValidateAddressRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ValidateAddressRequest.displayName = 'proto.walletrpc.ValidateAddressRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ValidateAddressRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ValidateAddressRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ValidateAddressRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ValidateAddressRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ValidateAddressRequest}
 */
proto.walletrpc.ValidateAddressRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ValidateAddressRequest;
  return proto.walletrpc.ValidateAddressRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ValidateAddressRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ValidateAddressRequest}
 */
proto.walletrpc.ValidateAddressRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ValidateAddressRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ValidateAddressRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ValidateAddressRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ValidateAddressRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.walletrpc.ValidateAddressRequest.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.walletrpc.ValidateAddressRequest.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.walletrpc.ValidateAddressResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.walletrpc.ValidateAddressResponse.repeatedFields_, null);
};
goog.inherits(proto.walletrpc.ValidateAddressResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.walletrpc.ValidateAddressResponse.displayName = 'proto.walletrpc.ValidateAddressResponse';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.walletrpc.ValidateAddressResponse.repeatedFields_ = [7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.walletrpc.ValidateAddressResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.walletrpc.ValidateAddressResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.walletrpc.ValidateAddressResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ValidateAddressResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    isValid: jspb.Message.getFieldWithDefault(msg, 1, false),
    isMine: jspb.Message.getFieldWithDefault(msg, 2, false),
    accountNumber: jspb.Message.getFieldWithDefault(msg, 3, 0),
    pubKeyAddr: jspb.Message.getFieldWithDefault(msg, 4, ""),
    pubKey: msg.getPubKey_asB64(),
    isScript: jspb.Message.getFieldWithDefault(msg, 6, false),
    pkScriptAddrsList: jspb.Message.getRepeatedField(msg, 7),
    scriptType: jspb.Message.getFieldWithDefault(msg, 8, 0),
    payToAddrScript: msg.getPayToAddrScript_asB64(),
    sigsRequired: jspb.Message.getFieldWithDefault(msg, 10, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.walletrpc.ValidateAddressResponse}
 */
proto.walletrpc.ValidateAddressResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.walletrpc.ValidateAddressResponse;
  return proto.walletrpc.ValidateAddressResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.walletrpc.ValidateAddressResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.walletrpc.ValidateAddressResponse}
 */
proto.walletrpc.ValidateAddressResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsValid(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsMine(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAccountNumber(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPubKeyAddr(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPubKey(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsScript(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.addPkScriptAddrs(value);
      break;
    case 8:
      var value = /** @type {!proto.walletrpc.ValidateAddressResponse.ScriptType} */ (reader.readEnum());
      msg.setScriptType(value);
      break;
    case 9:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayToAddrScript(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSigsRequired(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.walletrpc.ValidateAddressResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.walletrpc.ValidateAddressResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.walletrpc.ValidateAddressResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.walletrpc.ValidateAddressResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIsValid();
  if (f) {
    writer.writeBool(
      1,
      f
    );
  }
  f = message.getIsMine();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getAccountNumber();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = message.getPubKeyAddr();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getPubKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getIsScript();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getPkScriptAddrsList();
  if (f.length > 0) {
    writer.writeRepeatedString(
      7,
      f
    );
  }
  f = message.getScriptType();
  if (f !== 0.0) {
    writer.writeEnum(
      8,
      f
    );
  }
  f = message.getPayToAddrScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      9,
      f
    );
  }
  f = message.getSigsRequired();
  if (f !== 0) {
    writer.writeUint32(
      10,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.walletrpc.ValidateAddressResponse.ScriptType = {
  NONSTANDARDTY: 0,
  PUBKEYTY: 1,
  PUBKEYHASHTY: 2,
  SCRIPTHASHTY: 3,
  MULTISIGTY: 4,
  NULLDATATY: 5,
  STAKESUBMISSIONTY: 6,
  STAKEGENTY: 7,
  STAKEREVOCATIONTY: 8,
  STAKESUBCHANGETY: 9,
  PUBKEYALTTY: 10,
  PUBKEYHASHALTTY: 11
};

/**
 * optional bool is_valid = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getIsValid = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.walletrpc.ValidateAddressResponse.prototype.setIsValid = function(value) {
  jspb.Message.setField(this, 1, value);
};


/**
 * optional bool is_mine = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getIsMine = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.walletrpc.ValidateAddressResponse.prototype.setIsMine = function(value) {
  jspb.Message.setField(this, 2, value);
};


/**
 * optional uint32 account_number = 3;
 * @return {number}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getAccountNumber = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.walletrpc.ValidateAddressResponse.prototype.setAccountNumber = function(value) {
  jspb.Message.setField(this, 3, value);
};


/**
 * optional string pub_key_addr = 4;
 * @return {string}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPubKeyAddr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.walletrpc.ValidateAddressResponse.prototype.setPubKeyAddr = function(value) {
  jspb.Message.setField(this, 4, value);
};


/**
 * optional bytes pub_key = 5;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPubKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes pub_key = 5;
 * This is a type-conversion wrapper around `getPubKey()`
 * @return {string}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPubKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPubKey()));
};


/**
 * optional bytes pub_key = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPubKey()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPubKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPubKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ValidateAddressResponse.prototype.setPubKey = function(value) {
  jspb.Message.setField(this, 5, value);
};


/**
 * optional bool is_script = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getIsScript = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.walletrpc.ValidateAddressResponse.prototype.setIsScript = function(value) {
  jspb.Message.setField(this, 6, value);
};


/**
 * repeated string pk_script_addrs = 7;
 * @return {!Array.<string>}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPkScriptAddrsList = function() {
  return /** @type {!Array.<string>} */ (jspb.Message.getRepeatedField(this, 7));
};


/** @param {!Array.<string>} value */
proto.walletrpc.ValidateAddressResponse.prototype.setPkScriptAddrsList = function(value) {
  jspb.Message.setField(this, 7, value || []);
};


/**
 * @param {!string} value
 * @param {number=} opt_index
 */
proto.walletrpc.ValidateAddressResponse.prototype.addPkScriptAddrs = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 7, value, opt_index);
};


proto.walletrpc.ValidateAddressResponse.prototype.clearPkScriptAddrsList = function() {
  this.setPkScriptAddrsList([]);
};


/**
 * optional ScriptType script_type = 8;
 * @return {!proto.walletrpc.ValidateAddressResponse.ScriptType}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getScriptType = function() {
  return /** @type {!proto.walletrpc.ValidateAddressResponse.ScriptType} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {!proto.walletrpc.ValidateAddressResponse.ScriptType} value */
proto.walletrpc.ValidateAddressResponse.prototype.setScriptType = function(value) {
  jspb.Message.setField(this, 8, value);
};


/**
 * optional bytes pay_to_addr_script = 9;
 * @return {!(string|Uint8Array)}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPayToAddrScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/**
 * optional bytes pay_to_addr_script = 9;
 * This is a type-conversion wrapper around `getPayToAddrScript()`
 * @return {string}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPayToAddrScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayToAddrScript()));
};


/**
 * optional bytes pay_to_addr_script = 9;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayToAddrScript()`
 * @return {!Uint8Array}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getPayToAddrScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayToAddrScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.walletrpc.ValidateAddressResponse.prototype.setPayToAddrScript = function(value) {
  jspb.Message.setField(this, 9, value);
};


/**
 * optional uint32 sigs_required = 10;
 * @return {number}
 */
proto.walletrpc.ValidateAddressResponse.prototype.getSigsRequired = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.walletrpc.ValidateAddressResponse.prototype.setSigsRequired = function(value) {
  jspb.Message.setField(this, 10, value);
};


goog.object.extend(exports, proto.walletrpc);
